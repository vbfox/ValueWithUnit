



namespace BlackFox.Units
{
	using System;
	using System.Globalization;
	using BlackFox.Units.Multiples;

	
		public struct Metres : IValueWithUnit, IEquatable< Metres >, IEquatable<IValueWithUnit>
		{
			public static readonly Metres Zero = new Metres(0);
			public static readonly Metres One = new Metres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.metre; } }

			public Metres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} m", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Metres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Metres(double value)
			{
				return new Metres(value);
			}

			public static Metres operator *(Metres value, double times)
			{
				return new Metres(value.value * times);
			}

			public static Metres operator *(double times, Metres value)
			{
				return new Metres(value.value * times);
			}

			public static Metres operator +(Metres first, Metres second)
			{
				return new Metres(first.value * second.value);
			}

							public static implicit operator Yoctometres(Metres value)
				{
					return (value.value)/1E-24;
				}

				public static Metres operator +(Metres first, Yoctometres second)
				{
					return new Metres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptometres(Metres value)
				{
					return (value.value)/1E-21;
				}

				public static Metres operator +(Metres first, Zeptometres second)
				{
					return new Metres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attometres(Metres value)
				{
					return (value.value)/1E-18;
				}

				public static Metres operator +(Metres first, Attometres second)
				{
					return new Metres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtometres(Metres value)
				{
					return (value.value)/1E-15;
				}

				public static Metres operator +(Metres first, Femtometres second)
				{
					return new Metres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picometres(Metres value)
				{
					return (value.value)/1E-12;
				}

				public static Metres operator +(Metres first, Picometres second)
				{
					return new Metres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanometres(Metres value)
				{
					return (value.value)/1E-09;
				}

				public static Metres operator +(Metres first, Nanometres second)
				{
					return new Metres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Micrometres(Metres value)
				{
					return (value.value)/1E-06;
				}

				public static Metres operator +(Metres first, Micrometres second)
				{
					return new Metres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Millimetres(Metres value)
				{
					return (value.value)/0.001;
				}

				public static Metres operator +(Metres first, Millimetres second)
				{
					return new Metres(first.value + (second.value)*0.001);
				}
								public static implicit operator Centimetres(Metres value)
				{
					return (value.value)/0.01;
				}

				public static Metres operator +(Metres first, Centimetres second)
				{
					return new Metres(first.value + (second.value)*0.01);
				}
								public static implicit operator Decimetres(Metres value)
				{
					return (value.value)/0.1;
				}

				public static Metres operator +(Metres first, Decimetres second)
				{
					return new Metres(first.value + (second.value)*0.1);
				}
								public static implicit operator Decametres(Metres value)
				{
					return (value.value)/10;
				}

				public static Metres operator +(Metres first, Decametres second)
				{
					return new Metres(first.value + (second.value)*10);
				}
								public static implicit operator Hectometres(Metres value)
				{
					return (value.value)/100;
				}

				public static Metres operator +(Metres first, Hectometres second)
				{
					return new Metres(first.value + (second.value)*100);
				}
								public static implicit operator Kilometres(Metres value)
				{
					return (value.value)/1000;
				}

				public static Metres operator +(Metres first, Kilometres second)
				{
					return new Metres(first.value + (second.value)*1000);
				}
								public static implicit operator Megametres(Metres value)
				{
					return (value.value)/1000000;
				}

				public static Metres operator +(Metres first, Megametres second)
				{
					return new Metres(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigametres(Metres value)
				{
					return (value.value)/1000000000;
				}

				public static Metres operator +(Metres first, Gigametres second)
				{
					return new Metres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Terametres(Metres value)
				{
					return (value.value)/1000000000000;
				}

				public static Metres operator +(Metres first, Terametres second)
				{
					return new Metres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petametres(Metres value)
				{
					return (value.value)/1E+15;
				}

				public static Metres operator +(Metres first, Petametres second)
				{
					return new Metres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Exametres(Metres value)
				{
					return (value.value)/1E+18;
				}

				public static Metres operator +(Metres first, Exametres second)
				{
					return new Metres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettametres(Metres value)
				{
					return (value.value)/1E+21;
				}

				public static Metres operator +(Metres first, Zettametres second)
				{
					return new Metres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottametres(Metres value)
				{
					return (value.value)/1E+24;
				}

				public static Metres operator +(Metres first, Yottametres second)
				{
					return new Metres(first.value + (second.value)*1E+24);
				}
						}
		namespace Multiples
{

		public struct Yoctometres : IValueWithUnit, IEquatable< Yoctometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctometres Zero = new Yoctometres(0);
			public static readonly Yoctometres One = new Yoctometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.yoctometre; } }

			public Yoctometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ym", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-24);
				}
				
			public bool Equals(Yoctometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctometres(double value)
			{
				return new Yoctometres(value);
			}

			public static Yoctometres operator *(Yoctometres value, double times)
			{
				return new Yoctometres(value.value * times);
			}

			public static Yoctometres operator *(double times, Yoctometres value)
			{
				return new Yoctometres(value.value * times);
			}

			public static Yoctometres operator +(Yoctometres first, Yoctometres second)
			{
				return new Yoctometres(first.value * second.value);
			}

							public static implicit operator Metres(Yoctometres value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctometres operator +(Yoctometres first, Metres second)
				{
					return new Yoctometres(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptometres(Yoctometres value)
				{
					return (value.value)*0.001;
				}

				public static Yoctometres operator +(Yoctometres first, Zeptometres second)
				{
					return new Yoctometres(first.value + (second.value)*1000);
				}
								public static implicit operator Attometres(Yoctometres value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctometres operator +(Yoctometres first, Attometres second)
				{
					return new Yoctometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtometres(Yoctometres value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctometres operator +(Yoctometres first, Femtometres second)
				{
					return new Yoctometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picometres(Yoctometres value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctometres operator +(Yoctometres first, Picometres second)
				{
					return new Yoctometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanometres(Yoctometres value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctometres operator +(Yoctometres first, Nanometres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Micrometres(Yoctometres value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctometres operator +(Yoctometres first, Micrometres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Millimetres(Yoctometres value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctometres operator +(Yoctometres first, Millimetres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centimetres(Yoctometres value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctometres operator +(Yoctometres first, Centimetres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+22);
				}
								public static implicit operator Decimetres(Yoctometres value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctometres operator +(Yoctometres first, Decimetres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decametres(Yoctometres value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctometres operator +(Yoctometres first, Decametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectometres(Yoctometres value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctometres operator +(Yoctometres first, Hectometres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kilometres(Yoctometres value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctometres operator +(Yoctometres first, Kilometres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megametres(Yoctometres value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctometres operator +(Yoctometres first, Megametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigametres(Yoctometres value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctometres operator +(Yoctometres first, Gigametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+33);
				}
								public static implicit operator Terametres(Yoctometres value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctometres operator +(Yoctometres first, Terametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petametres(Yoctometres value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctometres operator +(Yoctometres first, Petametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+39);
				}
								public static implicit operator Exametres(Yoctometres value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctometres operator +(Yoctometres first, Exametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettametres(Yoctometres value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctometres operator +(Yoctometres first, Zettametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottametres(Yoctometres value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctometres operator +(Yoctometres first, Yottametres second)
				{
					return new Yoctometres(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptometres : IValueWithUnit, IEquatable< Zeptometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptometres Zero = new Zeptometres(0);
			public static readonly Zeptometres One = new Zeptometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.zeptometre; } }

			public Zeptometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-21);
				}
				
			public bool Equals(Zeptometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptometres(double value)
			{
				return new Zeptometres(value);
			}

			public static Zeptometres operator *(Zeptometres value, double times)
			{
				return new Zeptometres(value.value * times);
			}

			public static Zeptometres operator *(double times, Zeptometres value)
			{
				return new Zeptometres(value.value * times);
			}

			public static Zeptometres operator +(Zeptometres first, Zeptometres second)
			{
				return new Zeptometres(first.value * second.value);
			}

							public static implicit operator Metres(Zeptometres value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptometres operator +(Zeptometres first, Metres second)
				{
					return new Zeptometres(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctometres(Zeptometres value)
				{
					return (value.value)*1000;
				}

				public static Zeptometres operator +(Zeptometres first, Yoctometres second)
				{
					return new Zeptometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Attometres(Zeptometres value)
				{
					return (value.value)*0.001;
				}

				public static Zeptometres operator +(Zeptometres first, Attometres second)
				{
					return new Zeptometres(first.value + (second.value)*1000);
				}
								public static implicit operator Femtometres(Zeptometres value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptometres operator +(Zeptometres first, Femtometres second)
				{
					return new Zeptometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Picometres(Zeptometres value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptometres operator +(Zeptometres first, Picometres second)
				{
					return new Zeptometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanometres(Zeptometres value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptometres operator +(Zeptometres first, Nanometres second)
				{
					return new Zeptometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Micrometres(Zeptometres value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptometres operator +(Zeptometres first, Micrometres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Millimetres(Zeptometres value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptometres operator +(Zeptometres first, Millimetres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centimetres(Zeptometres value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptometres operator +(Zeptometres first, Centimetres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+19);
				}
								public static implicit operator Decimetres(Zeptometres value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptometres operator +(Zeptometres first, Decimetres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decametres(Zeptometres value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptometres operator +(Zeptometres first, Decametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectometres(Zeptometres value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptometres operator +(Zeptometres first, Hectometres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kilometres(Zeptometres value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptometres operator +(Zeptometres first, Kilometres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megametres(Zeptometres value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptometres operator +(Zeptometres first, Megametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigametres(Zeptometres value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptometres operator +(Zeptometres first, Gigametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+30);
				}
								public static implicit operator Terametres(Zeptometres value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptometres operator +(Zeptometres first, Terametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petametres(Zeptometres value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptometres operator +(Zeptometres first, Petametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+36);
				}
								public static implicit operator Exametres(Zeptometres value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptometres operator +(Zeptometres first, Exametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettametres(Zeptometres value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptometres operator +(Zeptometres first, Zettametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottametres(Zeptometres value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptometres operator +(Zeptometres first, Yottametres second)
				{
					return new Zeptometres(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attometres : IValueWithUnit, IEquatable< Attometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Attometres Zero = new Attometres(0);
			public static readonly Attometres One = new Attometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.attometre; } }

			public Attometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} am", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-18);
				}
				
			public bool Equals(Attometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attometres(double value)
			{
				return new Attometres(value);
			}

			public static Attometres operator *(Attometres value, double times)
			{
				return new Attometres(value.value * times);
			}

			public static Attometres operator *(double times, Attometres value)
			{
				return new Attometres(value.value * times);
			}

			public static Attometres operator +(Attometres first, Attometres second)
			{
				return new Attometres(first.value * second.value);
			}

							public static implicit operator Metres(Attometres value)
				{
					return (value.value)*1E-18;
				}

				public static Attometres operator +(Attometres first, Metres second)
				{
					return new Attometres(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctometres(Attometres value)
				{
					return (value.value)*1000000;
				}

				public static Attometres operator +(Attometres first, Yoctometres second)
				{
					return new Attometres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptometres(Attometres value)
				{
					return (value.value)*1000;
				}

				public static Attometres operator +(Attometres first, Zeptometres second)
				{
					return new Attometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtometres(Attometres value)
				{
					return (value.value)*0.001;
				}

				public static Attometres operator +(Attometres first, Femtometres second)
				{
					return new Attometres(first.value + (second.value)*1000);
				}
								public static implicit operator Picometres(Attometres value)
				{
					return (value.value)*1E-06;
				}

				public static Attometres operator +(Attometres first, Picometres second)
				{
					return new Attometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanometres(Attometres value)
				{
					return (value.value)*1E-09;
				}

				public static Attometres operator +(Attometres first, Nanometres second)
				{
					return new Attometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Micrometres(Attometres value)
				{
					return (value.value)*1E-12;
				}

				public static Attometres operator +(Attometres first, Micrometres second)
				{
					return new Attometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Millimetres(Attometres value)
				{
					return (value.value)*1E-15;
				}

				public static Attometres operator +(Attometres first, Millimetres second)
				{
					return new Attometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centimetres(Attometres value)
				{
					return (value.value)*1E-16;
				}

				public static Attometres operator +(Attometres first, Centimetres second)
				{
					return new Attometres(first.value + (second.value)*1E+16);
				}
								public static implicit operator Decimetres(Attometres value)
				{
					return (value.value)*1E-17;
				}

				public static Attometres operator +(Attometres first, Decimetres second)
				{
					return new Attometres(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decametres(Attometres value)
				{
					return (value.value)*1E-19;
				}

				public static Attometres operator +(Attometres first, Decametres second)
				{
					return new Attometres(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectometres(Attometres value)
				{
					return (value.value)*1E-20;
				}

				public static Attometres operator +(Attometres first, Hectometres second)
				{
					return new Attometres(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kilometres(Attometres value)
				{
					return (value.value)*1E-21;
				}

				public static Attometres operator +(Attometres first, Kilometres second)
				{
					return new Attometres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megametres(Attometres value)
				{
					return (value.value)*1E-24;
				}

				public static Attometres operator +(Attometres first, Megametres second)
				{
					return new Attometres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigametres(Attometres value)
				{
					return (value.value)*1E-27;
				}

				public static Attometres operator +(Attometres first, Gigametres second)
				{
					return new Attometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Terametres(Attometres value)
				{
					return (value.value)*1E-30;
				}

				public static Attometres operator +(Attometres first, Terametres second)
				{
					return new Attometres(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petametres(Attometres value)
				{
					return (value.value)*1E-33;
				}

				public static Attometres operator +(Attometres first, Petametres second)
				{
					return new Attometres(first.value + (second.value)*1E+33);
				}
								public static implicit operator Exametres(Attometres value)
				{
					return (value.value)*1E-36;
				}

				public static Attometres operator +(Attometres first, Exametres second)
				{
					return new Attometres(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettametres(Attometres value)
				{
					return (value.value)*1E-39;
				}

				public static Attometres operator +(Attometres first, Zettametres second)
				{
					return new Attometres(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottametres(Attometres value)
				{
					return (value.value)*1E-42;
				}

				public static Attometres operator +(Attometres first, Yottametres second)
				{
					return new Attometres(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtometres : IValueWithUnit, IEquatable< Femtometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtometres Zero = new Femtometres(0);
			public static readonly Femtometres One = new Femtometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.femtometre; } }

			public Femtometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-15);
				}
				
			public bool Equals(Femtometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtometres(double value)
			{
				return new Femtometres(value);
			}

			public static Femtometres operator *(Femtometres value, double times)
			{
				return new Femtometres(value.value * times);
			}

			public static Femtometres operator *(double times, Femtometres value)
			{
				return new Femtometres(value.value * times);
			}

			public static Femtometres operator +(Femtometres first, Femtometres second)
			{
				return new Femtometres(first.value * second.value);
			}

							public static implicit operator Metres(Femtometres value)
				{
					return (value.value)*1E-15;
				}

				public static Femtometres operator +(Femtometres first, Metres second)
				{
					return new Femtometres(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctometres(Femtometres value)
				{
					return (value.value)*1000000000;
				}

				public static Femtometres operator +(Femtometres first, Yoctometres second)
				{
					return new Femtometres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptometres(Femtometres value)
				{
					return (value.value)*1000000;
				}

				public static Femtometres operator +(Femtometres first, Zeptometres second)
				{
					return new Femtometres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attometres(Femtometres value)
				{
					return (value.value)*1000;
				}

				public static Femtometres operator +(Femtometres first, Attometres second)
				{
					return new Femtometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Picometres(Femtometres value)
				{
					return (value.value)*0.001;
				}

				public static Femtometres operator +(Femtometres first, Picometres second)
				{
					return new Femtometres(first.value + (second.value)*1000);
				}
								public static implicit operator Nanometres(Femtometres value)
				{
					return (value.value)*1E-06;
				}

				public static Femtometres operator +(Femtometres first, Nanometres second)
				{
					return new Femtometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Micrometres(Femtometres value)
				{
					return (value.value)*1E-09;
				}

				public static Femtometres operator +(Femtometres first, Micrometres second)
				{
					return new Femtometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Millimetres(Femtometres value)
				{
					return (value.value)*1E-12;
				}

				public static Femtometres operator +(Femtometres first, Millimetres second)
				{
					return new Femtometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centimetres(Femtometres value)
				{
					return (value.value)*1E-13;
				}

				public static Femtometres operator +(Femtometres first, Centimetres second)
				{
					return new Femtometres(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Decimetres(Femtometres value)
				{
					return (value.value)*1E-14;
				}

				public static Femtometres operator +(Femtometres first, Decimetres second)
				{
					return new Femtometres(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decametres(Femtometres value)
				{
					return (value.value)*1E-16;
				}

				public static Femtometres operator +(Femtometres first, Decametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectometres(Femtometres value)
				{
					return (value.value)*1E-17;
				}

				public static Femtometres operator +(Femtometres first, Hectometres second)
				{
					return new Femtometres(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kilometres(Femtometres value)
				{
					return (value.value)*1E-18;
				}

				public static Femtometres operator +(Femtometres first, Kilometres second)
				{
					return new Femtometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megametres(Femtometres value)
				{
					return (value.value)*1E-21;
				}

				public static Femtometres operator +(Femtometres first, Megametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigametres(Femtometres value)
				{
					return (value.value)*1E-24;
				}

				public static Femtometres operator +(Femtometres first, Gigametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Terametres(Femtometres value)
				{
					return (value.value)*1E-27;
				}

				public static Femtometres operator +(Femtometres first, Terametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petametres(Femtometres value)
				{
					return (value.value)*1E-30;
				}

				public static Femtometres operator +(Femtometres first, Petametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+30);
				}
								public static implicit operator Exametres(Femtometres value)
				{
					return (value.value)*1E-33;
				}

				public static Femtometres operator +(Femtometres first, Exametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettametres(Femtometres value)
				{
					return (value.value)*1E-36;
				}

				public static Femtometres operator +(Femtometres first, Zettametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottametres(Femtometres value)
				{
					return (value.value)*1E-39;
				}

				public static Femtometres operator +(Femtometres first, Yottametres second)
				{
					return new Femtometres(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picometres : IValueWithUnit, IEquatable< Picometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Picometres Zero = new Picometres(0);
			public static readonly Picometres One = new Picometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.picometre; } }

			public Picometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} pm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-12);
				}
				
			public bool Equals(Picometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picometres(double value)
			{
				return new Picometres(value);
			}

			public static Picometres operator *(Picometres value, double times)
			{
				return new Picometres(value.value * times);
			}

			public static Picometres operator *(double times, Picometres value)
			{
				return new Picometres(value.value * times);
			}

			public static Picometres operator +(Picometres first, Picometres second)
			{
				return new Picometres(first.value * second.value);
			}

							public static implicit operator Metres(Picometres value)
				{
					return (value.value)*1E-12;
				}

				public static Picometres operator +(Picometres first, Metres second)
				{
					return new Picometres(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctometres(Picometres value)
				{
					return (value.value)*1000000000000;
				}

				public static Picometres operator +(Picometres first, Yoctometres second)
				{
					return new Picometres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptometres(Picometres value)
				{
					return (value.value)*1000000000;
				}

				public static Picometres operator +(Picometres first, Zeptometres second)
				{
					return new Picometres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attometres(Picometres value)
				{
					return (value.value)*1000000;
				}

				public static Picometres operator +(Picometres first, Attometres second)
				{
					return new Picometres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtometres(Picometres value)
				{
					return (value.value)*1000;
				}

				public static Picometres operator +(Picometres first, Femtometres second)
				{
					return new Picometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanometres(Picometres value)
				{
					return (value.value)*0.001;
				}

				public static Picometres operator +(Picometres first, Nanometres second)
				{
					return new Picometres(first.value + (second.value)*1000);
				}
								public static implicit operator Micrometres(Picometres value)
				{
					return (value.value)*1E-06;
				}

				public static Picometres operator +(Picometres first, Micrometres second)
				{
					return new Picometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Millimetres(Picometres value)
				{
					return (value.value)*1E-09;
				}

				public static Picometres operator +(Picometres first, Millimetres second)
				{
					return new Picometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centimetres(Picometres value)
				{
					return (value.value)*1E-10;
				}

				public static Picometres operator +(Picometres first, Centimetres second)
				{
					return new Picometres(first.value + (second.value)*10000000000);
				}
								public static implicit operator Decimetres(Picometres value)
				{
					return (value.value)*1E-11;
				}

				public static Picometres operator +(Picometres first, Decimetres second)
				{
					return new Picometres(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decametres(Picometres value)
				{
					return (value.value)*1E-13;
				}

				public static Picometres operator +(Picometres first, Decametres second)
				{
					return new Picometres(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectometres(Picometres value)
				{
					return (value.value)*1E-14;
				}

				public static Picometres operator +(Picometres first, Hectometres second)
				{
					return new Picometres(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kilometres(Picometres value)
				{
					return (value.value)*1E-15;
				}

				public static Picometres operator +(Picometres first, Kilometres second)
				{
					return new Picometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megametres(Picometres value)
				{
					return (value.value)*1E-18;
				}

				public static Picometres operator +(Picometres first, Megametres second)
				{
					return new Picometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigametres(Picometres value)
				{
					return (value.value)*1E-21;
				}

				public static Picometres operator +(Picometres first, Gigametres second)
				{
					return new Picometres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Terametres(Picometres value)
				{
					return (value.value)*1E-24;
				}

				public static Picometres operator +(Picometres first, Terametres second)
				{
					return new Picometres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petametres(Picometres value)
				{
					return (value.value)*1E-27;
				}

				public static Picometres operator +(Picometres first, Petametres second)
				{
					return new Picometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Exametres(Picometres value)
				{
					return (value.value)*1E-30;
				}

				public static Picometres operator +(Picometres first, Exametres second)
				{
					return new Picometres(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettametres(Picometres value)
				{
					return (value.value)*1E-33;
				}

				public static Picometres operator +(Picometres first, Zettametres second)
				{
					return new Picometres(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottametres(Picometres value)
				{
					return (value.value)*1E-36;
				}

				public static Picometres operator +(Picometres first, Yottametres second)
				{
					return new Picometres(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanometres : IValueWithUnit, IEquatable< Nanometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanometres Zero = new Nanometres(0);
			public static readonly Nanometres One = new Nanometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.nanometre; } }

			public Nanometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} nm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-09);
				}
				
			public bool Equals(Nanometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanometres(double value)
			{
				return new Nanometres(value);
			}

			public static Nanometres operator *(Nanometres value, double times)
			{
				return new Nanometres(value.value * times);
			}

			public static Nanometres operator *(double times, Nanometres value)
			{
				return new Nanometres(value.value * times);
			}

			public static Nanometres operator +(Nanometres first, Nanometres second)
			{
				return new Nanometres(first.value * second.value);
			}

							public static implicit operator Metres(Nanometres value)
				{
					return (value.value)*1E-09;
				}

				public static Nanometres operator +(Nanometres first, Metres second)
				{
					return new Nanometres(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctometres(Nanometres value)
				{
					return (value.value)*1E+15;
				}

				public static Nanometres operator +(Nanometres first, Yoctometres second)
				{
					return new Nanometres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptometres(Nanometres value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanometres operator +(Nanometres first, Zeptometres second)
				{
					return new Nanometres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attometres(Nanometres value)
				{
					return (value.value)*1000000000;
				}

				public static Nanometres operator +(Nanometres first, Attometres second)
				{
					return new Nanometres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtometres(Nanometres value)
				{
					return (value.value)*1000000;
				}

				public static Nanometres operator +(Nanometres first, Femtometres second)
				{
					return new Nanometres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picometres(Nanometres value)
				{
					return (value.value)*1000;
				}

				public static Nanometres operator +(Nanometres first, Picometres second)
				{
					return new Nanometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Micrometres(Nanometres value)
				{
					return (value.value)*0.001;
				}

				public static Nanometres operator +(Nanometres first, Micrometres second)
				{
					return new Nanometres(first.value + (second.value)*1000);
				}
								public static implicit operator Millimetres(Nanometres value)
				{
					return (value.value)*1E-06;
				}

				public static Nanometres operator +(Nanometres first, Millimetres second)
				{
					return new Nanometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Centimetres(Nanometres value)
				{
					return (value.value)*1E-07;
				}

				public static Nanometres operator +(Nanometres first, Centimetres second)
				{
					return new Nanometres(first.value + (second.value)*10000000);
				}
								public static implicit operator Decimetres(Nanometres value)
				{
					return (value.value)*1E-08;
				}

				public static Nanometres operator +(Nanometres first, Decimetres second)
				{
					return new Nanometres(first.value + (second.value)*100000000);
				}
								public static implicit operator Decametres(Nanometres value)
				{
					return (value.value)*1E-10;
				}

				public static Nanometres operator +(Nanometres first, Decametres second)
				{
					return new Nanometres(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectometres(Nanometres value)
				{
					return (value.value)*1E-11;
				}

				public static Nanometres operator +(Nanometres first, Hectometres second)
				{
					return new Nanometres(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kilometres(Nanometres value)
				{
					return (value.value)*1E-12;
				}

				public static Nanometres operator +(Nanometres first, Kilometres second)
				{
					return new Nanometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megametres(Nanometres value)
				{
					return (value.value)*1E-15;
				}

				public static Nanometres operator +(Nanometres first, Megametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigametres(Nanometres value)
				{
					return (value.value)*1E-18;
				}

				public static Nanometres operator +(Nanometres first, Gigametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Terametres(Nanometres value)
				{
					return (value.value)*1E-21;
				}

				public static Nanometres operator +(Nanometres first, Terametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petametres(Nanometres value)
				{
					return (value.value)*1E-24;
				}

				public static Nanometres operator +(Nanometres first, Petametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Exametres(Nanometres value)
				{
					return (value.value)*1E-27;
				}

				public static Nanometres operator +(Nanometres first, Exametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettametres(Nanometres value)
				{
					return (value.value)*1E-30;
				}

				public static Nanometres operator +(Nanometres first, Zettametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottametres(Nanometres value)
				{
					return (value.value)*1E-33;
				}

				public static Nanometres operator +(Nanometres first, Yottametres second)
				{
					return new Nanometres(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Micrometres : IValueWithUnit, IEquatable< Micrometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Micrometres Zero = new Micrometres(0);
			public static readonly Micrometres One = new Micrometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.micrometre; } }

			public Micrometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E-06);
				}
				
			public bool Equals(Micrometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Micrometres(double value)
			{
				return new Micrometres(value);
			}

			public static Micrometres operator *(Micrometres value, double times)
			{
				return new Micrometres(value.value * times);
			}

			public static Micrometres operator *(double times, Micrometres value)
			{
				return new Micrometres(value.value * times);
			}

			public static Micrometres operator +(Micrometres first, Micrometres second)
			{
				return new Micrometres(first.value * second.value);
			}

							public static implicit operator Metres(Micrometres value)
				{
					return (value.value)*1E-06;
				}

				public static Micrometres operator +(Micrometres first, Metres second)
				{
					return new Micrometres(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctometres(Micrometres value)
				{
					return (value.value)*1E+18;
				}

				public static Micrometres operator +(Micrometres first, Yoctometres second)
				{
					return new Micrometres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptometres(Micrometres value)
				{
					return (value.value)*1E+15;
				}

				public static Micrometres operator +(Micrometres first, Zeptometres second)
				{
					return new Micrometres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attometres(Micrometres value)
				{
					return (value.value)*1000000000000;
				}

				public static Micrometres operator +(Micrometres first, Attometres second)
				{
					return new Micrometres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtometres(Micrometres value)
				{
					return (value.value)*1000000000;
				}

				public static Micrometres operator +(Micrometres first, Femtometres second)
				{
					return new Micrometres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picometres(Micrometres value)
				{
					return (value.value)*1000000;
				}

				public static Micrometres operator +(Micrometres first, Picometres second)
				{
					return new Micrometres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanometres(Micrometres value)
				{
					return (value.value)*1000;
				}

				public static Micrometres operator +(Micrometres first, Nanometres second)
				{
					return new Micrometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Millimetres(Micrometres value)
				{
					return (value.value)*0.001;
				}

				public static Micrometres operator +(Micrometres first, Millimetres second)
				{
					return new Micrometres(first.value + (second.value)*1000);
				}
								public static implicit operator Centimetres(Micrometres value)
				{
					return (value.value)*0.0001;
				}

				public static Micrometres operator +(Micrometres first, Centimetres second)
				{
					return new Micrometres(first.value + (second.value)*10000);
				}
								public static implicit operator Decimetres(Micrometres value)
				{
					return (value.value)*1E-05;
				}

				public static Micrometres operator +(Micrometres first, Decimetres second)
				{
					return new Micrometres(first.value + (second.value)*100000);
				}
								public static implicit operator Decametres(Micrometres value)
				{
					return (value.value)*1E-07;
				}

				public static Micrometres operator +(Micrometres first, Decametres second)
				{
					return new Micrometres(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectometres(Micrometres value)
				{
					return (value.value)*1E-08;
				}

				public static Micrometres operator +(Micrometres first, Hectometres second)
				{
					return new Micrometres(first.value + (second.value)*100000000);
				}
								public static implicit operator Kilometres(Micrometres value)
				{
					return (value.value)*1E-09;
				}

				public static Micrometres operator +(Micrometres first, Kilometres second)
				{
					return new Micrometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megametres(Micrometres value)
				{
					return (value.value)*1E-12;
				}

				public static Micrometres operator +(Micrometres first, Megametres second)
				{
					return new Micrometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigametres(Micrometres value)
				{
					return (value.value)*1E-15;
				}

				public static Micrometres operator +(Micrometres first, Gigametres second)
				{
					return new Micrometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Terametres(Micrometres value)
				{
					return (value.value)*1E-18;
				}

				public static Micrometres operator +(Micrometres first, Terametres second)
				{
					return new Micrometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petametres(Micrometres value)
				{
					return (value.value)*1E-21;
				}

				public static Micrometres operator +(Micrometres first, Petametres second)
				{
					return new Micrometres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Exametres(Micrometres value)
				{
					return (value.value)*1E-24;
				}

				public static Micrometres operator +(Micrometres first, Exametres second)
				{
					return new Micrometres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettametres(Micrometres value)
				{
					return (value.value)*1E-27;
				}

				public static Micrometres operator +(Micrometres first, Zettametres second)
				{
					return new Micrometres(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottametres(Micrometres value)
				{
					return (value.value)*1E-30;
				}

				public static Micrometres operator +(Micrometres first, Yottametres second)
				{
					return new Micrometres(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Millimetres : IValueWithUnit, IEquatable< Millimetres >, IEquatable<IValueWithUnit>
		{
			public static readonly Millimetres Zero = new Millimetres(0);
			public static readonly Millimetres One = new Millimetres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.millimetre; } }

			public Millimetres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*0.001);
				}
				
			public bool Equals(Millimetres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Millimetres(double value)
			{
				return new Millimetres(value);
			}

			public static Millimetres operator *(Millimetres value, double times)
			{
				return new Millimetres(value.value * times);
			}

			public static Millimetres operator *(double times, Millimetres value)
			{
				return new Millimetres(value.value * times);
			}

			public static Millimetres operator +(Millimetres first, Millimetres second)
			{
				return new Millimetres(first.value * second.value);
			}

							public static implicit operator Metres(Millimetres value)
				{
					return (value.value)*0.001;
				}

				public static Millimetres operator +(Millimetres first, Metres second)
				{
					return new Millimetres(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctometres(Millimetres value)
				{
					return (value.value)*1E+21;
				}

				public static Millimetres operator +(Millimetres first, Yoctometres second)
				{
					return new Millimetres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptometres(Millimetres value)
				{
					return (value.value)*1E+18;
				}

				public static Millimetres operator +(Millimetres first, Zeptometres second)
				{
					return new Millimetres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attometres(Millimetres value)
				{
					return (value.value)*1E+15;
				}

				public static Millimetres operator +(Millimetres first, Attometres second)
				{
					return new Millimetres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtometres(Millimetres value)
				{
					return (value.value)*1000000000000;
				}

				public static Millimetres operator +(Millimetres first, Femtometres second)
				{
					return new Millimetres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picometres(Millimetres value)
				{
					return (value.value)*1000000000;
				}

				public static Millimetres operator +(Millimetres first, Picometres second)
				{
					return new Millimetres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanometres(Millimetres value)
				{
					return (value.value)*1000000;
				}

				public static Millimetres operator +(Millimetres first, Nanometres second)
				{
					return new Millimetres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Micrometres(Millimetres value)
				{
					return (value.value)*1000;
				}

				public static Millimetres operator +(Millimetres first, Micrometres second)
				{
					return new Millimetres(first.value + (second.value)*0.001);
				}
								public static implicit operator Centimetres(Millimetres value)
				{
					return (value.value)*0.1;
				}

				public static Millimetres operator +(Millimetres first, Centimetres second)
				{
					return new Millimetres(first.value + (second.value)*10);
				}
								public static implicit operator Decimetres(Millimetres value)
				{
					return (value.value)*0.01;
				}

				public static Millimetres operator +(Millimetres first, Decimetres second)
				{
					return new Millimetres(first.value + (second.value)*100);
				}
								public static implicit operator Decametres(Millimetres value)
				{
					return (value.value)*0.0001;
				}

				public static Millimetres operator +(Millimetres first, Decametres second)
				{
					return new Millimetres(first.value + (second.value)*10000);
				}
								public static implicit operator Hectometres(Millimetres value)
				{
					return (value.value)*1E-05;
				}

				public static Millimetres operator +(Millimetres first, Hectometres second)
				{
					return new Millimetres(first.value + (second.value)*100000);
				}
								public static implicit operator Kilometres(Millimetres value)
				{
					return (value.value)*1E-06;
				}

				public static Millimetres operator +(Millimetres first, Kilometres second)
				{
					return new Millimetres(first.value + (second.value)*1000000);
				}
								public static implicit operator Megametres(Millimetres value)
				{
					return (value.value)*1E-09;
				}

				public static Millimetres operator +(Millimetres first, Megametres second)
				{
					return new Millimetres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigametres(Millimetres value)
				{
					return (value.value)*1E-12;
				}

				public static Millimetres operator +(Millimetres first, Gigametres second)
				{
					return new Millimetres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Terametres(Millimetres value)
				{
					return (value.value)*1E-15;
				}

				public static Millimetres operator +(Millimetres first, Terametres second)
				{
					return new Millimetres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petametres(Millimetres value)
				{
					return (value.value)*1E-18;
				}

				public static Millimetres operator +(Millimetres first, Petametres second)
				{
					return new Millimetres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Exametres(Millimetres value)
				{
					return (value.value)*1E-21;
				}

				public static Millimetres operator +(Millimetres first, Exametres second)
				{
					return new Millimetres(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettametres(Millimetres value)
				{
					return (value.value)*1E-24;
				}

				public static Millimetres operator +(Millimetres first, Zettametres second)
				{
					return new Millimetres(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottametres(Millimetres value)
				{
					return (value.value)*1E-27;
				}

				public static Millimetres operator +(Millimetres first, Yottametres second)
				{
					return new Millimetres(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centimetres : IValueWithUnit, IEquatable< Centimetres >, IEquatable<IValueWithUnit>
		{
			public static readonly Centimetres Zero = new Centimetres(0);
			public static readonly Centimetres One = new Centimetres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.centimetre; } }

			public Centimetres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*0.01);
				}
				
			public bool Equals(Centimetres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centimetres(double value)
			{
				return new Centimetres(value);
			}

			public static Centimetres operator *(Centimetres value, double times)
			{
				return new Centimetres(value.value * times);
			}

			public static Centimetres operator *(double times, Centimetres value)
			{
				return new Centimetres(value.value * times);
			}

			public static Centimetres operator +(Centimetres first, Centimetres second)
			{
				return new Centimetres(first.value * second.value);
			}

							public static implicit operator Metres(Centimetres value)
				{
					return (value.value)*0.01;
				}

				public static Centimetres operator +(Centimetres first, Metres second)
				{
					return new Centimetres(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctometres(Centimetres value)
				{
					return (value.value)*1E+22;
				}

				public static Centimetres operator +(Centimetres first, Yoctometres second)
				{
					return new Centimetres(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptometres(Centimetres value)
				{
					return (value.value)*1E+19;
				}

				public static Centimetres operator +(Centimetres first, Zeptometres second)
				{
					return new Centimetres(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attometres(Centimetres value)
				{
					return (value.value)*1E+16;
				}

				public static Centimetres operator +(Centimetres first, Attometres second)
				{
					return new Centimetres(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtometres(Centimetres value)
				{
					return (value.value)*10000000000000;
				}

				public static Centimetres operator +(Centimetres first, Femtometres second)
				{
					return new Centimetres(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picometres(Centimetres value)
				{
					return (value.value)*10000000000;
				}

				public static Centimetres operator +(Centimetres first, Picometres second)
				{
					return new Centimetres(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanometres(Centimetres value)
				{
					return (value.value)*10000000;
				}

				public static Centimetres operator +(Centimetres first, Nanometres second)
				{
					return new Centimetres(first.value + (second.value)*1E-07);
				}
								public static implicit operator Micrometres(Centimetres value)
				{
					return (value.value)*10000;
				}

				public static Centimetres operator +(Centimetres first, Micrometres second)
				{
					return new Centimetres(first.value + (second.value)*0.0001);
				}
								public static implicit operator Millimetres(Centimetres value)
				{
					return (value.value)*10;
				}

				public static Centimetres operator +(Centimetres first, Millimetres second)
				{
					return new Centimetres(first.value + (second.value)*0.1);
				}
								public static implicit operator Decimetres(Centimetres value)
				{
					return (value.value)*0.1;
				}

				public static Centimetres operator +(Centimetres first, Decimetres second)
				{
					return new Centimetres(first.value + (second.value)*10);
				}
								public static implicit operator Decametres(Centimetres value)
				{
					return (value.value)*0.001;
				}

				public static Centimetres operator +(Centimetres first, Decametres second)
				{
					return new Centimetres(first.value + (second.value)*1000);
				}
								public static implicit operator Hectometres(Centimetres value)
				{
					return (value.value)*0.0001;
				}

				public static Centimetres operator +(Centimetres first, Hectometres second)
				{
					return new Centimetres(first.value + (second.value)*10000);
				}
								public static implicit operator Kilometres(Centimetres value)
				{
					return (value.value)*1E-05;
				}

				public static Centimetres operator +(Centimetres first, Kilometres second)
				{
					return new Centimetres(first.value + (second.value)*100000);
				}
								public static implicit operator Megametres(Centimetres value)
				{
					return (value.value)*1E-08;
				}

				public static Centimetres operator +(Centimetres first, Megametres second)
				{
					return new Centimetres(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigametres(Centimetres value)
				{
					return (value.value)*1E-11;
				}

				public static Centimetres operator +(Centimetres first, Gigametres second)
				{
					return new Centimetres(first.value + (second.value)*100000000000);
				}
								public static implicit operator Terametres(Centimetres value)
				{
					return (value.value)*1E-14;
				}

				public static Centimetres operator +(Centimetres first, Terametres second)
				{
					return new Centimetres(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petametres(Centimetres value)
				{
					return (value.value)*1E-17;
				}

				public static Centimetres operator +(Centimetres first, Petametres second)
				{
					return new Centimetres(first.value + (second.value)*1E+17);
				}
								public static implicit operator Exametres(Centimetres value)
				{
					return (value.value)*1E-20;
				}

				public static Centimetres operator +(Centimetres first, Exametres second)
				{
					return new Centimetres(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettametres(Centimetres value)
				{
					return (value.value)*1E-23;
				}

				public static Centimetres operator +(Centimetres first, Zettametres second)
				{
					return new Centimetres(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottametres(Centimetres value)
				{
					return (value.value)*1E-26;
				}

				public static Centimetres operator +(Centimetres first, Yottametres second)
				{
					return new Centimetres(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Decimetres : IValueWithUnit, IEquatable< Decimetres >, IEquatable<IValueWithUnit>
		{
			public static readonly Decimetres Zero = new Decimetres(0);
			public static readonly Decimetres One = new Decimetres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.decimetre; } }

			public Decimetres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*0.1);
				}
				
			public bool Equals(Decimetres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decimetres(double value)
			{
				return new Decimetres(value);
			}

			public static Decimetres operator *(Decimetres value, double times)
			{
				return new Decimetres(value.value * times);
			}

			public static Decimetres operator *(double times, Decimetres value)
			{
				return new Decimetres(value.value * times);
			}

			public static Decimetres operator +(Decimetres first, Decimetres second)
			{
				return new Decimetres(first.value * second.value);
			}

							public static implicit operator Metres(Decimetres value)
				{
					return (value.value)*0.1;
				}

				public static Decimetres operator +(Decimetres first, Metres second)
				{
					return new Decimetres(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctometres(Decimetres value)
				{
					return (value.value)*1E+23;
				}

				public static Decimetres operator +(Decimetres first, Yoctometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptometres(Decimetres value)
				{
					return (value.value)*1E+20;
				}

				public static Decimetres operator +(Decimetres first, Zeptometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attometres(Decimetres value)
				{
					return (value.value)*1E+17;
				}

				public static Decimetres operator +(Decimetres first, Attometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtometres(Decimetres value)
				{
					return (value.value)*100000000000000;
				}

				public static Decimetres operator +(Decimetres first, Femtometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picometres(Decimetres value)
				{
					return (value.value)*100000000000;
				}

				public static Decimetres operator +(Decimetres first, Picometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanometres(Decimetres value)
				{
					return (value.value)*100000000;
				}

				public static Decimetres operator +(Decimetres first, Nanometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-08);
				}
								public static implicit operator Micrometres(Decimetres value)
				{
					return (value.value)*100000;
				}

				public static Decimetres operator +(Decimetres first, Micrometres second)
				{
					return new Decimetres(first.value + (second.value)*1E-05);
				}
								public static implicit operator Millimetres(Decimetres value)
				{
					return (value.value)*100;
				}

				public static Decimetres operator +(Decimetres first, Millimetres second)
				{
					return new Decimetres(first.value + (second.value)*0.01);
				}
								public static implicit operator Centimetres(Decimetres value)
				{
					return (value.value)*10;
				}

				public static Decimetres operator +(Decimetres first, Centimetres second)
				{
					return new Decimetres(first.value + (second.value)*0.1);
				}
								public static implicit operator Decametres(Decimetres value)
				{
					return (value.value)*0.01;
				}

				public static Decimetres operator +(Decimetres first, Decametres second)
				{
					return new Decimetres(first.value + (second.value)*100);
				}
								public static implicit operator Hectometres(Decimetres value)
				{
					return (value.value)*0.001;
				}

				public static Decimetres operator +(Decimetres first, Hectometres second)
				{
					return new Decimetres(first.value + (second.value)*1000);
				}
								public static implicit operator Kilometres(Decimetres value)
				{
					return (value.value)*0.0001;
				}

				public static Decimetres operator +(Decimetres first, Kilometres second)
				{
					return new Decimetres(first.value + (second.value)*10000);
				}
								public static implicit operator Megametres(Decimetres value)
				{
					return (value.value)*1E-07;
				}

				public static Decimetres operator +(Decimetres first, Megametres second)
				{
					return new Decimetres(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigametres(Decimetres value)
				{
					return (value.value)*1E-10;
				}

				public static Decimetres operator +(Decimetres first, Gigametres second)
				{
					return new Decimetres(first.value + (second.value)*10000000000);
				}
								public static implicit operator Terametres(Decimetres value)
				{
					return (value.value)*1E-13;
				}

				public static Decimetres operator +(Decimetres first, Terametres second)
				{
					return new Decimetres(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petametres(Decimetres value)
				{
					return (value.value)*1E-16;
				}

				public static Decimetres operator +(Decimetres first, Petametres second)
				{
					return new Decimetres(first.value + (second.value)*1E+16);
				}
								public static implicit operator Exametres(Decimetres value)
				{
					return (value.value)*1E-19;
				}

				public static Decimetres operator +(Decimetres first, Exametres second)
				{
					return new Decimetres(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettametres(Decimetres value)
				{
					return (value.value)*1E-22;
				}

				public static Decimetres operator +(Decimetres first, Zettametres second)
				{
					return new Decimetres(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottametres(Decimetres value)
				{
					return (value.value)*1E-25;
				}

				public static Decimetres operator +(Decimetres first, Yottametres second)
				{
					return new Decimetres(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decametres : IValueWithUnit, IEquatable< Decametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Decametres Zero = new Decametres(0);
			public static readonly Decametres One = new Decametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.decametre; } }

			public Decametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dam", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*10);
				}
				
			public bool Equals(Decametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decametres(double value)
			{
				return new Decametres(value);
			}

			public static Decametres operator *(Decametres value, double times)
			{
				return new Decametres(value.value * times);
			}

			public static Decametres operator *(double times, Decametres value)
			{
				return new Decametres(value.value * times);
			}

			public static Decametres operator +(Decametres first, Decametres second)
			{
				return new Decametres(first.value * second.value);
			}

							public static implicit operator Metres(Decametres value)
				{
					return (value.value)*10;
				}

				public static Decametres operator +(Decametres first, Metres second)
				{
					return new Decametres(first.value + (second.value)/10);
				}
								public static implicit operator Yoctometres(Decametres value)
				{
					return (value.value)*1E+25;
				}

				public static Decametres operator +(Decametres first, Yoctometres second)
				{
					return new Decametres(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptometres(Decametres value)
				{
					return (value.value)*1E+22;
				}

				public static Decametres operator +(Decametres first, Zeptometres second)
				{
					return new Decametres(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attometres(Decametres value)
				{
					return (value.value)*1E+19;
				}

				public static Decametres operator +(Decametres first, Attometres second)
				{
					return new Decametres(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtometres(Decametres value)
				{
					return (value.value)*1E+16;
				}

				public static Decametres operator +(Decametres first, Femtometres second)
				{
					return new Decametres(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picometres(Decametres value)
				{
					return (value.value)*10000000000000;
				}

				public static Decametres operator +(Decametres first, Picometres second)
				{
					return new Decametres(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanometres(Decametres value)
				{
					return (value.value)*10000000000;
				}

				public static Decametres operator +(Decametres first, Nanometres second)
				{
					return new Decametres(first.value + (second.value)*1E-10);
				}
								public static implicit operator Micrometres(Decametres value)
				{
					return (value.value)*10000000;
				}

				public static Decametres operator +(Decametres first, Micrometres second)
				{
					return new Decametres(first.value + (second.value)*1E-07);
				}
								public static implicit operator Millimetres(Decametres value)
				{
					return (value.value)*10000;
				}

				public static Decametres operator +(Decametres first, Millimetres second)
				{
					return new Decametres(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centimetres(Decametres value)
				{
					return (value.value)*1000;
				}

				public static Decametres operator +(Decametres first, Centimetres second)
				{
					return new Decametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Decimetres(Decametres value)
				{
					return (value.value)*100;
				}

				public static Decametres operator +(Decametres first, Decimetres second)
				{
					return new Decametres(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectometres(Decametres value)
				{
					return (value.value)*0.1;
				}

				public static Decametres operator +(Decametres first, Hectometres second)
				{
					return new Decametres(first.value + (second.value)*10);
				}
								public static implicit operator Kilometres(Decametres value)
				{
					return (value.value)*0.01;
				}

				public static Decametres operator +(Decametres first, Kilometres second)
				{
					return new Decametres(first.value + (second.value)*100);
				}
								public static implicit operator Megametres(Decametres value)
				{
					return (value.value)*1E-05;
				}

				public static Decametres operator +(Decametres first, Megametres second)
				{
					return new Decametres(first.value + (second.value)*100000);
				}
								public static implicit operator Gigametres(Decametres value)
				{
					return (value.value)*1E-08;
				}

				public static Decametres operator +(Decametres first, Gigametres second)
				{
					return new Decametres(first.value + (second.value)*100000000);
				}
								public static implicit operator Terametres(Decametres value)
				{
					return (value.value)*1E-11;
				}

				public static Decametres operator +(Decametres first, Terametres second)
				{
					return new Decametres(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petametres(Decametres value)
				{
					return (value.value)*1E-14;
				}

				public static Decametres operator +(Decametres first, Petametres second)
				{
					return new Decametres(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Exametres(Decametres value)
				{
					return (value.value)*1E-17;
				}

				public static Decametres operator +(Decametres first, Exametres second)
				{
					return new Decametres(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettametres(Decametres value)
				{
					return (value.value)*1E-20;
				}

				public static Decametres operator +(Decametres first, Zettametres second)
				{
					return new Decametres(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottametres(Decametres value)
				{
					return (value.value)*1E-23;
				}

				public static Decametres operator +(Decametres first, Yottametres second)
				{
					return new Decametres(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectometres : IValueWithUnit, IEquatable< Hectometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectometres Zero = new Hectometres(0);
			public static readonly Hectometres One = new Hectometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.hectometre; } }

			public Hectometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*100);
				}
				
			public bool Equals(Hectometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectometres(double value)
			{
				return new Hectometres(value);
			}

			public static Hectometres operator *(Hectometres value, double times)
			{
				return new Hectometres(value.value * times);
			}

			public static Hectometres operator *(double times, Hectometres value)
			{
				return new Hectometres(value.value * times);
			}

			public static Hectometres operator +(Hectometres first, Hectometres second)
			{
				return new Hectometres(first.value * second.value);
			}

							public static implicit operator Metres(Hectometres value)
				{
					return (value.value)*100;
				}

				public static Hectometres operator +(Hectometres first, Metres second)
				{
					return new Hectometres(first.value + (second.value)/100);
				}
								public static implicit operator Yoctometres(Hectometres value)
				{
					return (value.value)*1E+26;
				}

				public static Hectometres operator +(Hectometres first, Yoctometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptometres(Hectometres value)
				{
					return (value.value)*1E+23;
				}

				public static Hectometres operator +(Hectometres first, Zeptometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attometres(Hectometres value)
				{
					return (value.value)*1E+20;
				}

				public static Hectometres operator +(Hectometres first, Attometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtometres(Hectometres value)
				{
					return (value.value)*1E+17;
				}

				public static Hectometres operator +(Hectometres first, Femtometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picometres(Hectometres value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectometres operator +(Hectometres first, Picometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanometres(Hectometres value)
				{
					return (value.value)*100000000000;
				}

				public static Hectometres operator +(Hectometres first, Nanometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-11);
				}
								public static implicit operator Micrometres(Hectometres value)
				{
					return (value.value)*100000000;
				}

				public static Hectometres operator +(Hectometres first, Micrometres second)
				{
					return new Hectometres(first.value + (second.value)*1E-08);
				}
								public static implicit operator Millimetres(Hectometres value)
				{
					return (value.value)*100000;
				}

				public static Hectometres operator +(Hectometres first, Millimetres second)
				{
					return new Hectometres(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centimetres(Hectometres value)
				{
					return (value.value)*10000;
				}

				public static Hectometres operator +(Hectometres first, Centimetres second)
				{
					return new Hectometres(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decimetres(Hectometres value)
				{
					return (value.value)*1000;
				}

				public static Hectometres operator +(Hectometres first, Decimetres second)
				{
					return new Hectometres(first.value + (second.value)*0.001);
				}
								public static implicit operator Decametres(Hectometres value)
				{
					return (value.value)*10;
				}

				public static Hectometres operator +(Hectometres first, Decametres second)
				{
					return new Hectometres(first.value + (second.value)*0.1);
				}
								public static implicit operator Kilometres(Hectometres value)
				{
					return (value.value)*0.1;
				}

				public static Hectometres operator +(Hectometres first, Kilometres second)
				{
					return new Hectometres(first.value + (second.value)*10);
				}
								public static implicit operator Megametres(Hectometres value)
				{
					return (value.value)*0.0001;
				}

				public static Hectometres operator +(Hectometres first, Megametres second)
				{
					return new Hectometres(first.value + (second.value)*10000);
				}
								public static implicit operator Gigametres(Hectometres value)
				{
					return (value.value)*1E-07;
				}

				public static Hectometres operator +(Hectometres first, Gigametres second)
				{
					return new Hectometres(first.value + (second.value)*10000000);
				}
								public static implicit operator Terametres(Hectometres value)
				{
					return (value.value)*1E-10;
				}

				public static Hectometres operator +(Hectometres first, Terametres second)
				{
					return new Hectometres(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petametres(Hectometres value)
				{
					return (value.value)*1E-13;
				}

				public static Hectometres operator +(Hectometres first, Petametres second)
				{
					return new Hectometres(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Exametres(Hectometres value)
				{
					return (value.value)*1E-16;
				}

				public static Hectometres operator +(Hectometres first, Exametres second)
				{
					return new Hectometres(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettametres(Hectometres value)
				{
					return (value.value)*1E-19;
				}

				public static Hectometres operator +(Hectometres first, Zettametres second)
				{
					return new Hectometres(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottametres(Hectometres value)
				{
					return (value.value)*1E-22;
				}

				public static Hectometres operator +(Hectometres first, Yottametres second)
				{
					return new Hectometres(first.value + (second.value)*1E+22);
				}
						}
		}
namespace Multiples
{

		public struct Kilometres : IValueWithUnit, IEquatable< Kilometres >, IEquatable<IValueWithUnit>
		{
			public static readonly Kilometres Zero = new Kilometres(0);
			public static readonly Kilometres One = new Kilometres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.kilometre; } }

			public Kilometres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} km", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1000);
				}
				
			public bool Equals(Kilometres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kilometres(double value)
			{
				return new Kilometres(value);
			}

			public static Kilometres operator *(Kilometres value, double times)
			{
				return new Kilometres(value.value * times);
			}

			public static Kilometres operator *(double times, Kilometres value)
			{
				return new Kilometres(value.value * times);
			}

			public static Kilometres operator +(Kilometres first, Kilometres second)
			{
				return new Kilometres(first.value * second.value);
			}

							public static implicit operator Metres(Kilometres value)
				{
					return (value.value)*1000;
				}

				public static Kilometres operator +(Kilometres first, Metres second)
				{
					return new Kilometres(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctometres(Kilometres value)
				{
					return (value.value)*1E+27;
				}

				public static Kilometres operator +(Kilometres first, Yoctometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptometres(Kilometres value)
				{
					return (value.value)*1E+24;
				}

				public static Kilometres operator +(Kilometres first, Zeptometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attometres(Kilometres value)
				{
					return (value.value)*1E+21;
				}

				public static Kilometres operator +(Kilometres first, Attometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtometres(Kilometres value)
				{
					return (value.value)*1E+18;
				}

				public static Kilometres operator +(Kilometres first, Femtometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picometres(Kilometres value)
				{
					return (value.value)*1E+15;
				}

				public static Kilometres operator +(Kilometres first, Picometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanometres(Kilometres value)
				{
					return (value.value)*1000000000000;
				}

				public static Kilometres operator +(Kilometres first, Nanometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Micrometres(Kilometres value)
				{
					return (value.value)*1000000000;
				}

				public static Kilometres operator +(Kilometres first, Micrometres second)
				{
					return new Kilometres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Millimetres(Kilometres value)
				{
					return (value.value)*1000000;
				}

				public static Kilometres operator +(Kilometres first, Millimetres second)
				{
					return new Kilometres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centimetres(Kilometres value)
				{
					return (value.value)*100000;
				}

				public static Kilometres operator +(Kilometres first, Centimetres second)
				{
					return new Kilometres(first.value + (second.value)*1E-05);
				}
								public static implicit operator Decimetres(Kilometres value)
				{
					return (value.value)*10000;
				}

				public static Kilometres operator +(Kilometres first, Decimetres second)
				{
					return new Kilometres(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decametres(Kilometres value)
				{
					return (value.value)*100;
				}

				public static Kilometres operator +(Kilometres first, Decametres second)
				{
					return new Kilometres(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectometres(Kilometres value)
				{
					return (value.value)*10;
				}

				public static Kilometres operator +(Kilometres first, Hectometres second)
				{
					return new Kilometres(first.value + (second.value)*0.1);
				}
								public static implicit operator Megametres(Kilometres value)
				{
					return (value.value)*0.001;
				}

				public static Kilometres operator +(Kilometres first, Megametres second)
				{
					return new Kilometres(first.value + (second.value)*1000);
				}
								public static implicit operator Gigametres(Kilometres value)
				{
					return (value.value)*1E-06;
				}

				public static Kilometres operator +(Kilometres first, Gigametres second)
				{
					return new Kilometres(first.value + (second.value)*1000000);
				}
								public static implicit operator Terametres(Kilometres value)
				{
					return (value.value)*1E-09;
				}

				public static Kilometres operator +(Kilometres first, Terametres second)
				{
					return new Kilometres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petametres(Kilometres value)
				{
					return (value.value)*1E-12;
				}

				public static Kilometres operator +(Kilometres first, Petametres second)
				{
					return new Kilometres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Exametres(Kilometres value)
				{
					return (value.value)*1E-15;
				}

				public static Kilometres operator +(Kilometres first, Exametres second)
				{
					return new Kilometres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettametres(Kilometres value)
				{
					return (value.value)*1E-18;
				}

				public static Kilometres operator +(Kilometres first, Zettametres second)
				{
					return new Kilometres(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottametres(Kilometres value)
				{
					return (value.value)*1E-21;
				}

				public static Kilometres operator +(Kilometres first, Yottametres second)
				{
					return new Kilometres(first.value + (second.value)*1E+21);
				}
						}
		}
namespace Multiples
{

		public struct Megametres : IValueWithUnit, IEquatable< Megametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Megametres Zero = new Megametres(0);
			public static readonly Megametres One = new Megametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.megametre; } }

			public Megametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Mm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1000000);
				}
				
			public bool Equals(Megametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megametres(double value)
			{
				return new Megametres(value);
			}

			public static Megametres operator *(Megametres value, double times)
			{
				return new Megametres(value.value * times);
			}

			public static Megametres operator *(double times, Megametres value)
			{
				return new Megametres(value.value * times);
			}

			public static Megametres operator +(Megametres first, Megametres second)
			{
				return new Megametres(first.value * second.value);
			}

							public static implicit operator Metres(Megametres value)
				{
					return (value.value)*1000000;
				}

				public static Megametres operator +(Megametres first, Metres second)
				{
					return new Megametres(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctometres(Megametres value)
				{
					return (value.value)*1E+30;
				}

				public static Megametres operator +(Megametres first, Yoctometres second)
				{
					return new Megametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptometres(Megametres value)
				{
					return (value.value)*1E+27;
				}

				public static Megametres operator +(Megametres first, Zeptometres second)
				{
					return new Megametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attometres(Megametres value)
				{
					return (value.value)*1E+24;
				}

				public static Megametres operator +(Megametres first, Attometres second)
				{
					return new Megametres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtometres(Megametres value)
				{
					return (value.value)*1E+21;
				}

				public static Megametres operator +(Megametres first, Femtometres second)
				{
					return new Megametres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picometres(Megametres value)
				{
					return (value.value)*1E+18;
				}

				public static Megametres operator +(Megametres first, Picometres second)
				{
					return new Megametres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanometres(Megametres value)
				{
					return (value.value)*1E+15;
				}

				public static Megametres operator +(Megametres first, Nanometres second)
				{
					return new Megametres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Micrometres(Megametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Megametres operator +(Megametres first, Micrometres second)
				{
					return new Megametres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Millimetres(Megametres value)
				{
					return (value.value)*1000000000;
				}

				public static Megametres operator +(Megametres first, Millimetres second)
				{
					return new Megametres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centimetres(Megametres value)
				{
					return (value.value)*100000000;
				}

				public static Megametres operator +(Megametres first, Centimetres second)
				{
					return new Megametres(first.value + (second.value)*1E-08);
				}
								public static implicit operator Decimetres(Megametres value)
				{
					return (value.value)*10000000;
				}

				public static Megametres operator +(Megametres first, Decimetres second)
				{
					return new Megametres(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decametres(Megametres value)
				{
					return (value.value)*100000;
				}

				public static Megametres operator +(Megametres first, Decametres second)
				{
					return new Megametres(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectometres(Megametres value)
				{
					return (value.value)*10000;
				}

				public static Megametres operator +(Megametres first, Hectometres second)
				{
					return new Megametres(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kilometres(Megametres value)
				{
					return (value.value)*1000;
				}

				public static Megametres operator +(Megametres first, Kilometres second)
				{
					return new Megametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigametres(Megametres value)
				{
					return (value.value)*0.001;
				}

				public static Megametres operator +(Megametres first, Gigametres second)
				{
					return new Megametres(first.value + (second.value)*1000);
				}
								public static implicit operator Terametres(Megametres value)
				{
					return (value.value)*1E-06;
				}

				public static Megametres operator +(Megametres first, Terametres second)
				{
					return new Megametres(first.value + (second.value)*1000000);
				}
								public static implicit operator Petametres(Megametres value)
				{
					return (value.value)*1E-09;
				}

				public static Megametres operator +(Megametres first, Petametres second)
				{
					return new Megametres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Exametres(Megametres value)
				{
					return (value.value)*1E-12;
				}

				public static Megametres operator +(Megametres first, Exametres second)
				{
					return new Megametres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettametres(Megametres value)
				{
					return (value.value)*1E-15;
				}

				public static Megametres operator +(Megametres first, Zettametres second)
				{
					return new Megametres(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottametres(Megametres value)
				{
					return (value.value)*1E-18;
				}

				public static Megametres operator +(Megametres first, Yottametres second)
				{
					return new Megametres(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigametres : IValueWithUnit, IEquatable< Gigametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigametres Zero = new Gigametres(0);
			public static readonly Gigametres One = new Gigametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.gigametre; } }

			public Gigametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Gm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1000000000);
				}
				
			public bool Equals(Gigametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigametres(double value)
			{
				return new Gigametres(value);
			}

			public static Gigametres operator *(Gigametres value, double times)
			{
				return new Gigametres(value.value * times);
			}

			public static Gigametres operator *(double times, Gigametres value)
			{
				return new Gigametres(value.value * times);
			}

			public static Gigametres operator +(Gigametres first, Gigametres second)
			{
				return new Gigametres(first.value * second.value);
			}

							public static implicit operator Metres(Gigametres value)
				{
					return (value.value)*1000000000;
				}

				public static Gigametres operator +(Gigametres first, Metres second)
				{
					return new Gigametres(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctometres(Gigametres value)
				{
					return (value.value)*1E+33;
				}

				public static Gigametres operator +(Gigametres first, Yoctometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptometres(Gigametres value)
				{
					return (value.value)*1E+30;
				}

				public static Gigametres operator +(Gigametres first, Zeptometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attometres(Gigametres value)
				{
					return (value.value)*1E+27;
				}

				public static Gigametres operator +(Gigametres first, Attometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtometres(Gigametres value)
				{
					return (value.value)*1E+24;
				}

				public static Gigametres operator +(Gigametres first, Femtometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picometres(Gigametres value)
				{
					return (value.value)*1E+21;
				}

				public static Gigametres operator +(Gigametres first, Picometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanometres(Gigametres value)
				{
					return (value.value)*1E+18;
				}

				public static Gigametres operator +(Gigametres first, Nanometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Micrometres(Gigametres value)
				{
					return (value.value)*1E+15;
				}

				public static Gigametres operator +(Gigametres first, Micrometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Millimetres(Gigametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigametres operator +(Gigametres first, Millimetres second)
				{
					return new Gigametres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centimetres(Gigametres value)
				{
					return (value.value)*100000000000;
				}

				public static Gigametres operator +(Gigametres first, Centimetres second)
				{
					return new Gigametres(first.value + (second.value)*1E-11);
				}
								public static implicit operator Decimetres(Gigametres value)
				{
					return (value.value)*10000000000;
				}

				public static Gigametres operator +(Gigametres first, Decimetres second)
				{
					return new Gigametres(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decametres(Gigametres value)
				{
					return (value.value)*100000000;
				}

				public static Gigametres operator +(Gigametres first, Decametres second)
				{
					return new Gigametres(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectometres(Gigametres value)
				{
					return (value.value)*10000000;
				}

				public static Gigametres operator +(Gigametres first, Hectometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kilometres(Gigametres value)
				{
					return (value.value)*1000000;
				}

				public static Gigametres operator +(Gigametres first, Kilometres second)
				{
					return new Gigametres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megametres(Gigametres value)
				{
					return (value.value)*1000;
				}

				public static Gigametres operator +(Gigametres first, Megametres second)
				{
					return new Gigametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Terametres(Gigametres value)
				{
					return (value.value)*0.001;
				}

				public static Gigametres operator +(Gigametres first, Terametres second)
				{
					return new Gigametres(first.value + (second.value)*1000);
				}
								public static implicit operator Petametres(Gigametres value)
				{
					return (value.value)*1E-06;
				}

				public static Gigametres operator +(Gigametres first, Petametres second)
				{
					return new Gigametres(first.value + (second.value)*1000000);
				}
								public static implicit operator Exametres(Gigametres value)
				{
					return (value.value)*1E-09;
				}

				public static Gigametres operator +(Gigametres first, Exametres second)
				{
					return new Gigametres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettametres(Gigametres value)
				{
					return (value.value)*1E-12;
				}

				public static Gigametres operator +(Gigametres first, Zettametres second)
				{
					return new Gigametres(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottametres(Gigametres value)
				{
					return (value.value)*1E-15;
				}

				public static Gigametres operator +(Gigametres first, Yottametres second)
				{
					return new Gigametres(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Terametres : IValueWithUnit, IEquatable< Terametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Terametres Zero = new Terametres(0);
			public static readonly Terametres One = new Terametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.terametre; } }

			public Terametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Tm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1000000000000);
				}
				
			public bool Equals(Terametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Terametres(double value)
			{
				return new Terametres(value);
			}

			public static Terametres operator *(Terametres value, double times)
			{
				return new Terametres(value.value * times);
			}

			public static Terametres operator *(double times, Terametres value)
			{
				return new Terametres(value.value * times);
			}

			public static Terametres operator +(Terametres first, Terametres second)
			{
				return new Terametres(first.value * second.value);
			}

							public static implicit operator Metres(Terametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Terametres operator +(Terametres first, Metres second)
				{
					return new Terametres(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctometres(Terametres value)
				{
					return (value.value)*1E+36;
				}

				public static Terametres operator +(Terametres first, Yoctometres second)
				{
					return new Terametres(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptometres(Terametres value)
				{
					return (value.value)*1E+33;
				}

				public static Terametres operator +(Terametres first, Zeptometres second)
				{
					return new Terametres(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attometres(Terametres value)
				{
					return (value.value)*1E+30;
				}

				public static Terametres operator +(Terametres first, Attometres second)
				{
					return new Terametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtometres(Terametres value)
				{
					return (value.value)*1E+27;
				}

				public static Terametres operator +(Terametres first, Femtometres second)
				{
					return new Terametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picometres(Terametres value)
				{
					return (value.value)*1E+24;
				}

				public static Terametres operator +(Terametres first, Picometres second)
				{
					return new Terametres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanometres(Terametres value)
				{
					return (value.value)*1E+21;
				}

				public static Terametres operator +(Terametres first, Nanometres second)
				{
					return new Terametres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Micrometres(Terametres value)
				{
					return (value.value)*1E+18;
				}

				public static Terametres operator +(Terametres first, Micrometres second)
				{
					return new Terametres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Millimetres(Terametres value)
				{
					return (value.value)*1E+15;
				}

				public static Terametres operator +(Terametres first, Millimetres second)
				{
					return new Terametres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centimetres(Terametres value)
				{
					return (value.value)*100000000000000;
				}

				public static Terametres operator +(Terametres first, Centimetres second)
				{
					return new Terametres(first.value + (second.value)*1E-14);
				}
								public static implicit operator Decimetres(Terametres value)
				{
					return (value.value)*10000000000000;
				}

				public static Terametres operator +(Terametres first, Decimetres second)
				{
					return new Terametres(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decametres(Terametres value)
				{
					return (value.value)*100000000000;
				}

				public static Terametres operator +(Terametres first, Decametres second)
				{
					return new Terametres(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectometres(Terametres value)
				{
					return (value.value)*10000000000;
				}

				public static Terametres operator +(Terametres first, Hectometres second)
				{
					return new Terametres(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kilometres(Terametres value)
				{
					return (value.value)*1000000000;
				}

				public static Terametres operator +(Terametres first, Kilometres second)
				{
					return new Terametres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megametres(Terametres value)
				{
					return (value.value)*1000000;
				}

				public static Terametres operator +(Terametres first, Megametres second)
				{
					return new Terametres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigametres(Terametres value)
				{
					return (value.value)*1000;
				}

				public static Terametres operator +(Terametres first, Gigametres second)
				{
					return new Terametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Petametres(Terametres value)
				{
					return (value.value)*0.001;
				}

				public static Terametres operator +(Terametres first, Petametres second)
				{
					return new Terametres(first.value + (second.value)*1000);
				}
								public static implicit operator Exametres(Terametres value)
				{
					return (value.value)*1E-06;
				}

				public static Terametres operator +(Terametres first, Exametres second)
				{
					return new Terametres(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettametres(Terametres value)
				{
					return (value.value)*1E-09;
				}

				public static Terametres operator +(Terametres first, Zettametres second)
				{
					return new Terametres(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottametres(Terametres value)
				{
					return (value.value)*1E-12;
				}

				public static Terametres operator +(Terametres first, Yottametres second)
				{
					return new Terametres(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petametres : IValueWithUnit, IEquatable< Petametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Petametres Zero = new Petametres(0);
			public static readonly Petametres One = new Petametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.petametre; } }

			public Petametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Pm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E+15);
				}
				
			public bool Equals(Petametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petametres(double value)
			{
				return new Petametres(value);
			}

			public static Petametres operator *(Petametres value, double times)
			{
				return new Petametres(value.value * times);
			}

			public static Petametres operator *(double times, Petametres value)
			{
				return new Petametres(value.value * times);
			}

			public static Petametres operator +(Petametres first, Petametres second)
			{
				return new Petametres(first.value * second.value);
			}

							public static implicit operator Metres(Petametres value)
				{
					return (value.value)*1E+15;
				}

				public static Petametres operator +(Petametres first, Metres second)
				{
					return new Petametres(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctometres(Petametres value)
				{
					return (value.value)*1E+39;
				}

				public static Petametres operator +(Petametres first, Yoctometres second)
				{
					return new Petametres(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptometres(Petametres value)
				{
					return (value.value)*1E+36;
				}

				public static Petametres operator +(Petametres first, Zeptometres second)
				{
					return new Petametres(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attometres(Petametres value)
				{
					return (value.value)*1E+33;
				}

				public static Petametres operator +(Petametres first, Attometres second)
				{
					return new Petametres(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtometres(Petametres value)
				{
					return (value.value)*1E+30;
				}

				public static Petametres operator +(Petametres first, Femtometres second)
				{
					return new Petametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picometres(Petametres value)
				{
					return (value.value)*1E+27;
				}

				public static Petametres operator +(Petametres first, Picometres second)
				{
					return new Petametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanometres(Petametres value)
				{
					return (value.value)*1E+24;
				}

				public static Petametres operator +(Petametres first, Nanometres second)
				{
					return new Petametres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Micrometres(Petametres value)
				{
					return (value.value)*1E+21;
				}

				public static Petametres operator +(Petametres first, Micrometres second)
				{
					return new Petametres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Millimetres(Petametres value)
				{
					return (value.value)*1E+18;
				}

				public static Petametres operator +(Petametres first, Millimetres second)
				{
					return new Petametres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centimetres(Petametres value)
				{
					return (value.value)*1E+17;
				}

				public static Petametres operator +(Petametres first, Centimetres second)
				{
					return new Petametres(first.value + (second.value)*1E-17);
				}
								public static implicit operator Decimetres(Petametres value)
				{
					return (value.value)*1E+16;
				}

				public static Petametres operator +(Petametres first, Decimetres second)
				{
					return new Petametres(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decametres(Petametres value)
				{
					return (value.value)*100000000000000;
				}

				public static Petametres operator +(Petametres first, Decametres second)
				{
					return new Petametres(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectometres(Petametres value)
				{
					return (value.value)*10000000000000;
				}

				public static Petametres operator +(Petametres first, Hectometres second)
				{
					return new Petametres(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kilometres(Petametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Petametres operator +(Petametres first, Kilometres second)
				{
					return new Petametres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megametres(Petametres value)
				{
					return (value.value)*1000000000;
				}

				public static Petametres operator +(Petametres first, Megametres second)
				{
					return new Petametres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigametres(Petametres value)
				{
					return (value.value)*1000000;
				}

				public static Petametres operator +(Petametres first, Gigametres second)
				{
					return new Petametres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Terametres(Petametres value)
				{
					return (value.value)*1000;
				}

				public static Petametres operator +(Petametres first, Terametres second)
				{
					return new Petametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Exametres(Petametres value)
				{
					return (value.value)*0.001;
				}

				public static Petametres operator +(Petametres first, Exametres second)
				{
					return new Petametres(first.value + (second.value)*1000);
				}
								public static implicit operator Zettametres(Petametres value)
				{
					return (value.value)*1E-06;
				}

				public static Petametres operator +(Petametres first, Zettametres second)
				{
					return new Petametres(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottametres(Petametres value)
				{
					return (value.value)*1E-09;
				}

				public static Petametres operator +(Petametres first, Yottametres second)
				{
					return new Petametres(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Exametres : IValueWithUnit, IEquatable< Exametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Exametres Zero = new Exametres(0);
			public static readonly Exametres One = new Exametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.exametre; } }

			public Exametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Em", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E+18);
				}
				
			public bool Equals(Exametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Exametres(double value)
			{
				return new Exametres(value);
			}

			public static Exametres operator *(Exametres value, double times)
			{
				return new Exametres(value.value * times);
			}

			public static Exametres operator *(double times, Exametres value)
			{
				return new Exametres(value.value * times);
			}

			public static Exametres operator +(Exametres first, Exametres second)
			{
				return new Exametres(first.value * second.value);
			}

							public static implicit operator Metres(Exametres value)
				{
					return (value.value)*1E+18;
				}

				public static Exametres operator +(Exametres first, Metres second)
				{
					return new Exametres(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctometres(Exametres value)
				{
					return (value.value)*1E+42;
				}

				public static Exametres operator +(Exametres first, Yoctometres second)
				{
					return new Exametres(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptometres(Exametres value)
				{
					return (value.value)*1E+39;
				}

				public static Exametres operator +(Exametres first, Zeptometres second)
				{
					return new Exametres(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attometres(Exametres value)
				{
					return (value.value)*1E+36;
				}

				public static Exametres operator +(Exametres first, Attometres second)
				{
					return new Exametres(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtometres(Exametres value)
				{
					return (value.value)*1E+33;
				}

				public static Exametres operator +(Exametres first, Femtometres second)
				{
					return new Exametres(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picometres(Exametres value)
				{
					return (value.value)*1E+30;
				}

				public static Exametres operator +(Exametres first, Picometres second)
				{
					return new Exametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanometres(Exametres value)
				{
					return (value.value)*1E+27;
				}

				public static Exametres operator +(Exametres first, Nanometres second)
				{
					return new Exametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Micrometres(Exametres value)
				{
					return (value.value)*1E+24;
				}

				public static Exametres operator +(Exametres first, Micrometres second)
				{
					return new Exametres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Millimetres(Exametres value)
				{
					return (value.value)*1E+21;
				}

				public static Exametres operator +(Exametres first, Millimetres second)
				{
					return new Exametres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centimetres(Exametres value)
				{
					return (value.value)*1E+20;
				}

				public static Exametres operator +(Exametres first, Centimetres second)
				{
					return new Exametres(first.value + (second.value)*1E-20);
				}
								public static implicit operator Decimetres(Exametres value)
				{
					return (value.value)*1E+19;
				}

				public static Exametres operator +(Exametres first, Decimetres second)
				{
					return new Exametres(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decametres(Exametres value)
				{
					return (value.value)*1E+17;
				}

				public static Exametres operator +(Exametres first, Decametres second)
				{
					return new Exametres(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectometres(Exametres value)
				{
					return (value.value)*1E+16;
				}

				public static Exametres operator +(Exametres first, Hectometres second)
				{
					return new Exametres(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kilometres(Exametres value)
				{
					return (value.value)*1E+15;
				}

				public static Exametres operator +(Exametres first, Kilometres second)
				{
					return new Exametres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megametres(Exametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Exametres operator +(Exametres first, Megametres second)
				{
					return new Exametres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigametres(Exametres value)
				{
					return (value.value)*1000000000;
				}

				public static Exametres operator +(Exametres first, Gigametres second)
				{
					return new Exametres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Terametres(Exametres value)
				{
					return (value.value)*1000000;
				}

				public static Exametres operator +(Exametres first, Terametres second)
				{
					return new Exametres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petametres(Exametres value)
				{
					return (value.value)*1000;
				}

				public static Exametres operator +(Exametres first, Petametres second)
				{
					return new Exametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettametres(Exametres value)
				{
					return (value.value)*0.001;
				}

				public static Exametres operator +(Exametres first, Zettametres second)
				{
					return new Exametres(first.value + (second.value)*1000);
				}
								public static implicit operator Yottametres(Exametres value)
				{
					return (value.value)*1E-06;
				}

				public static Exametres operator +(Exametres first, Yottametres second)
				{
					return new Exametres(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettametres : IValueWithUnit, IEquatable< Zettametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettametres Zero = new Zettametres(0);
			public static readonly Zettametres One = new Zettametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.zettametre; } }

			public Zettametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Zm", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E+21);
				}
				
			public bool Equals(Zettametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettametres(double value)
			{
				return new Zettametres(value);
			}

			public static Zettametres operator *(Zettametres value, double times)
			{
				return new Zettametres(value.value * times);
			}

			public static Zettametres operator *(double times, Zettametres value)
			{
				return new Zettametres(value.value * times);
			}

			public static Zettametres operator +(Zettametres first, Zettametres second)
			{
				return new Zettametres(first.value * second.value);
			}

							public static implicit operator Metres(Zettametres value)
				{
					return (value.value)*1E+21;
				}

				public static Zettametres operator +(Zettametres first, Metres second)
				{
					return new Zettametres(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctometres(Zettametres value)
				{
					return (value.value)*1E+45;
				}

				public static Zettametres operator +(Zettametres first, Yoctometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptometres(Zettametres value)
				{
					return (value.value)*1E+42;
				}

				public static Zettametres operator +(Zettametres first, Zeptometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attometres(Zettametres value)
				{
					return (value.value)*1E+39;
				}

				public static Zettametres operator +(Zettametres first, Attometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtometres(Zettametres value)
				{
					return (value.value)*1E+36;
				}

				public static Zettametres operator +(Zettametres first, Femtometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picometres(Zettametres value)
				{
					return (value.value)*1E+33;
				}

				public static Zettametres operator +(Zettametres first, Picometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanometres(Zettametres value)
				{
					return (value.value)*1E+30;
				}

				public static Zettametres operator +(Zettametres first, Nanometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Micrometres(Zettametres value)
				{
					return (value.value)*1E+27;
				}

				public static Zettametres operator +(Zettametres first, Micrometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Millimetres(Zettametres value)
				{
					return (value.value)*1E+24;
				}

				public static Zettametres operator +(Zettametres first, Millimetres second)
				{
					return new Zettametres(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centimetres(Zettametres value)
				{
					return (value.value)*1E+23;
				}

				public static Zettametres operator +(Zettametres first, Centimetres second)
				{
					return new Zettametres(first.value + (second.value)*1E-23);
				}
								public static implicit operator Decimetres(Zettametres value)
				{
					return (value.value)*1E+22;
				}

				public static Zettametres operator +(Zettametres first, Decimetres second)
				{
					return new Zettametres(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decametres(Zettametres value)
				{
					return (value.value)*1E+20;
				}

				public static Zettametres operator +(Zettametres first, Decametres second)
				{
					return new Zettametres(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectometres(Zettametres value)
				{
					return (value.value)*1E+19;
				}

				public static Zettametres operator +(Zettametres first, Hectometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kilometres(Zettametres value)
				{
					return (value.value)*1E+18;
				}

				public static Zettametres operator +(Zettametres first, Kilometres second)
				{
					return new Zettametres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megametres(Zettametres value)
				{
					return (value.value)*1E+15;
				}

				public static Zettametres operator +(Zettametres first, Megametres second)
				{
					return new Zettametres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigametres(Zettametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettametres operator +(Zettametres first, Gigametres second)
				{
					return new Zettametres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Terametres(Zettametres value)
				{
					return (value.value)*1000000000;
				}

				public static Zettametres operator +(Zettametres first, Terametres second)
				{
					return new Zettametres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petametres(Zettametres value)
				{
					return (value.value)*1000000;
				}

				public static Zettametres operator +(Zettametres first, Petametres second)
				{
					return new Zettametres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Exametres(Zettametres value)
				{
					return (value.value)*1000;
				}

				public static Zettametres operator +(Zettametres first, Exametres second)
				{
					return new Zettametres(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottametres(Zettametres value)
				{
					return (value.value)*0.001;
				}

				public static Zettametres operator +(Zettametres first, Yottametres second)
				{
					return new Zettametres(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottametres : IValueWithUnit, IEquatable< Yottametres >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottametres Zero = new Yottametres(0);
			public static readonly Yottametres One = new Yottametres(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Length.Units.yottametre; } }

			public Yottametres(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ym", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Metres ToBaseUnit()
				{
					return new Metres((this.value)*1E+24);
				}
				
			public bool Equals(Yottametres other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottametres(double value)
			{
				return new Yottametres(value);
			}

			public static Yottametres operator *(Yottametres value, double times)
			{
				return new Yottametres(value.value * times);
			}

			public static Yottametres operator *(double times, Yottametres value)
			{
				return new Yottametres(value.value * times);
			}

			public static Yottametres operator +(Yottametres first, Yottametres second)
			{
				return new Yottametres(first.value * second.value);
			}

							public static implicit operator Metres(Yottametres value)
				{
					return (value.value)*1E+24;
				}

				public static Yottametres operator +(Yottametres first, Metres second)
				{
					return new Yottametres(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctometres(Yottametres value)
				{
					return (value.value)*1E+48;
				}

				public static Yottametres operator +(Yottametres first, Yoctometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptometres(Yottametres value)
				{
					return (value.value)*1E+45;
				}

				public static Yottametres operator +(Yottametres first, Zeptometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attometres(Yottametres value)
				{
					return (value.value)*1E+42;
				}

				public static Yottametres operator +(Yottametres first, Attometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtometres(Yottametres value)
				{
					return (value.value)*1E+39;
				}

				public static Yottametres operator +(Yottametres first, Femtometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picometres(Yottametres value)
				{
					return (value.value)*1E+36;
				}

				public static Yottametres operator +(Yottametres first, Picometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanometres(Yottametres value)
				{
					return (value.value)*1E+33;
				}

				public static Yottametres operator +(Yottametres first, Nanometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-33);
				}
								public static implicit operator Micrometres(Yottametres value)
				{
					return (value.value)*1E+30;
				}

				public static Yottametres operator +(Yottametres first, Micrometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-30);
				}
								public static implicit operator Millimetres(Yottametres value)
				{
					return (value.value)*1E+27;
				}

				public static Yottametres operator +(Yottametres first, Millimetres second)
				{
					return new Yottametres(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centimetres(Yottametres value)
				{
					return (value.value)*1E+26;
				}

				public static Yottametres operator +(Yottametres first, Centimetres second)
				{
					return new Yottametres(first.value + (second.value)*1E-26);
				}
								public static implicit operator Decimetres(Yottametres value)
				{
					return (value.value)*1E+25;
				}

				public static Yottametres operator +(Yottametres first, Decimetres second)
				{
					return new Yottametres(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decametres(Yottametres value)
				{
					return (value.value)*1E+23;
				}

				public static Yottametres operator +(Yottametres first, Decametres second)
				{
					return new Yottametres(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectometres(Yottametres value)
				{
					return (value.value)*1E+22;
				}

				public static Yottametres operator +(Yottametres first, Hectometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kilometres(Yottametres value)
				{
					return (value.value)*1E+21;
				}

				public static Yottametres operator +(Yottametres first, Kilometres second)
				{
					return new Yottametres(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megametres(Yottametres value)
				{
					return (value.value)*1E+18;
				}

				public static Yottametres operator +(Yottametres first, Megametres second)
				{
					return new Yottametres(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigametres(Yottametres value)
				{
					return (value.value)*1E+15;
				}

				public static Yottametres operator +(Yottametres first, Gigametres second)
				{
					return new Yottametres(first.value + (second.value)*1E-15);
				}
								public static implicit operator Terametres(Yottametres value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottametres operator +(Yottametres first, Terametres second)
				{
					return new Yottametres(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petametres(Yottametres value)
				{
					return (value.value)*1000000000;
				}

				public static Yottametres operator +(Yottametres first, Petametres second)
				{
					return new Yottametres(first.value + (second.value)*1E-09);
				}
								public static implicit operator Exametres(Yottametres value)
				{
					return (value.value)*1000000;
				}

				public static Yottametres operator +(Yottametres first, Exametres second)
				{
					return new Yottametres(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettametres(Yottametres value)
				{
					return (value.value)*1000;
				}

				public static Yottametres operator +(Yottametres first, Zettametres second)
				{
					return new Yottametres(first.value + (second.value)*0.001);
				}
						}
		}

		public struct Seconds : IValueWithUnit, IEquatable< Seconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Seconds Zero = new Seconds(0);
			public static readonly Seconds One = new Seconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.second; } }

			public Seconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} s", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Seconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Seconds(double value)
			{
				return new Seconds(value);
			}

			public static Seconds operator *(Seconds value, double times)
			{
				return new Seconds(value.value * times);
			}

			public static Seconds operator *(double times, Seconds value)
			{
				return new Seconds(value.value * times);
			}

			public static Seconds operator +(Seconds first, Seconds second)
			{
				return new Seconds(first.value * second.value);
			}

							public static implicit operator Yoctoseconds(Seconds value)
				{
					return (value.value)/1E-24;
				}

				public static Seconds operator +(Seconds first, Yoctoseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptoseconds(Seconds value)
				{
					return (value.value)/1E-21;
				}

				public static Seconds operator +(Seconds first, Zeptoseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attoseconds(Seconds value)
				{
					return (value.value)/1E-18;
				}

				public static Seconds operator +(Seconds first, Attoseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtoseconds(Seconds value)
				{
					return (value.value)/1E-15;
				}

				public static Seconds operator +(Seconds first, Femtoseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picoseconds(Seconds value)
				{
					return (value.value)/1E-12;
				}

				public static Seconds operator +(Seconds first, Picoseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanoseconds(Seconds value)
				{
					return (value.value)/1E-09;
				}

				public static Seconds operator +(Seconds first, Nanoseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Microseconds(Seconds value)
				{
					return (value.value)/1E-06;
				}

				public static Seconds operator +(Seconds first, Microseconds second)
				{
					return new Seconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Milliseconds(Seconds value)
				{
					return (value.value)/0.001;
				}

				public static Seconds operator +(Seconds first, Milliseconds second)
				{
					return new Seconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Centiseconds(Seconds value)
				{
					return (value.value)/0.01;
				}

				public static Seconds operator +(Seconds first, Centiseconds second)
				{
					return new Seconds(first.value + (second.value)*0.01);
				}
								public static implicit operator Deciseconds(Seconds value)
				{
					return (value.value)/0.1;
				}

				public static Seconds operator +(Seconds first, Deciseconds second)
				{
					return new Seconds(first.value + (second.value)*0.1);
				}
								public static implicit operator Decaseconds(Seconds value)
				{
					return (value.value)/10;
				}

				public static Seconds operator +(Seconds first, Decaseconds second)
				{
					return new Seconds(first.value + (second.value)*10);
				}
								public static implicit operator Hectoseconds(Seconds value)
				{
					return (value.value)/100;
				}

				public static Seconds operator +(Seconds first, Hectoseconds second)
				{
					return new Seconds(first.value + (second.value)*100);
				}
								public static implicit operator Kiloseconds(Seconds value)
				{
					return (value.value)/1000;
				}

				public static Seconds operator +(Seconds first, Kiloseconds second)
				{
					return new Seconds(first.value + (second.value)*1000);
				}
								public static implicit operator Megaseconds(Seconds value)
				{
					return (value.value)/1000000;
				}

				public static Seconds operator +(Seconds first, Megaseconds second)
				{
					return new Seconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigaseconds(Seconds value)
				{
					return (value.value)/1000000000;
				}

				public static Seconds operator +(Seconds first, Gigaseconds second)
				{
					return new Seconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Teraseconds(Seconds value)
				{
					return (value.value)/1000000000000;
				}

				public static Seconds operator +(Seconds first, Teraseconds second)
				{
					return new Seconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petaseconds(Seconds value)
				{
					return (value.value)/1E+15;
				}

				public static Seconds operator +(Seconds first, Petaseconds second)
				{
					return new Seconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Exaseconds(Seconds value)
				{
					return (value.value)/1E+18;
				}

				public static Seconds operator +(Seconds first, Exaseconds second)
				{
					return new Seconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettaseconds(Seconds value)
				{
					return (value.value)/1E+21;
				}

				public static Seconds operator +(Seconds first, Zettaseconds second)
				{
					return new Seconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottaseconds(Seconds value)
				{
					return (value.value)/1E+24;
				}

				public static Seconds operator +(Seconds first, Yottaseconds second)
				{
					return new Seconds(first.value + (second.value)*1E+24);
				}
						}
		namespace Multiples
{

		public struct Yoctoseconds : IValueWithUnit, IEquatable< Yoctoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctoseconds Zero = new Yoctoseconds(0);
			public static readonly Yoctoseconds One = new Yoctoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.yoctosecond; } }

			public Yoctoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ys", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-24);
				}
				
			public bool Equals(Yoctoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctoseconds(double value)
			{
				return new Yoctoseconds(value);
			}

			public static Yoctoseconds operator *(Yoctoseconds value, double times)
			{
				return new Yoctoseconds(value.value * times);
			}

			public static Yoctoseconds operator *(double times, Yoctoseconds value)
			{
				return new Yoctoseconds(value.value * times);
			}

			public static Yoctoseconds operator +(Yoctoseconds first, Yoctoseconds second)
			{
				return new Yoctoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Yoctoseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Seconds second)
				{
					return new Yoctoseconds(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptoseconds(Yoctoseconds value)
				{
					return (value.value)*0.001;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Zeptoseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Attoseconds(Yoctoseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Attoseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtoseconds(Yoctoseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Femtoseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picoseconds(Yoctoseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Picoseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanoseconds(Yoctoseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Nanoseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Microseconds(Yoctoseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Microseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Milliseconds(Yoctoseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Milliseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centiseconds(Yoctoseconds value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Centiseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+22);
				}
								public static implicit operator Deciseconds(Yoctoseconds value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Deciseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Decaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectoseconds(Yoctoseconds value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Hectoseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kiloseconds(Yoctoseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Kiloseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Megaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Gigaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+33);
				}
								public static implicit operator Teraseconds(Yoctoseconds value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Teraseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Petaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+39);
				}
								public static implicit operator Exaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Exaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Zettaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottaseconds(Yoctoseconds value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctoseconds operator +(Yoctoseconds first, Yottaseconds second)
				{
					return new Yoctoseconds(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptoseconds : IValueWithUnit, IEquatable< Zeptoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptoseconds Zero = new Zeptoseconds(0);
			public static readonly Zeptoseconds One = new Zeptoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.zeptosecond; } }

			public Zeptoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-21);
				}
				
			public bool Equals(Zeptoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptoseconds(double value)
			{
				return new Zeptoseconds(value);
			}

			public static Zeptoseconds operator *(Zeptoseconds value, double times)
			{
				return new Zeptoseconds(value.value * times);
			}

			public static Zeptoseconds operator *(double times, Zeptoseconds value)
			{
				return new Zeptoseconds(value.value * times);
			}

			public static Zeptoseconds operator +(Zeptoseconds first, Zeptoseconds second)
			{
				return new Zeptoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Zeptoseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Seconds second)
				{
					return new Zeptoseconds(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctoseconds(Zeptoseconds value)
				{
					return (value.value)*1000;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Yoctoseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Attoseconds(Zeptoseconds value)
				{
					return (value.value)*0.001;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Attoseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Femtoseconds(Zeptoseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Femtoseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Picoseconds(Zeptoseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Picoseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanoseconds(Zeptoseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Nanoseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Microseconds(Zeptoseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Microseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Milliseconds(Zeptoseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Milliseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centiseconds(Zeptoseconds value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Centiseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+19);
				}
								public static implicit operator Deciseconds(Zeptoseconds value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Deciseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Decaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectoseconds(Zeptoseconds value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Hectoseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kiloseconds(Zeptoseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Kiloseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Megaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Gigaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+30);
				}
								public static implicit operator Teraseconds(Zeptoseconds value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Teraseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Petaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+36);
				}
								public static implicit operator Exaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Exaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Zettaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottaseconds(Zeptoseconds value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptoseconds operator +(Zeptoseconds first, Yottaseconds second)
				{
					return new Zeptoseconds(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attoseconds : IValueWithUnit, IEquatable< Attoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Attoseconds Zero = new Attoseconds(0);
			public static readonly Attoseconds One = new Attoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.attosecond; } }

			public Attoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} as", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-18);
				}
				
			public bool Equals(Attoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attoseconds(double value)
			{
				return new Attoseconds(value);
			}

			public static Attoseconds operator *(Attoseconds value, double times)
			{
				return new Attoseconds(value.value * times);
			}

			public static Attoseconds operator *(double times, Attoseconds value)
			{
				return new Attoseconds(value.value * times);
			}

			public static Attoseconds operator +(Attoseconds first, Attoseconds second)
			{
				return new Attoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Attoseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Attoseconds operator +(Attoseconds first, Seconds second)
				{
					return new Attoseconds(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctoseconds(Attoseconds value)
				{
					return (value.value)*1000000;
				}

				public static Attoseconds operator +(Attoseconds first, Yoctoseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptoseconds(Attoseconds value)
				{
					return (value.value)*1000;
				}

				public static Attoseconds operator +(Attoseconds first, Zeptoseconds second)
				{
					return new Attoseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtoseconds(Attoseconds value)
				{
					return (value.value)*0.001;
				}

				public static Attoseconds operator +(Attoseconds first, Femtoseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Picoseconds(Attoseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Attoseconds operator +(Attoseconds first, Picoseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanoseconds(Attoseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Attoseconds operator +(Attoseconds first, Nanoseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Microseconds(Attoseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Attoseconds operator +(Attoseconds first, Microseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Milliseconds(Attoseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Attoseconds operator +(Attoseconds first, Milliseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centiseconds(Attoseconds value)
				{
					return (value.value)*1E-16;
				}

				public static Attoseconds operator +(Attoseconds first, Centiseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+16);
				}
								public static implicit operator Deciseconds(Attoseconds value)
				{
					return (value.value)*1E-17;
				}

				public static Attoseconds operator +(Attoseconds first, Deciseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decaseconds(Attoseconds value)
				{
					return (value.value)*1E-19;
				}

				public static Attoseconds operator +(Attoseconds first, Decaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectoseconds(Attoseconds value)
				{
					return (value.value)*1E-20;
				}

				public static Attoseconds operator +(Attoseconds first, Hectoseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kiloseconds(Attoseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Attoseconds operator +(Attoseconds first, Kiloseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megaseconds(Attoseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Attoseconds operator +(Attoseconds first, Megaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigaseconds(Attoseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Attoseconds operator +(Attoseconds first, Gigaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Teraseconds(Attoseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Attoseconds operator +(Attoseconds first, Teraseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petaseconds(Attoseconds value)
				{
					return (value.value)*1E-33;
				}

				public static Attoseconds operator +(Attoseconds first, Petaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+33);
				}
								public static implicit operator Exaseconds(Attoseconds value)
				{
					return (value.value)*1E-36;
				}

				public static Attoseconds operator +(Attoseconds first, Exaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettaseconds(Attoseconds value)
				{
					return (value.value)*1E-39;
				}

				public static Attoseconds operator +(Attoseconds first, Zettaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottaseconds(Attoseconds value)
				{
					return (value.value)*1E-42;
				}

				public static Attoseconds operator +(Attoseconds first, Yottaseconds second)
				{
					return new Attoseconds(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtoseconds : IValueWithUnit, IEquatable< Femtoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtoseconds Zero = new Femtoseconds(0);
			public static readonly Femtoseconds One = new Femtoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.femtosecond; } }

			public Femtoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-15);
				}
				
			public bool Equals(Femtoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtoseconds(double value)
			{
				return new Femtoseconds(value);
			}

			public static Femtoseconds operator *(Femtoseconds value, double times)
			{
				return new Femtoseconds(value.value * times);
			}

			public static Femtoseconds operator *(double times, Femtoseconds value)
			{
				return new Femtoseconds(value.value * times);
			}

			public static Femtoseconds operator +(Femtoseconds first, Femtoseconds second)
			{
				return new Femtoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Femtoseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Femtoseconds operator +(Femtoseconds first, Seconds second)
				{
					return new Femtoseconds(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctoseconds(Femtoseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Femtoseconds operator +(Femtoseconds first, Yoctoseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptoseconds(Femtoseconds value)
				{
					return (value.value)*1000000;
				}

				public static Femtoseconds operator +(Femtoseconds first, Zeptoseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attoseconds(Femtoseconds value)
				{
					return (value.value)*1000;
				}

				public static Femtoseconds operator +(Femtoseconds first, Attoseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Picoseconds(Femtoseconds value)
				{
					return (value.value)*0.001;
				}

				public static Femtoseconds operator +(Femtoseconds first, Picoseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Nanoseconds(Femtoseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Femtoseconds operator +(Femtoseconds first, Nanoseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Microseconds(Femtoseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Femtoseconds operator +(Femtoseconds first, Microseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Milliseconds(Femtoseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Femtoseconds operator +(Femtoseconds first, Milliseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centiseconds(Femtoseconds value)
				{
					return (value.value)*1E-13;
				}

				public static Femtoseconds operator +(Femtoseconds first, Centiseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Deciseconds(Femtoseconds value)
				{
					return (value.value)*1E-14;
				}

				public static Femtoseconds operator +(Femtoseconds first, Deciseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decaseconds(Femtoseconds value)
				{
					return (value.value)*1E-16;
				}

				public static Femtoseconds operator +(Femtoseconds first, Decaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectoseconds(Femtoseconds value)
				{
					return (value.value)*1E-17;
				}

				public static Femtoseconds operator +(Femtoseconds first, Hectoseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kiloseconds(Femtoseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Femtoseconds operator +(Femtoseconds first, Kiloseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megaseconds(Femtoseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Femtoseconds operator +(Femtoseconds first, Megaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigaseconds(Femtoseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Femtoseconds operator +(Femtoseconds first, Gigaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Teraseconds(Femtoseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Femtoseconds operator +(Femtoseconds first, Teraseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petaseconds(Femtoseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Femtoseconds operator +(Femtoseconds first, Petaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+30);
				}
								public static implicit operator Exaseconds(Femtoseconds value)
				{
					return (value.value)*1E-33;
				}

				public static Femtoseconds operator +(Femtoseconds first, Exaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettaseconds(Femtoseconds value)
				{
					return (value.value)*1E-36;
				}

				public static Femtoseconds operator +(Femtoseconds first, Zettaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottaseconds(Femtoseconds value)
				{
					return (value.value)*1E-39;
				}

				public static Femtoseconds operator +(Femtoseconds first, Yottaseconds second)
				{
					return new Femtoseconds(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picoseconds : IValueWithUnit, IEquatable< Picoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Picoseconds Zero = new Picoseconds(0);
			public static readonly Picoseconds One = new Picoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.picosecond; } }

			public Picoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ps", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-12);
				}
				
			public bool Equals(Picoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picoseconds(double value)
			{
				return new Picoseconds(value);
			}

			public static Picoseconds operator *(Picoseconds value, double times)
			{
				return new Picoseconds(value.value * times);
			}

			public static Picoseconds operator *(double times, Picoseconds value)
			{
				return new Picoseconds(value.value * times);
			}

			public static Picoseconds operator +(Picoseconds first, Picoseconds second)
			{
				return new Picoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Picoseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Picoseconds operator +(Picoseconds first, Seconds second)
				{
					return new Picoseconds(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctoseconds(Picoseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Picoseconds operator +(Picoseconds first, Yoctoseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptoseconds(Picoseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Picoseconds operator +(Picoseconds first, Zeptoseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attoseconds(Picoseconds value)
				{
					return (value.value)*1000000;
				}

				public static Picoseconds operator +(Picoseconds first, Attoseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtoseconds(Picoseconds value)
				{
					return (value.value)*1000;
				}

				public static Picoseconds operator +(Picoseconds first, Femtoseconds second)
				{
					return new Picoseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanoseconds(Picoseconds value)
				{
					return (value.value)*0.001;
				}

				public static Picoseconds operator +(Picoseconds first, Nanoseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Microseconds(Picoseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Picoseconds operator +(Picoseconds first, Microseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Milliseconds(Picoseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Picoseconds operator +(Picoseconds first, Milliseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centiseconds(Picoseconds value)
				{
					return (value.value)*1E-10;
				}

				public static Picoseconds operator +(Picoseconds first, Centiseconds second)
				{
					return new Picoseconds(first.value + (second.value)*10000000000);
				}
								public static implicit operator Deciseconds(Picoseconds value)
				{
					return (value.value)*1E-11;
				}

				public static Picoseconds operator +(Picoseconds first, Deciseconds second)
				{
					return new Picoseconds(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decaseconds(Picoseconds value)
				{
					return (value.value)*1E-13;
				}

				public static Picoseconds operator +(Picoseconds first, Decaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectoseconds(Picoseconds value)
				{
					return (value.value)*1E-14;
				}

				public static Picoseconds operator +(Picoseconds first, Hectoseconds second)
				{
					return new Picoseconds(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kiloseconds(Picoseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Picoseconds operator +(Picoseconds first, Kiloseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megaseconds(Picoseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Picoseconds operator +(Picoseconds first, Megaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigaseconds(Picoseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Picoseconds operator +(Picoseconds first, Gigaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Teraseconds(Picoseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Picoseconds operator +(Picoseconds first, Teraseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petaseconds(Picoseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Picoseconds operator +(Picoseconds first, Petaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Exaseconds(Picoseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Picoseconds operator +(Picoseconds first, Exaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettaseconds(Picoseconds value)
				{
					return (value.value)*1E-33;
				}

				public static Picoseconds operator +(Picoseconds first, Zettaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottaseconds(Picoseconds value)
				{
					return (value.value)*1E-36;
				}

				public static Picoseconds operator +(Picoseconds first, Yottaseconds second)
				{
					return new Picoseconds(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanoseconds : IValueWithUnit, IEquatable< Nanoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanoseconds Zero = new Nanoseconds(0);
			public static readonly Nanoseconds One = new Nanoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.nanosecond; } }

			public Nanoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ns", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-09);
				}
				
			public bool Equals(Nanoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanoseconds(double value)
			{
				return new Nanoseconds(value);
			}

			public static Nanoseconds operator *(Nanoseconds value, double times)
			{
				return new Nanoseconds(value.value * times);
			}

			public static Nanoseconds operator *(double times, Nanoseconds value)
			{
				return new Nanoseconds(value.value * times);
			}

			public static Nanoseconds operator +(Nanoseconds first, Nanoseconds second)
			{
				return new Nanoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Nanoseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Nanoseconds operator +(Nanoseconds first, Seconds second)
				{
					return new Nanoseconds(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctoseconds(Nanoseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Nanoseconds operator +(Nanoseconds first, Yoctoseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptoseconds(Nanoseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanoseconds operator +(Nanoseconds first, Zeptoseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attoseconds(Nanoseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Nanoseconds operator +(Nanoseconds first, Attoseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtoseconds(Nanoseconds value)
				{
					return (value.value)*1000000;
				}

				public static Nanoseconds operator +(Nanoseconds first, Femtoseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picoseconds(Nanoseconds value)
				{
					return (value.value)*1000;
				}

				public static Nanoseconds operator +(Nanoseconds first, Picoseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Microseconds(Nanoseconds value)
				{
					return (value.value)*0.001;
				}

				public static Nanoseconds operator +(Nanoseconds first, Microseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Milliseconds(Nanoseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Nanoseconds operator +(Nanoseconds first, Milliseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Centiseconds(Nanoseconds value)
				{
					return (value.value)*1E-07;
				}

				public static Nanoseconds operator +(Nanoseconds first, Centiseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*10000000);
				}
								public static implicit operator Deciseconds(Nanoseconds value)
				{
					return (value.value)*1E-08;
				}

				public static Nanoseconds operator +(Nanoseconds first, Deciseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*100000000);
				}
								public static implicit operator Decaseconds(Nanoseconds value)
				{
					return (value.value)*1E-10;
				}

				public static Nanoseconds operator +(Nanoseconds first, Decaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectoseconds(Nanoseconds value)
				{
					return (value.value)*1E-11;
				}

				public static Nanoseconds operator +(Nanoseconds first, Hectoseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kiloseconds(Nanoseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Nanoseconds operator +(Nanoseconds first, Kiloseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megaseconds(Nanoseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Nanoseconds operator +(Nanoseconds first, Megaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigaseconds(Nanoseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Nanoseconds operator +(Nanoseconds first, Gigaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Teraseconds(Nanoseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Nanoseconds operator +(Nanoseconds first, Teraseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petaseconds(Nanoseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Nanoseconds operator +(Nanoseconds first, Petaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Exaseconds(Nanoseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Nanoseconds operator +(Nanoseconds first, Exaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettaseconds(Nanoseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Nanoseconds operator +(Nanoseconds first, Zettaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottaseconds(Nanoseconds value)
				{
					return (value.value)*1E-33;
				}

				public static Nanoseconds operator +(Nanoseconds first, Yottaseconds second)
				{
					return new Nanoseconds(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Microseconds : IValueWithUnit, IEquatable< Microseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Microseconds Zero = new Microseconds(0);
			public static readonly Microseconds One = new Microseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.microsecond; } }

			public Microseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E-06);
				}
				
			public bool Equals(Microseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Microseconds(double value)
			{
				return new Microseconds(value);
			}

			public static Microseconds operator *(Microseconds value, double times)
			{
				return new Microseconds(value.value * times);
			}

			public static Microseconds operator *(double times, Microseconds value)
			{
				return new Microseconds(value.value * times);
			}

			public static Microseconds operator +(Microseconds first, Microseconds second)
			{
				return new Microseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Microseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Microseconds operator +(Microseconds first, Seconds second)
				{
					return new Microseconds(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctoseconds(Microseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Microseconds operator +(Microseconds first, Yoctoseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptoseconds(Microseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Microseconds operator +(Microseconds first, Zeptoseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attoseconds(Microseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Microseconds operator +(Microseconds first, Attoseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtoseconds(Microseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Microseconds operator +(Microseconds first, Femtoseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picoseconds(Microseconds value)
				{
					return (value.value)*1000000;
				}

				public static Microseconds operator +(Microseconds first, Picoseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanoseconds(Microseconds value)
				{
					return (value.value)*1000;
				}

				public static Microseconds operator +(Microseconds first, Nanoseconds second)
				{
					return new Microseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Milliseconds(Microseconds value)
				{
					return (value.value)*0.001;
				}

				public static Microseconds operator +(Microseconds first, Milliseconds second)
				{
					return new Microseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Centiseconds(Microseconds value)
				{
					return (value.value)*0.0001;
				}

				public static Microseconds operator +(Microseconds first, Centiseconds second)
				{
					return new Microseconds(first.value + (second.value)*10000);
				}
								public static implicit operator Deciseconds(Microseconds value)
				{
					return (value.value)*1E-05;
				}

				public static Microseconds operator +(Microseconds first, Deciseconds second)
				{
					return new Microseconds(first.value + (second.value)*100000);
				}
								public static implicit operator Decaseconds(Microseconds value)
				{
					return (value.value)*1E-07;
				}

				public static Microseconds operator +(Microseconds first, Decaseconds second)
				{
					return new Microseconds(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectoseconds(Microseconds value)
				{
					return (value.value)*1E-08;
				}

				public static Microseconds operator +(Microseconds first, Hectoseconds second)
				{
					return new Microseconds(first.value + (second.value)*100000000);
				}
								public static implicit operator Kiloseconds(Microseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Microseconds operator +(Microseconds first, Kiloseconds second)
				{
					return new Microseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megaseconds(Microseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Microseconds operator +(Microseconds first, Megaseconds second)
				{
					return new Microseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigaseconds(Microseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Microseconds operator +(Microseconds first, Gigaseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Teraseconds(Microseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Microseconds operator +(Microseconds first, Teraseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petaseconds(Microseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Microseconds operator +(Microseconds first, Petaseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Exaseconds(Microseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Microseconds operator +(Microseconds first, Exaseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettaseconds(Microseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Microseconds operator +(Microseconds first, Zettaseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottaseconds(Microseconds value)
				{
					return (value.value)*1E-30;
				}

				public static Microseconds operator +(Microseconds first, Yottaseconds second)
				{
					return new Microseconds(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Milliseconds : IValueWithUnit, IEquatable< Milliseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Milliseconds Zero = new Milliseconds(0);
			public static readonly Milliseconds One = new Milliseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.millisecond; } }

			public Milliseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ms", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*0.001);
				}
				
			public bool Equals(Milliseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Milliseconds(double value)
			{
				return new Milliseconds(value);
			}

			public static Milliseconds operator *(Milliseconds value, double times)
			{
				return new Milliseconds(value.value * times);
			}

			public static Milliseconds operator *(double times, Milliseconds value)
			{
				return new Milliseconds(value.value * times);
			}

			public static Milliseconds operator +(Milliseconds first, Milliseconds second)
			{
				return new Milliseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Milliseconds value)
				{
					return (value.value)*0.001;
				}

				public static Milliseconds operator +(Milliseconds first, Seconds second)
				{
					return new Milliseconds(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctoseconds(Milliseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Milliseconds operator +(Milliseconds first, Yoctoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptoseconds(Milliseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Milliseconds operator +(Milliseconds first, Zeptoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attoseconds(Milliseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Milliseconds operator +(Milliseconds first, Attoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtoseconds(Milliseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Milliseconds operator +(Milliseconds first, Femtoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picoseconds(Milliseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Milliseconds operator +(Milliseconds first, Picoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanoseconds(Milliseconds value)
				{
					return (value.value)*1000000;
				}

				public static Milliseconds operator +(Milliseconds first, Nanoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Microseconds(Milliseconds value)
				{
					return (value.value)*1000;
				}

				public static Milliseconds operator +(Milliseconds first, Microseconds second)
				{
					return new Milliseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Centiseconds(Milliseconds value)
				{
					return (value.value)*0.1;
				}

				public static Milliseconds operator +(Milliseconds first, Centiseconds second)
				{
					return new Milliseconds(first.value + (second.value)*10);
				}
								public static implicit operator Deciseconds(Milliseconds value)
				{
					return (value.value)*0.01;
				}

				public static Milliseconds operator +(Milliseconds first, Deciseconds second)
				{
					return new Milliseconds(first.value + (second.value)*100);
				}
								public static implicit operator Decaseconds(Milliseconds value)
				{
					return (value.value)*0.0001;
				}

				public static Milliseconds operator +(Milliseconds first, Decaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*10000);
				}
								public static implicit operator Hectoseconds(Milliseconds value)
				{
					return (value.value)*1E-05;
				}

				public static Milliseconds operator +(Milliseconds first, Hectoseconds second)
				{
					return new Milliseconds(first.value + (second.value)*100000);
				}
								public static implicit operator Kiloseconds(Milliseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Milliseconds operator +(Milliseconds first, Kiloseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Megaseconds(Milliseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Milliseconds operator +(Milliseconds first, Megaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigaseconds(Milliseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Milliseconds operator +(Milliseconds first, Gigaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Teraseconds(Milliseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Milliseconds operator +(Milliseconds first, Teraseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petaseconds(Milliseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Milliseconds operator +(Milliseconds first, Petaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Exaseconds(Milliseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Milliseconds operator +(Milliseconds first, Exaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettaseconds(Milliseconds value)
				{
					return (value.value)*1E-24;
				}

				public static Milliseconds operator +(Milliseconds first, Zettaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottaseconds(Milliseconds value)
				{
					return (value.value)*1E-27;
				}

				public static Milliseconds operator +(Milliseconds first, Yottaseconds second)
				{
					return new Milliseconds(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centiseconds : IValueWithUnit, IEquatable< Centiseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Centiseconds Zero = new Centiseconds(0);
			public static readonly Centiseconds One = new Centiseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.centisecond; } }

			public Centiseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*0.01);
				}
				
			public bool Equals(Centiseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centiseconds(double value)
			{
				return new Centiseconds(value);
			}

			public static Centiseconds operator *(Centiseconds value, double times)
			{
				return new Centiseconds(value.value * times);
			}

			public static Centiseconds operator *(double times, Centiseconds value)
			{
				return new Centiseconds(value.value * times);
			}

			public static Centiseconds operator +(Centiseconds first, Centiseconds second)
			{
				return new Centiseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Centiseconds value)
				{
					return (value.value)*0.01;
				}

				public static Centiseconds operator +(Centiseconds first, Seconds second)
				{
					return new Centiseconds(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctoseconds(Centiseconds value)
				{
					return (value.value)*1E+22;
				}

				public static Centiseconds operator +(Centiseconds first, Yoctoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptoseconds(Centiseconds value)
				{
					return (value.value)*1E+19;
				}

				public static Centiseconds operator +(Centiseconds first, Zeptoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attoseconds(Centiseconds value)
				{
					return (value.value)*1E+16;
				}

				public static Centiseconds operator +(Centiseconds first, Attoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtoseconds(Centiseconds value)
				{
					return (value.value)*10000000000000;
				}

				public static Centiseconds operator +(Centiseconds first, Femtoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picoseconds(Centiseconds value)
				{
					return (value.value)*10000000000;
				}

				public static Centiseconds operator +(Centiseconds first, Picoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanoseconds(Centiseconds value)
				{
					return (value.value)*10000000;
				}

				public static Centiseconds operator +(Centiseconds first, Nanoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E-07);
				}
								public static implicit operator Microseconds(Centiseconds value)
				{
					return (value.value)*10000;
				}

				public static Centiseconds operator +(Centiseconds first, Microseconds second)
				{
					return new Centiseconds(first.value + (second.value)*0.0001);
				}
								public static implicit operator Milliseconds(Centiseconds value)
				{
					return (value.value)*10;
				}

				public static Centiseconds operator +(Centiseconds first, Milliseconds second)
				{
					return new Centiseconds(first.value + (second.value)*0.1);
				}
								public static implicit operator Deciseconds(Centiseconds value)
				{
					return (value.value)*0.1;
				}

				public static Centiseconds operator +(Centiseconds first, Deciseconds second)
				{
					return new Centiseconds(first.value + (second.value)*10);
				}
								public static implicit operator Decaseconds(Centiseconds value)
				{
					return (value.value)*0.001;
				}

				public static Centiseconds operator +(Centiseconds first, Decaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Hectoseconds(Centiseconds value)
				{
					return (value.value)*0.0001;
				}

				public static Centiseconds operator +(Centiseconds first, Hectoseconds second)
				{
					return new Centiseconds(first.value + (second.value)*10000);
				}
								public static implicit operator Kiloseconds(Centiseconds value)
				{
					return (value.value)*1E-05;
				}

				public static Centiseconds operator +(Centiseconds first, Kiloseconds second)
				{
					return new Centiseconds(first.value + (second.value)*100000);
				}
								public static implicit operator Megaseconds(Centiseconds value)
				{
					return (value.value)*1E-08;
				}

				public static Centiseconds operator +(Centiseconds first, Megaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigaseconds(Centiseconds value)
				{
					return (value.value)*1E-11;
				}

				public static Centiseconds operator +(Centiseconds first, Gigaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*100000000000);
				}
								public static implicit operator Teraseconds(Centiseconds value)
				{
					return (value.value)*1E-14;
				}

				public static Centiseconds operator +(Centiseconds first, Teraseconds second)
				{
					return new Centiseconds(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petaseconds(Centiseconds value)
				{
					return (value.value)*1E-17;
				}

				public static Centiseconds operator +(Centiseconds first, Petaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E+17);
				}
								public static implicit operator Exaseconds(Centiseconds value)
				{
					return (value.value)*1E-20;
				}

				public static Centiseconds operator +(Centiseconds first, Exaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettaseconds(Centiseconds value)
				{
					return (value.value)*1E-23;
				}

				public static Centiseconds operator +(Centiseconds first, Zettaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottaseconds(Centiseconds value)
				{
					return (value.value)*1E-26;
				}

				public static Centiseconds operator +(Centiseconds first, Yottaseconds second)
				{
					return new Centiseconds(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Deciseconds : IValueWithUnit, IEquatable< Deciseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Deciseconds Zero = new Deciseconds(0);
			public static readonly Deciseconds One = new Deciseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.decisecond; } }

			public Deciseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ds", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*0.1);
				}
				
			public bool Equals(Deciseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Deciseconds(double value)
			{
				return new Deciseconds(value);
			}

			public static Deciseconds operator *(Deciseconds value, double times)
			{
				return new Deciseconds(value.value * times);
			}

			public static Deciseconds operator *(double times, Deciseconds value)
			{
				return new Deciseconds(value.value * times);
			}

			public static Deciseconds operator +(Deciseconds first, Deciseconds second)
			{
				return new Deciseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Deciseconds value)
				{
					return (value.value)*0.1;
				}

				public static Deciseconds operator +(Deciseconds first, Seconds second)
				{
					return new Deciseconds(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctoseconds(Deciseconds value)
				{
					return (value.value)*1E+23;
				}

				public static Deciseconds operator +(Deciseconds first, Yoctoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptoseconds(Deciseconds value)
				{
					return (value.value)*1E+20;
				}

				public static Deciseconds operator +(Deciseconds first, Zeptoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attoseconds(Deciseconds value)
				{
					return (value.value)*1E+17;
				}

				public static Deciseconds operator +(Deciseconds first, Attoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtoseconds(Deciseconds value)
				{
					return (value.value)*100000000000000;
				}

				public static Deciseconds operator +(Deciseconds first, Femtoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picoseconds(Deciseconds value)
				{
					return (value.value)*100000000000;
				}

				public static Deciseconds operator +(Deciseconds first, Picoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanoseconds(Deciseconds value)
				{
					return (value.value)*100000000;
				}

				public static Deciseconds operator +(Deciseconds first, Nanoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-08);
				}
								public static implicit operator Microseconds(Deciseconds value)
				{
					return (value.value)*100000;
				}

				public static Deciseconds operator +(Deciseconds first, Microseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E-05);
				}
								public static implicit operator Milliseconds(Deciseconds value)
				{
					return (value.value)*100;
				}

				public static Deciseconds operator +(Deciseconds first, Milliseconds second)
				{
					return new Deciseconds(first.value + (second.value)*0.01);
				}
								public static implicit operator Centiseconds(Deciseconds value)
				{
					return (value.value)*10;
				}

				public static Deciseconds operator +(Deciseconds first, Centiseconds second)
				{
					return new Deciseconds(first.value + (second.value)*0.1);
				}
								public static implicit operator Decaseconds(Deciseconds value)
				{
					return (value.value)*0.01;
				}

				public static Deciseconds operator +(Deciseconds first, Decaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*100);
				}
								public static implicit operator Hectoseconds(Deciseconds value)
				{
					return (value.value)*0.001;
				}

				public static Deciseconds operator +(Deciseconds first, Hectoseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Kiloseconds(Deciseconds value)
				{
					return (value.value)*0.0001;
				}

				public static Deciseconds operator +(Deciseconds first, Kiloseconds second)
				{
					return new Deciseconds(first.value + (second.value)*10000);
				}
								public static implicit operator Megaseconds(Deciseconds value)
				{
					return (value.value)*1E-07;
				}

				public static Deciseconds operator +(Deciseconds first, Megaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigaseconds(Deciseconds value)
				{
					return (value.value)*1E-10;
				}

				public static Deciseconds operator +(Deciseconds first, Gigaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*10000000000);
				}
								public static implicit operator Teraseconds(Deciseconds value)
				{
					return (value.value)*1E-13;
				}

				public static Deciseconds operator +(Deciseconds first, Teraseconds second)
				{
					return new Deciseconds(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petaseconds(Deciseconds value)
				{
					return (value.value)*1E-16;
				}

				public static Deciseconds operator +(Deciseconds first, Petaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E+16);
				}
								public static implicit operator Exaseconds(Deciseconds value)
				{
					return (value.value)*1E-19;
				}

				public static Deciseconds operator +(Deciseconds first, Exaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettaseconds(Deciseconds value)
				{
					return (value.value)*1E-22;
				}

				public static Deciseconds operator +(Deciseconds first, Zettaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottaseconds(Deciseconds value)
				{
					return (value.value)*1E-25;
				}

				public static Deciseconds operator +(Deciseconds first, Yottaseconds second)
				{
					return new Deciseconds(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decaseconds : IValueWithUnit, IEquatable< Decaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Decaseconds Zero = new Decaseconds(0);
			public static readonly Decaseconds One = new Decaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.decasecond; } }

			public Decaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} das", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*10);
				}
				
			public bool Equals(Decaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decaseconds(double value)
			{
				return new Decaseconds(value);
			}

			public static Decaseconds operator *(Decaseconds value, double times)
			{
				return new Decaseconds(value.value * times);
			}

			public static Decaseconds operator *(double times, Decaseconds value)
			{
				return new Decaseconds(value.value * times);
			}

			public static Decaseconds operator +(Decaseconds first, Decaseconds second)
			{
				return new Decaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Decaseconds value)
				{
					return (value.value)*10;
				}

				public static Decaseconds operator +(Decaseconds first, Seconds second)
				{
					return new Decaseconds(first.value + (second.value)/10);
				}
								public static implicit operator Yoctoseconds(Decaseconds value)
				{
					return (value.value)*1E+25;
				}

				public static Decaseconds operator +(Decaseconds first, Yoctoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptoseconds(Decaseconds value)
				{
					return (value.value)*1E+22;
				}

				public static Decaseconds operator +(Decaseconds first, Zeptoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attoseconds(Decaseconds value)
				{
					return (value.value)*1E+19;
				}

				public static Decaseconds operator +(Decaseconds first, Attoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtoseconds(Decaseconds value)
				{
					return (value.value)*1E+16;
				}

				public static Decaseconds operator +(Decaseconds first, Femtoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picoseconds(Decaseconds value)
				{
					return (value.value)*10000000000000;
				}

				public static Decaseconds operator +(Decaseconds first, Picoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanoseconds(Decaseconds value)
				{
					return (value.value)*10000000000;
				}

				public static Decaseconds operator +(Decaseconds first, Nanoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-10);
				}
								public static implicit operator Microseconds(Decaseconds value)
				{
					return (value.value)*10000000;
				}

				public static Decaseconds operator +(Decaseconds first, Microseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E-07);
				}
								public static implicit operator Milliseconds(Decaseconds value)
				{
					return (value.value)*10000;
				}

				public static Decaseconds operator +(Decaseconds first, Milliseconds second)
				{
					return new Decaseconds(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centiseconds(Decaseconds value)
				{
					return (value.value)*1000;
				}

				public static Decaseconds operator +(Decaseconds first, Centiseconds second)
				{
					return new Decaseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Deciseconds(Decaseconds value)
				{
					return (value.value)*100;
				}

				public static Decaseconds operator +(Decaseconds first, Deciseconds second)
				{
					return new Decaseconds(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectoseconds(Decaseconds value)
				{
					return (value.value)*0.1;
				}

				public static Decaseconds operator +(Decaseconds first, Hectoseconds second)
				{
					return new Decaseconds(first.value + (second.value)*10);
				}
								public static implicit operator Kiloseconds(Decaseconds value)
				{
					return (value.value)*0.01;
				}

				public static Decaseconds operator +(Decaseconds first, Kiloseconds second)
				{
					return new Decaseconds(first.value + (second.value)*100);
				}
								public static implicit operator Megaseconds(Decaseconds value)
				{
					return (value.value)*1E-05;
				}

				public static Decaseconds operator +(Decaseconds first, Megaseconds second)
				{
					return new Decaseconds(first.value + (second.value)*100000);
				}
								public static implicit operator Gigaseconds(Decaseconds value)
				{
					return (value.value)*1E-08;
				}

				public static Decaseconds operator +(Decaseconds first, Gigaseconds second)
				{
					return new Decaseconds(first.value + (second.value)*100000000);
				}
								public static implicit operator Teraseconds(Decaseconds value)
				{
					return (value.value)*1E-11;
				}

				public static Decaseconds operator +(Decaseconds first, Teraseconds second)
				{
					return new Decaseconds(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petaseconds(Decaseconds value)
				{
					return (value.value)*1E-14;
				}

				public static Decaseconds operator +(Decaseconds first, Petaseconds second)
				{
					return new Decaseconds(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Exaseconds(Decaseconds value)
				{
					return (value.value)*1E-17;
				}

				public static Decaseconds operator +(Decaseconds first, Exaseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettaseconds(Decaseconds value)
				{
					return (value.value)*1E-20;
				}

				public static Decaseconds operator +(Decaseconds first, Zettaseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottaseconds(Decaseconds value)
				{
					return (value.value)*1E-23;
				}

				public static Decaseconds operator +(Decaseconds first, Yottaseconds second)
				{
					return new Decaseconds(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectoseconds : IValueWithUnit, IEquatable< Hectoseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectoseconds Zero = new Hectoseconds(0);
			public static readonly Hectoseconds One = new Hectoseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.hectosecond; } }

			public Hectoseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*100);
				}
				
			public bool Equals(Hectoseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectoseconds(double value)
			{
				return new Hectoseconds(value);
			}

			public static Hectoseconds operator *(Hectoseconds value, double times)
			{
				return new Hectoseconds(value.value * times);
			}

			public static Hectoseconds operator *(double times, Hectoseconds value)
			{
				return new Hectoseconds(value.value * times);
			}

			public static Hectoseconds operator +(Hectoseconds first, Hectoseconds second)
			{
				return new Hectoseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Hectoseconds value)
				{
					return (value.value)*100;
				}

				public static Hectoseconds operator +(Hectoseconds first, Seconds second)
				{
					return new Hectoseconds(first.value + (second.value)/100);
				}
								public static implicit operator Yoctoseconds(Hectoseconds value)
				{
					return (value.value)*1E+26;
				}

				public static Hectoseconds operator +(Hectoseconds first, Yoctoseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptoseconds(Hectoseconds value)
				{
					return (value.value)*1E+23;
				}

				public static Hectoseconds operator +(Hectoseconds first, Zeptoseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attoseconds(Hectoseconds value)
				{
					return (value.value)*1E+20;
				}

				public static Hectoseconds operator +(Hectoseconds first, Attoseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtoseconds(Hectoseconds value)
				{
					return (value.value)*1E+17;
				}

				public static Hectoseconds operator +(Hectoseconds first, Femtoseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picoseconds(Hectoseconds value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectoseconds operator +(Hectoseconds first, Picoseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanoseconds(Hectoseconds value)
				{
					return (value.value)*100000000000;
				}

				public static Hectoseconds operator +(Hectoseconds first, Nanoseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-11);
				}
								public static implicit operator Microseconds(Hectoseconds value)
				{
					return (value.value)*100000000;
				}

				public static Hectoseconds operator +(Hectoseconds first, Microseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-08);
				}
								public static implicit operator Milliseconds(Hectoseconds value)
				{
					return (value.value)*100000;
				}

				public static Hectoseconds operator +(Hectoseconds first, Milliseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centiseconds(Hectoseconds value)
				{
					return (value.value)*10000;
				}

				public static Hectoseconds operator +(Hectoseconds first, Centiseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*0.0001);
				}
								public static implicit operator Deciseconds(Hectoseconds value)
				{
					return (value.value)*1000;
				}

				public static Hectoseconds operator +(Hectoseconds first, Deciseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Decaseconds(Hectoseconds value)
				{
					return (value.value)*10;
				}

				public static Hectoseconds operator +(Hectoseconds first, Decaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*0.1);
				}
								public static implicit operator Kiloseconds(Hectoseconds value)
				{
					return (value.value)*0.1;
				}

				public static Hectoseconds operator +(Hectoseconds first, Kiloseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*10);
				}
								public static implicit operator Megaseconds(Hectoseconds value)
				{
					return (value.value)*0.0001;
				}

				public static Hectoseconds operator +(Hectoseconds first, Megaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*10000);
				}
								public static implicit operator Gigaseconds(Hectoseconds value)
				{
					return (value.value)*1E-07;
				}

				public static Hectoseconds operator +(Hectoseconds first, Gigaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*10000000);
				}
								public static implicit operator Teraseconds(Hectoseconds value)
				{
					return (value.value)*1E-10;
				}

				public static Hectoseconds operator +(Hectoseconds first, Teraseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petaseconds(Hectoseconds value)
				{
					return (value.value)*1E-13;
				}

				public static Hectoseconds operator +(Hectoseconds first, Petaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Exaseconds(Hectoseconds value)
				{
					return (value.value)*1E-16;
				}

				public static Hectoseconds operator +(Hectoseconds first, Exaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettaseconds(Hectoseconds value)
				{
					return (value.value)*1E-19;
				}

				public static Hectoseconds operator +(Hectoseconds first, Zettaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottaseconds(Hectoseconds value)
				{
					return (value.value)*1E-22;
				}

				public static Hectoseconds operator +(Hectoseconds first, Yottaseconds second)
				{
					return new Hectoseconds(first.value + (second.value)*1E+22);
				}
						}
		}
namespace Multiples
{

		public struct Kiloseconds : IValueWithUnit, IEquatable< Kiloseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Kiloseconds Zero = new Kiloseconds(0);
			public static readonly Kiloseconds One = new Kiloseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.kilosecond; } }

			public Kiloseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ks", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1000);
				}
				
			public bool Equals(Kiloseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kiloseconds(double value)
			{
				return new Kiloseconds(value);
			}

			public static Kiloseconds operator *(Kiloseconds value, double times)
			{
				return new Kiloseconds(value.value * times);
			}

			public static Kiloseconds operator *(double times, Kiloseconds value)
			{
				return new Kiloseconds(value.value * times);
			}

			public static Kiloseconds operator +(Kiloseconds first, Kiloseconds second)
			{
				return new Kiloseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Kiloseconds value)
				{
					return (value.value)*1000;
				}

				public static Kiloseconds operator +(Kiloseconds first, Seconds second)
				{
					return new Kiloseconds(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctoseconds(Kiloseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Kiloseconds operator +(Kiloseconds first, Yoctoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptoseconds(Kiloseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Kiloseconds operator +(Kiloseconds first, Zeptoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attoseconds(Kiloseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Kiloseconds operator +(Kiloseconds first, Attoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtoseconds(Kiloseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Kiloseconds operator +(Kiloseconds first, Femtoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picoseconds(Kiloseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Kiloseconds operator +(Kiloseconds first, Picoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanoseconds(Kiloseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Kiloseconds operator +(Kiloseconds first, Nanoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Microseconds(Kiloseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Kiloseconds operator +(Kiloseconds first, Microseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Milliseconds(Kiloseconds value)
				{
					return (value.value)*1000000;
				}

				public static Kiloseconds operator +(Kiloseconds first, Milliseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centiseconds(Kiloseconds value)
				{
					return (value.value)*100000;
				}

				public static Kiloseconds operator +(Kiloseconds first, Centiseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E-05);
				}
								public static implicit operator Deciseconds(Kiloseconds value)
				{
					return (value.value)*10000;
				}

				public static Kiloseconds operator +(Kiloseconds first, Deciseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decaseconds(Kiloseconds value)
				{
					return (value.value)*100;
				}

				public static Kiloseconds operator +(Kiloseconds first, Decaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectoseconds(Kiloseconds value)
				{
					return (value.value)*10;
				}

				public static Kiloseconds operator +(Kiloseconds first, Hectoseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*0.1);
				}
								public static implicit operator Megaseconds(Kiloseconds value)
				{
					return (value.value)*0.001;
				}

				public static Kiloseconds operator +(Kiloseconds first, Megaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Gigaseconds(Kiloseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Kiloseconds operator +(Kiloseconds first, Gigaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Teraseconds(Kiloseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Kiloseconds operator +(Kiloseconds first, Teraseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petaseconds(Kiloseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Kiloseconds operator +(Kiloseconds first, Petaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Exaseconds(Kiloseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Kiloseconds operator +(Kiloseconds first, Exaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettaseconds(Kiloseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Kiloseconds operator +(Kiloseconds first, Zettaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottaseconds(Kiloseconds value)
				{
					return (value.value)*1E-21;
				}

				public static Kiloseconds operator +(Kiloseconds first, Yottaseconds second)
				{
					return new Kiloseconds(first.value + (second.value)*1E+21);
				}
						}
		}
namespace Multiples
{

		public struct Megaseconds : IValueWithUnit, IEquatable< Megaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Megaseconds Zero = new Megaseconds(0);
			public static readonly Megaseconds One = new Megaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.megasecond; } }

			public Megaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ms", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1000000);
				}
				
			public bool Equals(Megaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megaseconds(double value)
			{
				return new Megaseconds(value);
			}

			public static Megaseconds operator *(Megaseconds value, double times)
			{
				return new Megaseconds(value.value * times);
			}

			public static Megaseconds operator *(double times, Megaseconds value)
			{
				return new Megaseconds(value.value * times);
			}

			public static Megaseconds operator +(Megaseconds first, Megaseconds second)
			{
				return new Megaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Megaseconds value)
				{
					return (value.value)*1000000;
				}

				public static Megaseconds operator +(Megaseconds first, Seconds second)
				{
					return new Megaseconds(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctoseconds(Megaseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Megaseconds operator +(Megaseconds first, Yoctoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptoseconds(Megaseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Megaseconds operator +(Megaseconds first, Zeptoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attoseconds(Megaseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Megaseconds operator +(Megaseconds first, Attoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtoseconds(Megaseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Megaseconds operator +(Megaseconds first, Femtoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picoseconds(Megaseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Megaseconds operator +(Megaseconds first, Picoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanoseconds(Megaseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Megaseconds operator +(Megaseconds first, Nanoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Microseconds(Megaseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Megaseconds operator +(Megaseconds first, Microseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Milliseconds(Megaseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Megaseconds operator +(Megaseconds first, Milliseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centiseconds(Megaseconds value)
				{
					return (value.value)*100000000;
				}

				public static Megaseconds operator +(Megaseconds first, Centiseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-08);
				}
								public static implicit operator Deciseconds(Megaseconds value)
				{
					return (value.value)*10000000;
				}

				public static Megaseconds operator +(Megaseconds first, Deciseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decaseconds(Megaseconds value)
				{
					return (value.value)*100000;
				}

				public static Megaseconds operator +(Megaseconds first, Decaseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectoseconds(Megaseconds value)
				{
					return (value.value)*10000;
				}

				public static Megaseconds operator +(Megaseconds first, Hectoseconds second)
				{
					return new Megaseconds(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kiloseconds(Megaseconds value)
				{
					return (value.value)*1000;
				}

				public static Megaseconds operator +(Megaseconds first, Kiloseconds second)
				{
					return new Megaseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigaseconds(Megaseconds value)
				{
					return (value.value)*0.001;
				}

				public static Megaseconds operator +(Megaseconds first, Gigaseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Teraseconds(Megaseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Megaseconds operator +(Megaseconds first, Teraseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Petaseconds(Megaseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Megaseconds operator +(Megaseconds first, Petaseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Exaseconds(Megaseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Megaseconds operator +(Megaseconds first, Exaseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettaseconds(Megaseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Megaseconds operator +(Megaseconds first, Zettaseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottaseconds(Megaseconds value)
				{
					return (value.value)*1E-18;
				}

				public static Megaseconds operator +(Megaseconds first, Yottaseconds second)
				{
					return new Megaseconds(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigaseconds : IValueWithUnit, IEquatable< Gigaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigaseconds Zero = new Gigaseconds(0);
			public static readonly Gigaseconds One = new Gigaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.gigasecond; } }

			public Gigaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Gs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1000000000);
				}
				
			public bool Equals(Gigaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigaseconds(double value)
			{
				return new Gigaseconds(value);
			}

			public static Gigaseconds operator *(Gigaseconds value, double times)
			{
				return new Gigaseconds(value.value * times);
			}

			public static Gigaseconds operator *(double times, Gigaseconds value)
			{
				return new Gigaseconds(value.value * times);
			}

			public static Gigaseconds operator +(Gigaseconds first, Gigaseconds second)
			{
				return new Gigaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Gigaseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Seconds second)
				{
					return new Gigaseconds(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctoseconds(Gigaseconds value)
				{
					return (value.value)*1E+33;
				}

				public static Gigaseconds operator +(Gigaseconds first, Yoctoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptoseconds(Gigaseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Gigaseconds operator +(Gigaseconds first, Zeptoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attoseconds(Gigaseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Gigaseconds operator +(Gigaseconds first, Attoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtoseconds(Gigaseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Gigaseconds operator +(Gigaseconds first, Femtoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picoseconds(Gigaseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Gigaseconds operator +(Gigaseconds first, Picoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanoseconds(Gigaseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Gigaseconds operator +(Gigaseconds first, Nanoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Microseconds(Gigaseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Gigaseconds operator +(Gigaseconds first, Microseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Milliseconds(Gigaseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Milliseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centiseconds(Gigaseconds value)
				{
					return (value.value)*100000000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Centiseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-11);
				}
								public static implicit operator Deciseconds(Gigaseconds value)
				{
					return (value.value)*10000000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Deciseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decaseconds(Gigaseconds value)
				{
					return (value.value)*100000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Decaseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectoseconds(Gigaseconds value)
				{
					return (value.value)*10000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Hectoseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kiloseconds(Gigaseconds value)
				{
					return (value.value)*1000000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Kiloseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megaseconds(Gigaseconds value)
				{
					return (value.value)*1000;
				}

				public static Gigaseconds operator +(Gigaseconds first, Megaseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Teraseconds(Gigaseconds value)
				{
					return (value.value)*0.001;
				}

				public static Gigaseconds operator +(Gigaseconds first, Teraseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Petaseconds(Gigaseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Gigaseconds operator +(Gigaseconds first, Petaseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Exaseconds(Gigaseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Gigaseconds operator +(Gigaseconds first, Exaseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettaseconds(Gigaseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Gigaseconds operator +(Gigaseconds first, Zettaseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottaseconds(Gigaseconds value)
				{
					return (value.value)*1E-15;
				}

				public static Gigaseconds operator +(Gigaseconds first, Yottaseconds second)
				{
					return new Gigaseconds(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Teraseconds : IValueWithUnit, IEquatable< Teraseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Teraseconds Zero = new Teraseconds(0);
			public static readonly Teraseconds One = new Teraseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.terasecond; } }

			public Teraseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ts", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1000000000000);
				}
				
			public bool Equals(Teraseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Teraseconds(double value)
			{
				return new Teraseconds(value);
			}

			public static Teraseconds operator *(Teraseconds value, double times)
			{
				return new Teraseconds(value.value * times);
			}

			public static Teraseconds operator *(double times, Teraseconds value)
			{
				return new Teraseconds(value.value * times);
			}

			public static Teraseconds operator +(Teraseconds first, Teraseconds second)
			{
				return new Teraseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Teraseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Teraseconds operator +(Teraseconds first, Seconds second)
				{
					return new Teraseconds(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctoseconds(Teraseconds value)
				{
					return (value.value)*1E+36;
				}

				public static Teraseconds operator +(Teraseconds first, Yoctoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptoseconds(Teraseconds value)
				{
					return (value.value)*1E+33;
				}

				public static Teraseconds operator +(Teraseconds first, Zeptoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attoseconds(Teraseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Teraseconds operator +(Teraseconds first, Attoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtoseconds(Teraseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Teraseconds operator +(Teraseconds first, Femtoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picoseconds(Teraseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Teraseconds operator +(Teraseconds first, Picoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanoseconds(Teraseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Teraseconds operator +(Teraseconds first, Nanoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Microseconds(Teraseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Teraseconds operator +(Teraseconds first, Microseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Milliseconds(Teraseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Teraseconds operator +(Teraseconds first, Milliseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centiseconds(Teraseconds value)
				{
					return (value.value)*100000000000000;
				}

				public static Teraseconds operator +(Teraseconds first, Centiseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-14);
				}
								public static implicit operator Deciseconds(Teraseconds value)
				{
					return (value.value)*10000000000000;
				}

				public static Teraseconds operator +(Teraseconds first, Deciseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decaseconds(Teraseconds value)
				{
					return (value.value)*100000000000;
				}

				public static Teraseconds operator +(Teraseconds first, Decaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectoseconds(Teraseconds value)
				{
					return (value.value)*10000000000;
				}

				public static Teraseconds operator +(Teraseconds first, Hectoseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kiloseconds(Teraseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Teraseconds operator +(Teraseconds first, Kiloseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megaseconds(Teraseconds value)
				{
					return (value.value)*1000000;
				}

				public static Teraseconds operator +(Teraseconds first, Megaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigaseconds(Teraseconds value)
				{
					return (value.value)*1000;
				}

				public static Teraseconds operator +(Teraseconds first, Gigaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Petaseconds(Teraseconds value)
				{
					return (value.value)*0.001;
				}

				public static Teraseconds operator +(Teraseconds first, Petaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Exaseconds(Teraseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Teraseconds operator +(Teraseconds first, Exaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettaseconds(Teraseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Teraseconds operator +(Teraseconds first, Zettaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottaseconds(Teraseconds value)
				{
					return (value.value)*1E-12;
				}

				public static Teraseconds operator +(Teraseconds first, Yottaseconds second)
				{
					return new Teraseconds(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petaseconds : IValueWithUnit, IEquatable< Petaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Petaseconds Zero = new Petaseconds(0);
			public static readonly Petaseconds One = new Petaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.petasecond; } }

			public Petaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ps", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E+15);
				}
				
			public bool Equals(Petaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petaseconds(double value)
			{
				return new Petaseconds(value);
			}

			public static Petaseconds operator *(Petaseconds value, double times)
			{
				return new Petaseconds(value.value * times);
			}

			public static Petaseconds operator *(double times, Petaseconds value)
			{
				return new Petaseconds(value.value * times);
			}

			public static Petaseconds operator +(Petaseconds first, Petaseconds second)
			{
				return new Petaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Petaseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Petaseconds operator +(Petaseconds first, Seconds second)
				{
					return new Petaseconds(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctoseconds(Petaseconds value)
				{
					return (value.value)*1E+39;
				}

				public static Petaseconds operator +(Petaseconds first, Yoctoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptoseconds(Petaseconds value)
				{
					return (value.value)*1E+36;
				}

				public static Petaseconds operator +(Petaseconds first, Zeptoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attoseconds(Petaseconds value)
				{
					return (value.value)*1E+33;
				}

				public static Petaseconds operator +(Petaseconds first, Attoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtoseconds(Petaseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Petaseconds operator +(Petaseconds first, Femtoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picoseconds(Petaseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Petaseconds operator +(Petaseconds first, Picoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanoseconds(Petaseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Petaseconds operator +(Petaseconds first, Nanoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Microseconds(Petaseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Petaseconds operator +(Petaseconds first, Microseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Milliseconds(Petaseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Petaseconds operator +(Petaseconds first, Milliseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centiseconds(Petaseconds value)
				{
					return (value.value)*1E+17;
				}

				public static Petaseconds operator +(Petaseconds first, Centiseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-17);
				}
								public static implicit operator Deciseconds(Petaseconds value)
				{
					return (value.value)*1E+16;
				}

				public static Petaseconds operator +(Petaseconds first, Deciseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decaseconds(Petaseconds value)
				{
					return (value.value)*100000000000000;
				}

				public static Petaseconds operator +(Petaseconds first, Decaseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectoseconds(Petaseconds value)
				{
					return (value.value)*10000000000000;
				}

				public static Petaseconds operator +(Petaseconds first, Hectoseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kiloseconds(Petaseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Petaseconds operator +(Petaseconds first, Kiloseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megaseconds(Petaseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Petaseconds operator +(Petaseconds first, Megaseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigaseconds(Petaseconds value)
				{
					return (value.value)*1000000;
				}

				public static Petaseconds operator +(Petaseconds first, Gigaseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Teraseconds(Petaseconds value)
				{
					return (value.value)*1000;
				}

				public static Petaseconds operator +(Petaseconds first, Teraseconds second)
				{
					return new Petaseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Exaseconds(Petaseconds value)
				{
					return (value.value)*0.001;
				}

				public static Petaseconds operator +(Petaseconds first, Exaseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Zettaseconds(Petaseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Petaseconds operator +(Petaseconds first, Zettaseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottaseconds(Petaseconds value)
				{
					return (value.value)*1E-09;
				}

				public static Petaseconds operator +(Petaseconds first, Yottaseconds second)
				{
					return new Petaseconds(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Exaseconds : IValueWithUnit, IEquatable< Exaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Exaseconds Zero = new Exaseconds(0);
			public static readonly Exaseconds One = new Exaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.exasecond; } }

			public Exaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Es", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E+18);
				}
				
			public bool Equals(Exaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Exaseconds(double value)
			{
				return new Exaseconds(value);
			}

			public static Exaseconds operator *(Exaseconds value, double times)
			{
				return new Exaseconds(value.value * times);
			}

			public static Exaseconds operator *(double times, Exaseconds value)
			{
				return new Exaseconds(value.value * times);
			}

			public static Exaseconds operator +(Exaseconds first, Exaseconds second)
			{
				return new Exaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Exaseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Exaseconds operator +(Exaseconds first, Seconds second)
				{
					return new Exaseconds(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctoseconds(Exaseconds value)
				{
					return (value.value)*1E+42;
				}

				public static Exaseconds operator +(Exaseconds first, Yoctoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptoseconds(Exaseconds value)
				{
					return (value.value)*1E+39;
				}

				public static Exaseconds operator +(Exaseconds first, Zeptoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attoseconds(Exaseconds value)
				{
					return (value.value)*1E+36;
				}

				public static Exaseconds operator +(Exaseconds first, Attoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtoseconds(Exaseconds value)
				{
					return (value.value)*1E+33;
				}

				public static Exaseconds operator +(Exaseconds first, Femtoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picoseconds(Exaseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Exaseconds operator +(Exaseconds first, Picoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanoseconds(Exaseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Exaseconds operator +(Exaseconds first, Nanoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Microseconds(Exaseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Exaseconds operator +(Exaseconds first, Microseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Milliseconds(Exaseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Exaseconds operator +(Exaseconds first, Milliseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centiseconds(Exaseconds value)
				{
					return (value.value)*1E+20;
				}

				public static Exaseconds operator +(Exaseconds first, Centiseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-20);
				}
								public static implicit operator Deciseconds(Exaseconds value)
				{
					return (value.value)*1E+19;
				}

				public static Exaseconds operator +(Exaseconds first, Deciseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decaseconds(Exaseconds value)
				{
					return (value.value)*1E+17;
				}

				public static Exaseconds operator +(Exaseconds first, Decaseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectoseconds(Exaseconds value)
				{
					return (value.value)*1E+16;
				}

				public static Exaseconds operator +(Exaseconds first, Hectoseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kiloseconds(Exaseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Exaseconds operator +(Exaseconds first, Kiloseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megaseconds(Exaseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Exaseconds operator +(Exaseconds first, Megaseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigaseconds(Exaseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Exaseconds operator +(Exaseconds first, Gigaseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Teraseconds(Exaseconds value)
				{
					return (value.value)*1000000;
				}

				public static Exaseconds operator +(Exaseconds first, Teraseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petaseconds(Exaseconds value)
				{
					return (value.value)*1000;
				}

				public static Exaseconds operator +(Exaseconds first, Petaseconds second)
				{
					return new Exaseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettaseconds(Exaseconds value)
				{
					return (value.value)*0.001;
				}

				public static Exaseconds operator +(Exaseconds first, Zettaseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1000);
				}
								public static implicit operator Yottaseconds(Exaseconds value)
				{
					return (value.value)*1E-06;
				}

				public static Exaseconds operator +(Exaseconds first, Yottaseconds second)
				{
					return new Exaseconds(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettaseconds : IValueWithUnit, IEquatable< Zettaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettaseconds Zero = new Zettaseconds(0);
			public static readonly Zettaseconds One = new Zettaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.zettasecond; } }

			public Zettaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Zs", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E+21);
				}
				
			public bool Equals(Zettaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettaseconds(double value)
			{
				return new Zettaseconds(value);
			}

			public static Zettaseconds operator *(Zettaseconds value, double times)
			{
				return new Zettaseconds(value.value * times);
			}

			public static Zettaseconds operator *(double times, Zettaseconds value)
			{
				return new Zettaseconds(value.value * times);
			}

			public static Zettaseconds operator +(Zettaseconds first, Zettaseconds second)
			{
				return new Zettaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Zettaseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Zettaseconds operator +(Zettaseconds first, Seconds second)
				{
					return new Zettaseconds(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctoseconds(Zettaseconds value)
				{
					return (value.value)*1E+45;
				}

				public static Zettaseconds operator +(Zettaseconds first, Yoctoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptoseconds(Zettaseconds value)
				{
					return (value.value)*1E+42;
				}

				public static Zettaseconds operator +(Zettaseconds first, Zeptoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attoseconds(Zettaseconds value)
				{
					return (value.value)*1E+39;
				}

				public static Zettaseconds operator +(Zettaseconds first, Attoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtoseconds(Zettaseconds value)
				{
					return (value.value)*1E+36;
				}

				public static Zettaseconds operator +(Zettaseconds first, Femtoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picoseconds(Zettaseconds value)
				{
					return (value.value)*1E+33;
				}

				public static Zettaseconds operator +(Zettaseconds first, Picoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanoseconds(Zettaseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Zettaseconds operator +(Zettaseconds first, Nanoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Microseconds(Zettaseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Zettaseconds operator +(Zettaseconds first, Microseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Milliseconds(Zettaseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Zettaseconds operator +(Zettaseconds first, Milliseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centiseconds(Zettaseconds value)
				{
					return (value.value)*1E+23;
				}

				public static Zettaseconds operator +(Zettaseconds first, Centiseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-23);
				}
								public static implicit operator Deciseconds(Zettaseconds value)
				{
					return (value.value)*1E+22;
				}

				public static Zettaseconds operator +(Zettaseconds first, Deciseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decaseconds(Zettaseconds value)
				{
					return (value.value)*1E+20;
				}

				public static Zettaseconds operator +(Zettaseconds first, Decaseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectoseconds(Zettaseconds value)
				{
					return (value.value)*1E+19;
				}

				public static Zettaseconds operator +(Zettaseconds first, Hectoseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kiloseconds(Zettaseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Zettaseconds operator +(Zettaseconds first, Kiloseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megaseconds(Zettaseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Zettaseconds operator +(Zettaseconds first, Megaseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigaseconds(Zettaseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettaseconds operator +(Zettaseconds first, Gigaseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Teraseconds(Zettaseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Zettaseconds operator +(Zettaseconds first, Teraseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petaseconds(Zettaseconds value)
				{
					return (value.value)*1000000;
				}

				public static Zettaseconds operator +(Zettaseconds first, Petaseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Exaseconds(Zettaseconds value)
				{
					return (value.value)*1000;
				}

				public static Zettaseconds operator +(Zettaseconds first, Exaseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottaseconds(Zettaseconds value)
				{
					return (value.value)*0.001;
				}

				public static Zettaseconds operator +(Zettaseconds first, Yottaseconds second)
				{
					return new Zettaseconds(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottaseconds : IValueWithUnit, IEquatable< Yottaseconds >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottaseconds Zero = new Yottaseconds(0);
			public static readonly Yottaseconds One = new Yottaseconds(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Time.Units.yottasecond; } }

			public Yottaseconds(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ys", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Seconds ToBaseUnit()
				{
					return new Seconds((this.value)*1E+24);
				}
				
			public bool Equals(Yottaseconds other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottaseconds(double value)
			{
				return new Yottaseconds(value);
			}

			public static Yottaseconds operator *(Yottaseconds value, double times)
			{
				return new Yottaseconds(value.value * times);
			}

			public static Yottaseconds operator *(double times, Yottaseconds value)
			{
				return new Yottaseconds(value.value * times);
			}

			public static Yottaseconds operator +(Yottaseconds first, Yottaseconds second)
			{
				return new Yottaseconds(first.value * second.value);
			}

							public static implicit operator Seconds(Yottaseconds value)
				{
					return (value.value)*1E+24;
				}

				public static Yottaseconds operator +(Yottaseconds first, Seconds second)
				{
					return new Yottaseconds(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctoseconds(Yottaseconds value)
				{
					return (value.value)*1E+48;
				}

				public static Yottaseconds operator +(Yottaseconds first, Yoctoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptoseconds(Yottaseconds value)
				{
					return (value.value)*1E+45;
				}

				public static Yottaseconds operator +(Yottaseconds first, Zeptoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attoseconds(Yottaseconds value)
				{
					return (value.value)*1E+42;
				}

				public static Yottaseconds operator +(Yottaseconds first, Attoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtoseconds(Yottaseconds value)
				{
					return (value.value)*1E+39;
				}

				public static Yottaseconds operator +(Yottaseconds first, Femtoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picoseconds(Yottaseconds value)
				{
					return (value.value)*1E+36;
				}

				public static Yottaseconds operator +(Yottaseconds first, Picoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanoseconds(Yottaseconds value)
				{
					return (value.value)*1E+33;
				}

				public static Yottaseconds operator +(Yottaseconds first, Nanoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-33);
				}
								public static implicit operator Microseconds(Yottaseconds value)
				{
					return (value.value)*1E+30;
				}

				public static Yottaseconds operator +(Yottaseconds first, Microseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-30);
				}
								public static implicit operator Milliseconds(Yottaseconds value)
				{
					return (value.value)*1E+27;
				}

				public static Yottaseconds operator +(Yottaseconds first, Milliseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centiseconds(Yottaseconds value)
				{
					return (value.value)*1E+26;
				}

				public static Yottaseconds operator +(Yottaseconds first, Centiseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-26);
				}
								public static implicit operator Deciseconds(Yottaseconds value)
				{
					return (value.value)*1E+25;
				}

				public static Yottaseconds operator +(Yottaseconds first, Deciseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decaseconds(Yottaseconds value)
				{
					return (value.value)*1E+23;
				}

				public static Yottaseconds operator +(Yottaseconds first, Decaseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectoseconds(Yottaseconds value)
				{
					return (value.value)*1E+22;
				}

				public static Yottaseconds operator +(Yottaseconds first, Hectoseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kiloseconds(Yottaseconds value)
				{
					return (value.value)*1E+21;
				}

				public static Yottaseconds operator +(Yottaseconds first, Kiloseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megaseconds(Yottaseconds value)
				{
					return (value.value)*1E+18;
				}

				public static Yottaseconds operator +(Yottaseconds first, Megaseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigaseconds(Yottaseconds value)
				{
					return (value.value)*1E+15;
				}

				public static Yottaseconds operator +(Yottaseconds first, Gigaseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-15);
				}
								public static implicit operator Teraseconds(Yottaseconds value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottaseconds operator +(Yottaseconds first, Teraseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petaseconds(Yottaseconds value)
				{
					return (value.value)*1000000000;
				}

				public static Yottaseconds operator +(Yottaseconds first, Petaseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-09);
				}
								public static implicit operator Exaseconds(Yottaseconds value)
				{
					return (value.value)*1000000;
				}

				public static Yottaseconds operator +(Yottaseconds first, Exaseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettaseconds(Yottaseconds value)
				{
					return (value.value)*1000;
				}

				public static Yottaseconds operator +(Yottaseconds first, Zettaseconds second)
				{
					return new Yottaseconds(first.value + (second.value)*0.001);
				}
						}
		}
namespace Multiples
{

		public struct Grams : IValueWithUnit, IEquatable< Grams >, IEquatable<IValueWithUnit>
		{
			public static readonly Grams Zero = new Grams(0);
			public static readonly Grams One = new Grams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.gram; } }

			public Grams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} g", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)/1000);
				}
				
			public bool Equals(Grams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Grams(double value)
			{
				return new Grams(value);
			}

			public static Grams operator *(Grams value, double times)
			{
				return new Grams(value.value * times);
			}

			public static Grams operator *(double times, Grams value)
			{
				return new Grams(value.value * times);
			}

			public static Grams operator +(Grams first, Grams second)
			{
				return new Grams(first.value * second.value);
			}

							public static implicit operator Yoctograms(Grams value)
				{
					return (value.value)/1E-24;
				}

				public static Grams operator +(Grams first, Yoctograms second)
				{
					return new Grams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptograms(Grams value)
				{
					return (value.value)/1E-21;
				}

				public static Grams operator +(Grams first, Zeptograms second)
				{
					return new Grams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attograms(Grams value)
				{
					return (value.value)/1E-18;
				}

				public static Grams operator +(Grams first, Attograms second)
				{
					return new Grams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtograms(Grams value)
				{
					return (value.value)/1E-15;
				}

				public static Grams operator +(Grams first, Femtograms second)
				{
					return new Grams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picograms(Grams value)
				{
					return (value.value)/1E-12;
				}

				public static Grams operator +(Grams first, Picograms second)
				{
					return new Grams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanograms(Grams value)
				{
					return (value.value)/1E-09;
				}

				public static Grams operator +(Grams first, Nanograms second)
				{
					return new Grams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Micrograms(Grams value)
				{
					return (value.value)/1E-06;
				}

				public static Grams operator +(Grams first, Micrograms second)
				{
					return new Grams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Milligrams(Grams value)
				{
					return (value.value)/0.001;
				}

				public static Grams operator +(Grams first, Milligrams second)
				{
					return new Grams(first.value + (second.value)*0.001);
				}
								public static implicit operator Centigrams(Grams value)
				{
					return (value.value)/0.01;
				}

				public static Grams operator +(Grams first, Centigrams second)
				{
					return new Grams(first.value + (second.value)*0.01);
				}
								public static implicit operator Decigrams(Grams value)
				{
					return (value.value)/0.1;
				}

				public static Grams operator +(Grams first, Decigrams second)
				{
					return new Grams(first.value + (second.value)*0.1);
				}
								public static implicit operator Decagrams(Grams value)
				{
					return (value.value)/10;
				}

				public static Grams operator +(Grams first, Decagrams second)
				{
					return new Grams(first.value + (second.value)*10);
				}
								public static implicit operator Hectograms(Grams value)
				{
					return (value.value)/100;
				}

				public static Grams operator +(Grams first, Hectograms second)
				{
					return new Grams(first.value + (second.value)*100);
				}
								public static implicit operator Kilograms(Grams value)
				{
					return (value.value)/1000;
				}

				public static Grams operator +(Grams first, Kilograms second)
				{
					return new Grams(first.value + (second.value)*1000);
				}
								public static implicit operator Megagrams(Grams value)
				{
					return (value.value)/1000000;
				}

				public static Grams operator +(Grams first, Megagrams second)
				{
					return new Grams(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigagrams(Grams value)
				{
					return (value.value)/1000000000;
				}

				public static Grams operator +(Grams first, Gigagrams second)
				{
					return new Grams(first.value + (second.value)*1000000000);
				}
								public static implicit operator Teragrams(Grams value)
				{
					return (value.value)/1000000000000;
				}

				public static Grams operator +(Grams first, Teragrams second)
				{
					return new Grams(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petagrams(Grams value)
				{
					return (value.value)/1E+15;
				}

				public static Grams operator +(Grams first, Petagrams second)
				{
					return new Grams(first.value + (second.value)*1E+15);
				}
								public static implicit operator Exagrams(Grams value)
				{
					return (value.value)/1E+18;
				}

				public static Grams operator +(Grams first, Exagrams second)
				{
					return new Grams(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettagrams(Grams value)
				{
					return (value.value)/1E+21;
				}

				public static Grams operator +(Grams first, Zettagrams second)
				{
					return new Grams(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottagrams(Grams value)
				{
					return (value.value)/1E+24;
				}

				public static Grams operator +(Grams first, Yottagrams second)
				{
					return new Grams(first.value + (second.value)*1E+24);
				}
						}
		}
namespace Multiples
{

		public struct Yoctograms : IValueWithUnit, IEquatable< Yoctograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctograms Zero = new Yoctograms(0);
			public static readonly Yoctograms One = new Yoctograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.yoctogram; } }

			public Yoctograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} yg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-27);
				}
				
			public bool Equals(Yoctograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctograms(double value)
			{
				return new Yoctograms(value);
			}

			public static Yoctograms operator *(Yoctograms value, double times)
			{
				return new Yoctograms(value.value * times);
			}

			public static Yoctograms operator *(double times, Yoctograms value)
			{
				return new Yoctograms(value.value * times);
			}

			public static Yoctograms operator +(Yoctograms first, Yoctograms second)
			{
				return new Yoctograms(first.value * second.value);
			}

							public static implicit operator Grams(Yoctograms value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctograms operator +(Yoctograms first, Grams second)
				{
					return new Yoctograms(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptograms(Yoctograms value)
				{
					return (value.value)*0.001;
				}

				public static Yoctograms operator +(Yoctograms first, Zeptograms second)
				{
					return new Yoctograms(first.value + (second.value)*1000);
				}
								public static implicit operator Attograms(Yoctograms value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctograms operator +(Yoctograms first, Attograms second)
				{
					return new Yoctograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtograms(Yoctograms value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctograms operator +(Yoctograms first, Femtograms second)
				{
					return new Yoctograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picograms(Yoctograms value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctograms operator +(Yoctograms first, Picograms second)
				{
					return new Yoctograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanograms(Yoctograms value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctograms operator +(Yoctograms first, Nanograms second)
				{
					return new Yoctograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Micrograms(Yoctograms value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctograms operator +(Yoctograms first, Micrograms second)
				{
					return new Yoctograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Milligrams(Yoctograms value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctograms operator +(Yoctograms first, Milligrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centigrams(Yoctograms value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctograms operator +(Yoctograms first, Centigrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+22);
				}
								public static implicit operator Decigrams(Yoctograms value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctograms operator +(Yoctograms first, Decigrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decagrams(Yoctograms value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctograms operator +(Yoctograms first, Decagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectograms(Yoctograms value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctograms operator +(Yoctograms first, Hectograms second)
				{
					return new Yoctograms(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kilograms(Yoctograms value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctograms operator +(Yoctograms first, Kilograms second)
				{
					return new Yoctograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megagrams(Yoctograms value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctograms operator +(Yoctograms first, Megagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigagrams(Yoctograms value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctograms operator +(Yoctograms first, Gigagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+33);
				}
								public static implicit operator Teragrams(Yoctograms value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctograms operator +(Yoctograms first, Teragrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petagrams(Yoctograms value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctograms operator +(Yoctograms first, Petagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+39);
				}
								public static implicit operator Exagrams(Yoctograms value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctograms operator +(Yoctograms first, Exagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettagrams(Yoctograms value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctograms operator +(Yoctograms first, Zettagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottagrams(Yoctograms value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctograms operator +(Yoctograms first, Yottagrams second)
				{
					return new Yoctograms(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptograms : IValueWithUnit, IEquatable< Zeptograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptograms Zero = new Zeptograms(0);
			public static readonly Zeptograms One = new Zeptograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.zeptogram; } }

			public Zeptograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-24);
				}
				
			public bool Equals(Zeptograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptograms(double value)
			{
				return new Zeptograms(value);
			}

			public static Zeptograms operator *(Zeptograms value, double times)
			{
				return new Zeptograms(value.value * times);
			}

			public static Zeptograms operator *(double times, Zeptograms value)
			{
				return new Zeptograms(value.value * times);
			}

			public static Zeptograms operator +(Zeptograms first, Zeptograms second)
			{
				return new Zeptograms(first.value * second.value);
			}

							public static implicit operator Grams(Zeptograms value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptograms operator +(Zeptograms first, Grams second)
				{
					return new Zeptograms(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctograms(Zeptograms value)
				{
					return (value.value)*1000;
				}

				public static Zeptograms operator +(Zeptograms first, Yoctograms second)
				{
					return new Zeptograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Attograms(Zeptograms value)
				{
					return (value.value)*0.001;
				}

				public static Zeptograms operator +(Zeptograms first, Attograms second)
				{
					return new Zeptograms(first.value + (second.value)*1000);
				}
								public static implicit operator Femtograms(Zeptograms value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptograms operator +(Zeptograms first, Femtograms second)
				{
					return new Zeptograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Picograms(Zeptograms value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptograms operator +(Zeptograms first, Picograms second)
				{
					return new Zeptograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanograms(Zeptograms value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptograms operator +(Zeptograms first, Nanograms second)
				{
					return new Zeptograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Micrograms(Zeptograms value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptograms operator +(Zeptograms first, Micrograms second)
				{
					return new Zeptograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Milligrams(Zeptograms value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptograms operator +(Zeptograms first, Milligrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centigrams(Zeptograms value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptograms operator +(Zeptograms first, Centigrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+19);
				}
								public static implicit operator Decigrams(Zeptograms value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptograms operator +(Zeptograms first, Decigrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decagrams(Zeptograms value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptograms operator +(Zeptograms first, Decagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectograms(Zeptograms value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptograms operator +(Zeptograms first, Hectograms second)
				{
					return new Zeptograms(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kilograms(Zeptograms value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptograms operator +(Zeptograms first, Kilograms second)
				{
					return new Zeptograms(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megagrams(Zeptograms value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptograms operator +(Zeptograms first, Megagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigagrams(Zeptograms value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptograms operator +(Zeptograms first, Gigagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+30);
				}
								public static implicit operator Teragrams(Zeptograms value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptograms operator +(Zeptograms first, Teragrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petagrams(Zeptograms value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptograms operator +(Zeptograms first, Petagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+36);
				}
								public static implicit operator Exagrams(Zeptograms value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptograms operator +(Zeptograms first, Exagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettagrams(Zeptograms value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptograms operator +(Zeptograms first, Zettagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottagrams(Zeptograms value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptograms operator +(Zeptograms first, Yottagrams second)
				{
					return new Zeptograms(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attograms : IValueWithUnit, IEquatable< Attograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Attograms Zero = new Attograms(0);
			public static readonly Attograms One = new Attograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.attogram; } }

			public Attograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ag", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-21);
				}
				
			public bool Equals(Attograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attograms(double value)
			{
				return new Attograms(value);
			}

			public static Attograms operator *(Attograms value, double times)
			{
				return new Attograms(value.value * times);
			}

			public static Attograms operator *(double times, Attograms value)
			{
				return new Attograms(value.value * times);
			}

			public static Attograms operator +(Attograms first, Attograms second)
			{
				return new Attograms(first.value * second.value);
			}

							public static implicit operator Grams(Attograms value)
				{
					return (value.value)*1E-18;
				}

				public static Attograms operator +(Attograms first, Grams second)
				{
					return new Attograms(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctograms(Attograms value)
				{
					return (value.value)*1000000;
				}

				public static Attograms operator +(Attograms first, Yoctograms second)
				{
					return new Attograms(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptograms(Attograms value)
				{
					return (value.value)*1000;
				}

				public static Attograms operator +(Attograms first, Zeptograms second)
				{
					return new Attograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtograms(Attograms value)
				{
					return (value.value)*0.001;
				}

				public static Attograms operator +(Attograms first, Femtograms second)
				{
					return new Attograms(first.value + (second.value)*1000);
				}
								public static implicit operator Picograms(Attograms value)
				{
					return (value.value)*1E-06;
				}

				public static Attograms operator +(Attograms first, Picograms second)
				{
					return new Attograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanograms(Attograms value)
				{
					return (value.value)*1E-09;
				}

				public static Attograms operator +(Attograms first, Nanograms second)
				{
					return new Attograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Micrograms(Attograms value)
				{
					return (value.value)*1E-12;
				}

				public static Attograms operator +(Attograms first, Micrograms second)
				{
					return new Attograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Milligrams(Attograms value)
				{
					return (value.value)*1E-15;
				}

				public static Attograms operator +(Attograms first, Milligrams second)
				{
					return new Attograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centigrams(Attograms value)
				{
					return (value.value)*1E-16;
				}

				public static Attograms operator +(Attograms first, Centigrams second)
				{
					return new Attograms(first.value + (second.value)*1E+16);
				}
								public static implicit operator Decigrams(Attograms value)
				{
					return (value.value)*1E-17;
				}

				public static Attograms operator +(Attograms first, Decigrams second)
				{
					return new Attograms(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decagrams(Attograms value)
				{
					return (value.value)*1E-19;
				}

				public static Attograms operator +(Attograms first, Decagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectograms(Attograms value)
				{
					return (value.value)*1E-20;
				}

				public static Attograms operator +(Attograms first, Hectograms second)
				{
					return new Attograms(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kilograms(Attograms value)
				{
					return (value.value)*1E-21;
				}

				public static Attograms operator +(Attograms first, Kilograms second)
				{
					return new Attograms(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megagrams(Attograms value)
				{
					return (value.value)*1E-24;
				}

				public static Attograms operator +(Attograms first, Megagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigagrams(Attograms value)
				{
					return (value.value)*1E-27;
				}

				public static Attograms operator +(Attograms first, Gigagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Teragrams(Attograms value)
				{
					return (value.value)*1E-30;
				}

				public static Attograms operator +(Attograms first, Teragrams second)
				{
					return new Attograms(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petagrams(Attograms value)
				{
					return (value.value)*1E-33;
				}

				public static Attograms operator +(Attograms first, Petagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+33);
				}
								public static implicit operator Exagrams(Attograms value)
				{
					return (value.value)*1E-36;
				}

				public static Attograms operator +(Attograms first, Exagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettagrams(Attograms value)
				{
					return (value.value)*1E-39;
				}

				public static Attograms operator +(Attograms first, Zettagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottagrams(Attograms value)
				{
					return (value.value)*1E-42;
				}

				public static Attograms operator +(Attograms first, Yottagrams second)
				{
					return new Attograms(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtograms : IValueWithUnit, IEquatable< Femtograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtograms Zero = new Femtograms(0);
			public static readonly Femtograms One = new Femtograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.femtogram; } }

			public Femtograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-18);
				}
				
			public bool Equals(Femtograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtograms(double value)
			{
				return new Femtograms(value);
			}

			public static Femtograms operator *(Femtograms value, double times)
			{
				return new Femtograms(value.value * times);
			}

			public static Femtograms operator *(double times, Femtograms value)
			{
				return new Femtograms(value.value * times);
			}

			public static Femtograms operator +(Femtograms first, Femtograms second)
			{
				return new Femtograms(first.value * second.value);
			}

							public static implicit operator Grams(Femtograms value)
				{
					return (value.value)*1E-15;
				}

				public static Femtograms operator +(Femtograms first, Grams second)
				{
					return new Femtograms(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctograms(Femtograms value)
				{
					return (value.value)*1000000000;
				}

				public static Femtograms operator +(Femtograms first, Yoctograms second)
				{
					return new Femtograms(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptograms(Femtograms value)
				{
					return (value.value)*1000000;
				}

				public static Femtograms operator +(Femtograms first, Zeptograms second)
				{
					return new Femtograms(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attograms(Femtograms value)
				{
					return (value.value)*1000;
				}

				public static Femtograms operator +(Femtograms first, Attograms second)
				{
					return new Femtograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Picograms(Femtograms value)
				{
					return (value.value)*0.001;
				}

				public static Femtograms operator +(Femtograms first, Picograms second)
				{
					return new Femtograms(first.value + (second.value)*1000);
				}
								public static implicit operator Nanograms(Femtograms value)
				{
					return (value.value)*1E-06;
				}

				public static Femtograms operator +(Femtograms first, Nanograms second)
				{
					return new Femtograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Micrograms(Femtograms value)
				{
					return (value.value)*1E-09;
				}

				public static Femtograms operator +(Femtograms first, Micrograms second)
				{
					return new Femtograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Milligrams(Femtograms value)
				{
					return (value.value)*1E-12;
				}

				public static Femtograms operator +(Femtograms first, Milligrams second)
				{
					return new Femtograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centigrams(Femtograms value)
				{
					return (value.value)*1E-13;
				}

				public static Femtograms operator +(Femtograms first, Centigrams second)
				{
					return new Femtograms(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Decigrams(Femtograms value)
				{
					return (value.value)*1E-14;
				}

				public static Femtograms operator +(Femtograms first, Decigrams second)
				{
					return new Femtograms(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decagrams(Femtograms value)
				{
					return (value.value)*1E-16;
				}

				public static Femtograms operator +(Femtograms first, Decagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectograms(Femtograms value)
				{
					return (value.value)*1E-17;
				}

				public static Femtograms operator +(Femtograms first, Hectograms second)
				{
					return new Femtograms(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kilograms(Femtograms value)
				{
					return (value.value)*1E-18;
				}

				public static Femtograms operator +(Femtograms first, Kilograms second)
				{
					return new Femtograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megagrams(Femtograms value)
				{
					return (value.value)*1E-21;
				}

				public static Femtograms operator +(Femtograms first, Megagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigagrams(Femtograms value)
				{
					return (value.value)*1E-24;
				}

				public static Femtograms operator +(Femtograms first, Gigagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+24);
				}
								public static implicit operator Teragrams(Femtograms value)
				{
					return (value.value)*1E-27;
				}

				public static Femtograms operator +(Femtograms first, Teragrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petagrams(Femtograms value)
				{
					return (value.value)*1E-30;
				}

				public static Femtograms operator +(Femtograms first, Petagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+30);
				}
								public static implicit operator Exagrams(Femtograms value)
				{
					return (value.value)*1E-33;
				}

				public static Femtograms operator +(Femtograms first, Exagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettagrams(Femtograms value)
				{
					return (value.value)*1E-36;
				}

				public static Femtograms operator +(Femtograms first, Zettagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottagrams(Femtograms value)
				{
					return (value.value)*1E-39;
				}

				public static Femtograms operator +(Femtograms first, Yottagrams second)
				{
					return new Femtograms(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picograms : IValueWithUnit, IEquatable< Picograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Picograms Zero = new Picograms(0);
			public static readonly Picograms One = new Picograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.picogram; } }

			public Picograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} pg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-15);
				}
				
			public bool Equals(Picograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picograms(double value)
			{
				return new Picograms(value);
			}

			public static Picograms operator *(Picograms value, double times)
			{
				return new Picograms(value.value * times);
			}

			public static Picograms operator *(double times, Picograms value)
			{
				return new Picograms(value.value * times);
			}

			public static Picograms operator +(Picograms first, Picograms second)
			{
				return new Picograms(first.value * second.value);
			}

							public static implicit operator Grams(Picograms value)
				{
					return (value.value)*1E-12;
				}

				public static Picograms operator +(Picograms first, Grams second)
				{
					return new Picograms(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctograms(Picograms value)
				{
					return (value.value)*1000000000000;
				}

				public static Picograms operator +(Picograms first, Yoctograms second)
				{
					return new Picograms(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptograms(Picograms value)
				{
					return (value.value)*1000000000;
				}

				public static Picograms operator +(Picograms first, Zeptograms second)
				{
					return new Picograms(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attograms(Picograms value)
				{
					return (value.value)*1000000;
				}

				public static Picograms operator +(Picograms first, Attograms second)
				{
					return new Picograms(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtograms(Picograms value)
				{
					return (value.value)*1000;
				}

				public static Picograms operator +(Picograms first, Femtograms second)
				{
					return new Picograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanograms(Picograms value)
				{
					return (value.value)*0.001;
				}

				public static Picograms operator +(Picograms first, Nanograms second)
				{
					return new Picograms(first.value + (second.value)*1000);
				}
								public static implicit operator Micrograms(Picograms value)
				{
					return (value.value)*1E-06;
				}

				public static Picograms operator +(Picograms first, Micrograms second)
				{
					return new Picograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Milligrams(Picograms value)
				{
					return (value.value)*1E-09;
				}

				public static Picograms operator +(Picograms first, Milligrams second)
				{
					return new Picograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centigrams(Picograms value)
				{
					return (value.value)*1E-10;
				}

				public static Picograms operator +(Picograms first, Centigrams second)
				{
					return new Picograms(first.value + (second.value)*10000000000);
				}
								public static implicit operator Decigrams(Picograms value)
				{
					return (value.value)*1E-11;
				}

				public static Picograms operator +(Picograms first, Decigrams second)
				{
					return new Picograms(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decagrams(Picograms value)
				{
					return (value.value)*1E-13;
				}

				public static Picograms operator +(Picograms first, Decagrams second)
				{
					return new Picograms(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectograms(Picograms value)
				{
					return (value.value)*1E-14;
				}

				public static Picograms operator +(Picograms first, Hectograms second)
				{
					return new Picograms(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kilograms(Picograms value)
				{
					return (value.value)*1E-15;
				}

				public static Picograms operator +(Picograms first, Kilograms second)
				{
					return new Picograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megagrams(Picograms value)
				{
					return (value.value)*1E-18;
				}

				public static Picograms operator +(Picograms first, Megagrams second)
				{
					return new Picograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigagrams(Picograms value)
				{
					return (value.value)*1E-21;
				}

				public static Picograms operator +(Picograms first, Gigagrams second)
				{
					return new Picograms(first.value + (second.value)*1E+21);
				}
								public static implicit operator Teragrams(Picograms value)
				{
					return (value.value)*1E-24;
				}

				public static Picograms operator +(Picograms first, Teragrams second)
				{
					return new Picograms(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petagrams(Picograms value)
				{
					return (value.value)*1E-27;
				}

				public static Picograms operator +(Picograms first, Petagrams second)
				{
					return new Picograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Exagrams(Picograms value)
				{
					return (value.value)*1E-30;
				}

				public static Picograms operator +(Picograms first, Exagrams second)
				{
					return new Picograms(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettagrams(Picograms value)
				{
					return (value.value)*1E-33;
				}

				public static Picograms operator +(Picograms first, Zettagrams second)
				{
					return new Picograms(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottagrams(Picograms value)
				{
					return (value.value)*1E-36;
				}

				public static Picograms operator +(Picograms first, Yottagrams second)
				{
					return new Picograms(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanograms : IValueWithUnit, IEquatable< Nanograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanograms Zero = new Nanograms(0);
			public static readonly Nanograms One = new Nanograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.nanogram; } }

			public Nanograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ng", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-12);
				}
				
			public bool Equals(Nanograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanograms(double value)
			{
				return new Nanograms(value);
			}

			public static Nanograms operator *(Nanograms value, double times)
			{
				return new Nanograms(value.value * times);
			}

			public static Nanograms operator *(double times, Nanograms value)
			{
				return new Nanograms(value.value * times);
			}

			public static Nanograms operator +(Nanograms first, Nanograms second)
			{
				return new Nanograms(first.value * second.value);
			}

							public static implicit operator Grams(Nanograms value)
				{
					return (value.value)*1E-09;
				}

				public static Nanograms operator +(Nanograms first, Grams second)
				{
					return new Nanograms(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctograms(Nanograms value)
				{
					return (value.value)*1E+15;
				}

				public static Nanograms operator +(Nanograms first, Yoctograms second)
				{
					return new Nanograms(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptograms(Nanograms value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanograms operator +(Nanograms first, Zeptograms second)
				{
					return new Nanograms(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attograms(Nanograms value)
				{
					return (value.value)*1000000000;
				}

				public static Nanograms operator +(Nanograms first, Attograms second)
				{
					return new Nanograms(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtograms(Nanograms value)
				{
					return (value.value)*1000000;
				}

				public static Nanograms operator +(Nanograms first, Femtograms second)
				{
					return new Nanograms(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picograms(Nanograms value)
				{
					return (value.value)*1000;
				}

				public static Nanograms operator +(Nanograms first, Picograms second)
				{
					return new Nanograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Micrograms(Nanograms value)
				{
					return (value.value)*0.001;
				}

				public static Nanograms operator +(Nanograms first, Micrograms second)
				{
					return new Nanograms(first.value + (second.value)*1000);
				}
								public static implicit operator Milligrams(Nanograms value)
				{
					return (value.value)*1E-06;
				}

				public static Nanograms operator +(Nanograms first, Milligrams second)
				{
					return new Nanograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Centigrams(Nanograms value)
				{
					return (value.value)*1E-07;
				}

				public static Nanograms operator +(Nanograms first, Centigrams second)
				{
					return new Nanograms(first.value + (second.value)*10000000);
				}
								public static implicit operator Decigrams(Nanograms value)
				{
					return (value.value)*1E-08;
				}

				public static Nanograms operator +(Nanograms first, Decigrams second)
				{
					return new Nanograms(first.value + (second.value)*100000000);
				}
								public static implicit operator Decagrams(Nanograms value)
				{
					return (value.value)*1E-10;
				}

				public static Nanograms operator +(Nanograms first, Decagrams second)
				{
					return new Nanograms(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectograms(Nanograms value)
				{
					return (value.value)*1E-11;
				}

				public static Nanograms operator +(Nanograms first, Hectograms second)
				{
					return new Nanograms(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kilograms(Nanograms value)
				{
					return (value.value)*1E-12;
				}

				public static Nanograms operator +(Nanograms first, Kilograms second)
				{
					return new Nanograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megagrams(Nanograms value)
				{
					return (value.value)*1E-15;
				}

				public static Nanograms operator +(Nanograms first, Megagrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigagrams(Nanograms value)
				{
					return (value.value)*1E-18;
				}

				public static Nanograms operator +(Nanograms first, Gigagrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Teragrams(Nanograms value)
				{
					return (value.value)*1E-21;
				}

				public static Nanograms operator +(Nanograms first, Teragrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petagrams(Nanograms value)
				{
					return (value.value)*1E-24;
				}

				public static Nanograms operator +(Nanograms first, Petagrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+24);
				}
								public static implicit operator Exagrams(Nanograms value)
				{
					return (value.value)*1E-27;
				}

				public static Nanograms operator +(Nanograms first, Exagrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettagrams(Nanograms value)
				{
					return (value.value)*1E-30;
				}

				public static Nanograms operator +(Nanograms first, Zettagrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottagrams(Nanograms value)
				{
					return (value.value)*1E-33;
				}

				public static Nanograms operator +(Nanograms first, Yottagrams second)
				{
					return new Nanograms(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Micrograms : IValueWithUnit, IEquatable< Micrograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Micrograms Zero = new Micrograms(0);
			public static readonly Micrograms One = new Micrograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.microgram; } }

			public Micrograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-09);
				}
				
			public bool Equals(Micrograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Micrograms(double value)
			{
				return new Micrograms(value);
			}

			public static Micrograms operator *(Micrograms value, double times)
			{
				return new Micrograms(value.value * times);
			}

			public static Micrograms operator *(double times, Micrograms value)
			{
				return new Micrograms(value.value * times);
			}

			public static Micrograms operator +(Micrograms first, Micrograms second)
			{
				return new Micrograms(first.value * second.value);
			}

							public static implicit operator Grams(Micrograms value)
				{
					return (value.value)*1E-06;
				}

				public static Micrograms operator +(Micrograms first, Grams second)
				{
					return new Micrograms(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctograms(Micrograms value)
				{
					return (value.value)*1E+18;
				}

				public static Micrograms operator +(Micrograms first, Yoctograms second)
				{
					return new Micrograms(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptograms(Micrograms value)
				{
					return (value.value)*1E+15;
				}

				public static Micrograms operator +(Micrograms first, Zeptograms second)
				{
					return new Micrograms(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attograms(Micrograms value)
				{
					return (value.value)*1000000000000;
				}

				public static Micrograms operator +(Micrograms first, Attograms second)
				{
					return new Micrograms(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtograms(Micrograms value)
				{
					return (value.value)*1000000000;
				}

				public static Micrograms operator +(Micrograms first, Femtograms second)
				{
					return new Micrograms(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picograms(Micrograms value)
				{
					return (value.value)*1000000;
				}

				public static Micrograms operator +(Micrograms first, Picograms second)
				{
					return new Micrograms(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanograms(Micrograms value)
				{
					return (value.value)*1000;
				}

				public static Micrograms operator +(Micrograms first, Nanograms second)
				{
					return new Micrograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Milligrams(Micrograms value)
				{
					return (value.value)*0.001;
				}

				public static Micrograms operator +(Micrograms first, Milligrams second)
				{
					return new Micrograms(first.value + (second.value)*1000);
				}
								public static implicit operator Centigrams(Micrograms value)
				{
					return (value.value)*0.0001;
				}

				public static Micrograms operator +(Micrograms first, Centigrams second)
				{
					return new Micrograms(first.value + (second.value)*10000);
				}
								public static implicit operator Decigrams(Micrograms value)
				{
					return (value.value)*1E-05;
				}

				public static Micrograms operator +(Micrograms first, Decigrams second)
				{
					return new Micrograms(first.value + (second.value)*100000);
				}
								public static implicit operator Decagrams(Micrograms value)
				{
					return (value.value)*1E-07;
				}

				public static Micrograms operator +(Micrograms first, Decagrams second)
				{
					return new Micrograms(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectograms(Micrograms value)
				{
					return (value.value)*1E-08;
				}

				public static Micrograms operator +(Micrograms first, Hectograms second)
				{
					return new Micrograms(first.value + (second.value)*100000000);
				}
								public static implicit operator Kilograms(Micrograms value)
				{
					return (value.value)*1E-09;
				}

				public static Micrograms operator +(Micrograms first, Kilograms second)
				{
					return new Micrograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megagrams(Micrograms value)
				{
					return (value.value)*1E-12;
				}

				public static Micrograms operator +(Micrograms first, Megagrams second)
				{
					return new Micrograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigagrams(Micrograms value)
				{
					return (value.value)*1E-15;
				}

				public static Micrograms operator +(Micrograms first, Gigagrams second)
				{
					return new Micrograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Teragrams(Micrograms value)
				{
					return (value.value)*1E-18;
				}

				public static Micrograms operator +(Micrograms first, Teragrams second)
				{
					return new Micrograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petagrams(Micrograms value)
				{
					return (value.value)*1E-21;
				}

				public static Micrograms operator +(Micrograms first, Petagrams second)
				{
					return new Micrograms(first.value + (second.value)*1E+21);
				}
								public static implicit operator Exagrams(Micrograms value)
				{
					return (value.value)*1E-24;
				}

				public static Micrograms operator +(Micrograms first, Exagrams second)
				{
					return new Micrograms(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettagrams(Micrograms value)
				{
					return (value.value)*1E-27;
				}

				public static Micrograms operator +(Micrograms first, Zettagrams second)
				{
					return new Micrograms(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottagrams(Micrograms value)
				{
					return (value.value)*1E-30;
				}

				public static Micrograms operator +(Micrograms first, Yottagrams second)
				{
					return new Micrograms(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Milligrams : IValueWithUnit, IEquatable< Milligrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Milligrams Zero = new Milligrams(0);
			public static readonly Milligrams One = new Milligrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.milligram; } }

			public Milligrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-06);
				}
				
			public bool Equals(Milligrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Milligrams(double value)
			{
				return new Milligrams(value);
			}

			public static Milligrams operator *(Milligrams value, double times)
			{
				return new Milligrams(value.value * times);
			}

			public static Milligrams operator *(double times, Milligrams value)
			{
				return new Milligrams(value.value * times);
			}

			public static Milligrams operator +(Milligrams first, Milligrams second)
			{
				return new Milligrams(first.value * second.value);
			}

							public static implicit operator Grams(Milligrams value)
				{
					return (value.value)*0.001;
				}

				public static Milligrams operator +(Milligrams first, Grams second)
				{
					return new Milligrams(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctograms(Milligrams value)
				{
					return (value.value)*1E+21;
				}

				public static Milligrams operator +(Milligrams first, Yoctograms second)
				{
					return new Milligrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptograms(Milligrams value)
				{
					return (value.value)*1E+18;
				}

				public static Milligrams operator +(Milligrams first, Zeptograms second)
				{
					return new Milligrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attograms(Milligrams value)
				{
					return (value.value)*1E+15;
				}

				public static Milligrams operator +(Milligrams first, Attograms second)
				{
					return new Milligrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtograms(Milligrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Milligrams operator +(Milligrams first, Femtograms second)
				{
					return new Milligrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picograms(Milligrams value)
				{
					return (value.value)*1000000000;
				}

				public static Milligrams operator +(Milligrams first, Picograms second)
				{
					return new Milligrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanograms(Milligrams value)
				{
					return (value.value)*1000000;
				}

				public static Milligrams operator +(Milligrams first, Nanograms second)
				{
					return new Milligrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Micrograms(Milligrams value)
				{
					return (value.value)*1000;
				}

				public static Milligrams operator +(Milligrams first, Micrograms second)
				{
					return new Milligrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Centigrams(Milligrams value)
				{
					return (value.value)*0.1;
				}

				public static Milligrams operator +(Milligrams first, Centigrams second)
				{
					return new Milligrams(first.value + (second.value)*10);
				}
								public static implicit operator Decigrams(Milligrams value)
				{
					return (value.value)*0.01;
				}

				public static Milligrams operator +(Milligrams first, Decigrams second)
				{
					return new Milligrams(first.value + (second.value)*100);
				}
								public static implicit operator Decagrams(Milligrams value)
				{
					return (value.value)*0.0001;
				}

				public static Milligrams operator +(Milligrams first, Decagrams second)
				{
					return new Milligrams(first.value + (second.value)*10000);
				}
								public static implicit operator Hectograms(Milligrams value)
				{
					return (value.value)*1E-05;
				}

				public static Milligrams operator +(Milligrams first, Hectograms second)
				{
					return new Milligrams(first.value + (second.value)*100000);
				}
								public static implicit operator Kilograms(Milligrams value)
				{
					return (value.value)*1E-06;
				}

				public static Milligrams operator +(Milligrams first, Kilograms second)
				{
					return new Milligrams(first.value + (second.value)*1000000);
				}
								public static implicit operator Megagrams(Milligrams value)
				{
					return (value.value)*1E-09;
				}

				public static Milligrams operator +(Milligrams first, Megagrams second)
				{
					return new Milligrams(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigagrams(Milligrams value)
				{
					return (value.value)*1E-12;
				}

				public static Milligrams operator +(Milligrams first, Gigagrams second)
				{
					return new Milligrams(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Teragrams(Milligrams value)
				{
					return (value.value)*1E-15;
				}

				public static Milligrams operator +(Milligrams first, Teragrams second)
				{
					return new Milligrams(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petagrams(Milligrams value)
				{
					return (value.value)*1E-18;
				}

				public static Milligrams operator +(Milligrams first, Petagrams second)
				{
					return new Milligrams(first.value + (second.value)*1E+18);
				}
								public static implicit operator Exagrams(Milligrams value)
				{
					return (value.value)*1E-21;
				}

				public static Milligrams operator +(Milligrams first, Exagrams second)
				{
					return new Milligrams(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettagrams(Milligrams value)
				{
					return (value.value)*1E-24;
				}

				public static Milligrams operator +(Milligrams first, Zettagrams second)
				{
					return new Milligrams(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottagrams(Milligrams value)
				{
					return (value.value)*1E-27;
				}

				public static Milligrams operator +(Milligrams first, Yottagrams second)
				{
					return new Milligrams(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centigrams : IValueWithUnit, IEquatable< Centigrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Centigrams Zero = new Centigrams(0);
			public static readonly Centigrams One = new Centigrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.centigram; } }

			public Centigrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E-05);
				}
				
			public bool Equals(Centigrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centigrams(double value)
			{
				return new Centigrams(value);
			}

			public static Centigrams operator *(Centigrams value, double times)
			{
				return new Centigrams(value.value * times);
			}

			public static Centigrams operator *(double times, Centigrams value)
			{
				return new Centigrams(value.value * times);
			}

			public static Centigrams operator +(Centigrams first, Centigrams second)
			{
				return new Centigrams(first.value * second.value);
			}

							public static implicit operator Grams(Centigrams value)
				{
					return (value.value)*0.01;
				}

				public static Centigrams operator +(Centigrams first, Grams second)
				{
					return new Centigrams(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctograms(Centigrams value)
				{
					return (value.value)*1E+22;
				}

				public static Centigrams operator +(Centigrams first, Yoctograms second)
				{
					return new Centigrams(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptograms(Centigrams value)
				{
					return (value.value)*1E+19;
				}

				public static Centigrams operator +(Centigrams first, Zeptograms second)
				{
					return new Centigrams(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attograms(Centigrams value)
				{
					return (value.value)*1E+16;
				}

				public static Centigrams operator +(Centigrams first, Attograms second)
				{
					return new Centigrams(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtograms(Centigrams value)
				{
					return (value.value)*10000000000000;
				}

				public static Centigrams operator +(Centigrams first, Femtograms second)
				{
					return new Centigrams(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picograms(Centigrams value)
				{
					return (value.value)*10000000000;
				}

				public static Centigrams operator +(Centigrams first, Picograms second)
				{
					return new Centigrams(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanograms(Centigrams value)
				{
					return (value.value)*10000000;
				}

				public static Centigrams operator +(Centigrams first, Nanograms second)
				{
					return new Centigrams(first.value + (second.value)*1E-07);
				}
								public static implicit operator Micrograms(Centigrams value)
				{
					return (value.value)*10000;
				}

				public static Centigrams operator +(Centigrams first, Micrograms second)
				{
					return new Centigrams(first.value + (second.value)*0.0001);
				}
								public static implicit operator Milligrams(Centigrams value)
				{
					return (value.value)*10;
				}

				public static Centigrams operator +(Centigrams first, Milligrams second)
				{
					return new Centigrams(first.value + (second.value)*0.1);
				}
								public static implicit operator Decigrams(Centigrams value)
				{
					return (value.value)*0.1;
				}

				public static Centigrams operator +(Centigrams first, Decigrams second)
				{
					return new Centigrams(first.value + (second.value)*10);
				}
								public static implicit operator Decagrams(Centigrams value)
				{
					return (value.value)*0.001;
				}

				public static Centigrams operator +(Centigrams first, Decagrams second)
				{
					return new Centigrams(first.value + (second.value)*1000);
				}
								public static implicit operator Hectograms(Centigrams value)
				{
					return (value.value)*0.0001;
				}

				public static Centigrams operator +(Centigrams first, Hectograms second)
				{
					return new Centigrams(first.value + (second.value)*10000);
				}
								public static implicit operator Kilograms(Centigrams value)
				{
					return (value.value)*1E-05;
				}

				public static Centigrams operator +(Centigrams first, Kilograms second)
				{
					return new Centigrams(first.value + (second.value)*100000);
				}
								public static implicit operator Megagrams(Centigrams value)
				{
					return (value.value)*1E-08;
				}

				public static Centigrams operator +(Centigrams first, Megagrams second)
				{
					return new Centigrams(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigagrams(Centigrams value)
				{
					return (value.value)*1E-11;
				}

				public static Centigrams operator +(Centigrams first, Gigagrams second)
				{
					return new Centigrams(first.value + (second.value)*100000000000);
				}
								public static implicit operator Teragrams(Centigrams value)
				{
					return (value.value)*1E-14;
				}

				public static Centigrams operator +(Centigrams first, Teragrams second)
				{
					return new Centigrams(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petagrams(Centigrams value)
				{
					return (value.value)*1E-17;
				}

				public static Centigrams operator +(Centigrams first, Petagrams second)
				{
					return new Centigrams(first.value + (second.value)*1E+17);
				}
								public static implicit operator Exagrams(Centigrams value)
				{
					return (value.value)*1E-20;
				}

				public static Centigrams operator +(Centigrams first, Exagrams second)
				{
					return new Centigrams(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettagrams(Centigrams value)
				{
					return (value.value)*1E-23;
				}

				public static Centigrams operator +(Centigrams first, Zettagrams second)
				{
					return new Centigrams(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottagrams(Centigrams value)
				{
					return (value.value)*1E-26;
				}

				public static Centigrams operator +(Centigrams first, Yottagrams second)
				{
					return new Centigrams(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Decigrams : IValueWithUnit, IEquatable< Decigrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Decigrams Zero = new Decigrams(0);
			public static readonly Decigrams One = new Decigrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.decigram; } }

			public Decigrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*0.0001);
				}
				
			public bool Equals(Decigrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decigrams(double value)
			{
				return new Decigrams(value);
			}

			public static Decigrams operator *(Decigrams value, double times)
			{
				return new Decigrams(value.value * times);
			}

			public static Decigrams operator *(double times, Decigrams value)
			{
				return new Decigrams(value.value * times);
			}

			public static Decigrams operator +(Decigrams first, Decigrams second)
			{
				return new Decigrams(first.value * second.value);
			}

							public static implicit operator Grams(Decigrams value)
				{
					return (value.value)*0.1;
				}

				public static Decigrams operator +(Decigrams first, Grams second)
				{
					return new Decigrams(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctograms(Decigrams value)
				{
					return (value.value)*1E+23;
				}

				public static Decigrams operator +(Decigrams first, Yoctograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptograms(Decigrams value)
				{
					return (value.value)*1E+20;
				}

				public static Decigrams operator +(Decigrams first, Zeptograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attograms(Decigrams value)
				{
					return (value.value)*1E+17;
				}

				public static Decigrams operator +(Decigrams first, Attograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtograms(Decigrams value)
				{
					return (value.value)*100000000000000;
				}

				public static Decigrams operator +(Decigrams first, Femtograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picograms(Decigrams value)
				{
					return (value.value)*100000000000;
				}

				public static Decigrams operator +(Decigrams first, Picograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanograms(Decigrams value)
				{
					return (value.value)*100000000;
				}

				public static Decigrams operator +(Decigrams first, Nanograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-08);
				}
								public static implicit operator Micrograms(Decigrams value)
				{
					return (value.value)*100000;
				}

				public static Decigrams operator +(Decigrams first, Micrograms second)
				{
					return new Decigrams(first.value + (second.value)*1E-05);
				}
								public static implicit operator Milligrams(Decigrams value)
				{
					return (value.value)*100;
				}

				public static Decigrams operator +(Decigrams first, Milligrams second)
				{
					return new Decigrams(first.value + (second.value)*0.01);
				}
								public static implicit operator Centigrams(Decigrams value)
				{
					return (value.value)*10;
				}

				public static Decigrams operator +(Decigrams first, Centigrams second)
				{
					return new Decigrams(first.value + (second.value)*0.1);
				}
								public static implicit operator Decagrams(Decigrams value)
				{
					return (value.value)*0.01;
				}

				public static Decigrams operator +(Decigrams first, Decagrams second)
				{
					return new Decigrams(first.value + (second.value)*100);
				}
								public static implicit operator Hectograms(Decigrams value)
				{
					return (value.value)*0.001;
				}

				public static Decigrams operator +(Decigrams first, Hectograms second)
				{
					return new Decigrams(first.value + (second.value)*1000);
				}
								public static implicit operator Kilograms(Decigrams value)
				{
					return (value.value)*0.0001;
				}

				public static Decigrams operator +(Decigrams first, Kilograms second)
				{
					return new Decigrams(first.value + (second.value)*10000);
				}
								public static implicit operator Megagrams(Decigrams value)
				{
					return (value.value)*1E-07;
				}

				public static Decigrams operator +(Decigrams first, Megagrams second)
				{
					return new Decigrams(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigagrams(Decigrams value)
				{
					return (value.value)*1E-10;
				}

				public static Decigrams operator +(Decigrams first, Gigagrams second)
				{
					return new Decigrams(first.value + (second.value)*10000000000);
				}
								public static implicit operator Teragrams(Decigrams value)
				{
					return (value.value)*1E-13;
				}

				public static Decigrams operator +(Decigrams first, Teragrams second)
				{
					return new Decigrams(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petagrams(Decigrams value)
				{
					return (value.value)*1E-16;
				}

				public static Decigrams operator +(Decigrams first, Petagrams second)
				{
					return new Decigrams(first.value + (second.value)*1E+16);
				}
								public static implicit operator Exagrams(Decigrams value)
				{
					return (value.value)*1E-19;
				}

				public static Decigrams operator +(Decigrams first, Exagrams second)
				{
					return new Decigrams(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettagrams(Decigrams value)
				{
					return (value.value)*1E-22;
				}

				public static Decigrams operator +(Decigrams first, Zettagrams second)
				{
					return new Decigrams(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottagrams(Decigrams value)
				{
					return (value.value)*1E-25;
				}

				public static Decigrams operator +(Decigrams first, Yottagrams second)
				{
					return new Decigrams(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decagrams : IValueWithUnit, IEquatable< Decagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Decagrams Zero = new Decagrams(0);
			public static readonly Decagrams One = new Decagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.decagram; } }

			public Decagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dag", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*0.01);
				}
				
			public bool Equals(Decagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decagrams(double value)
			{
				return new Decagrams(value);
			}

			public static Decagrams operator *(Decagrams value, double times)
			{
				return new Decagrams(value.value * times);
			}

			public static Decagrams operator *(double times, Decagrams value)
			{
				return new Decagrams(value.value * times);
			}

			public static Decagrams operator +(Decagrams first, Decagrams second)
			{
				return new Decagrams(first.value * second.value);
			}

							public static implicit operator Grams(Decagrams value)
				{
					return (value.value)*10;
				}

				public static Decagrams operator +(Decagrams first, Grams second)
				{
					return new Decagrams(first.value + (second.value)/10);
				}
								public static implicit operator Yoctograms(Decagrams value)
				{
					return (value.value)*1E+25;
				}

				public static Decagrams operator +(Decagrams first, Yoctograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptograms(Decagrams value)
				{
					return (value.value)*1E+22;
				}

				public static Decagrams operator +(Decagrams first, Zeptograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attograms(Decagrams value)
				{
					return (value.value)*1E+19;
				}

				public static Decagrams operator +(Decagrams first, Attograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtograms(Decagrams value)
				{
					return (value.value)*1E+16;
				}

				public static Decagrams operator +(Decagrams first, Femtograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picograms(Decagrams value)
				{
					return (value.value)*10000000000000;
				}

				public static Decagrams operator +(Decagrams first, Picograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanograms(Decagrams value)
				{
					return (value.value)*10000000000;
				}

				public static Decagrams operator +(Decagrams first, Nanograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-10);
				}
								public static implicit operator Micrograms(Decagrams value)
				{
					return (value.value)*10000000;
				}

				public static Decagrams operator +(Decagrams first, Micrograms second)
				{
					return new Decagrams(first.value + (second.value)*1E-07);
				}
								public static implicit operator Milligrams(Decagrams value)
				{
					return (value.value)*10000;
				}

				public static Decagrams operator +(Decagrams first, Milligrams second)
				{
					return new Decagrams(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centigrams(Decagrams value)
				{
					return (value.value)*1000;
				}

				public static Decagrams operator +(Decagrams first, Centigrams second)
				{
					return new Decagrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Decigrams(Decagrams value)
				{
					return (value.value)*100;
				}

				public static Decagrams operator +(Decagrams first, Decigrams second)
				{
					return new Decagrams(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectograms(Decagrams value)
				{
					return (value.value)*0.1;
				}

				public static Decagrams operator +(Decagrams first, Hectograms second)
				{
					return new Decagrams(first.value + (second.value)*10);
				}
								public static implicit operator Kilograms(Decagrams value)
				{
					return (value.value)*0.01;
				}

				public static Decagrams operator +(Decagrams first, Kilograms second)
				{
					return new Decagrams(first.value + (second.value)*100);
				}
								public static implicit operator Megagrams(Decagrams value)
				{
					return (value.value)*1E-05;
				}

				public static Decagrams operator +(Decagrams first, Megagrams second)
				{
					return new Decagrams(first.value + (second.value)*100000);
				}
								public static implicit operator Gigagrams(Decagrams value)
				{
					return (value.value)*1E-08;
				}

				public static Decagrams operator +(Decagrams first, Gigagrams second)
				{
					return new Decagrams(first.value + (second.value)*100000000);
				}
								public static implicit operator Teragrams(Decagrams value)
				{
					return (value.value)*1E-11;
				}

				public static Decagrams operator +(Decagrams first, Teragrams second)
				{
					return new Decagrams(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petagrams(Decagrams value)
				{
					return (value.value)*1E-14;
				}

				public static Decagrams operator +(Decagrams first, Petagrams second)
				{
					return new Decagrams(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Exagrams(Decagrams value)
				{
					return (value.value)*1E-17;
				}

				public static Decagrams operator +(Decagrams first, Exagrams second)
				{
					return new Decagrams(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettagrams(Decagrams value)
				{
					return (value.value)*1E-20;
				}

				public static Decagrams operator +(Decagrams first, Zettagrams second)
				{
					return new Decagrams(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottagrams(Decagrams value)
				{
					return (value.value)*1E-23;
				}

				public static Decagrams operator +(Decagrams first, Yottagrams second)
				{
					return new Decagrams(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectograms : IValueWithUnit, IEquatable< Hectograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectograms Zero = new Hectograms(0);
			public static readonly Hectograms One = new Hectograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.hectogram; } }

			public Hectograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*0.1);
				}
				
			public bool Equals(Hectograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectograms(double value)
			{
				return new Hectograms(value);
			}

			public static Hectograms operator *(Hectograms value, double times)
			{
				return new Hectograms(value.value * times);
			}

			public static Hectograms operator *(double times, Hectograms value)
			{
				return new Hectograms(value.value * times);
			}

			public static Hectograms operator +(Hectograms first, Hectograms second)
			{
				return new Hectograms(first.value * second.value);
			}

							public static implicit operator Grams(Hectograms value)
				{
					return (value.value)*100;
				}

				public static Hectograms operator +(Hectograms first, Grams second)
				{
					return new Hectograms(first.value + (second.value)/100);
				}
								public static implicit operator Yoctograms(Hectograms value)
				{
					return (value.value)*1E+26;
				}

				public static Hectograms operator +(Hectograms first, Yoctograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptograms(Hectograms value)
				{
					return (value.value)*1E+23;
				}

				public static Hectograms operator +(Hectograms first, Zeptograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attograms(Hectograms value)
				{
					return (value.value)*1E+20;
				}

				public static Hectograms operator +(Hectograms first, Attograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtograms(Hectograms value)
				{
					return (value.value)*1E+17;
				}

				public static Hectograms operator +(Hectograms first, Femtograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picograms(Hectograms value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectograms operator +(Hectograms first, Picograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanograms(Hectograms value)
				{
					return (value.value)*100000000000;
				}

				public static Hectograms operator +(Hectograms first, Nanograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-11);
				}
								public static implicit operator Micrograms(Hectograms value)
				{
					return (value.value)*100000000;
				}

				public static Hectograms operator +(Hectograms first, Micrograms second)
				{
					return new Hectograms(first.value + (second.value)*1E-08);
				}
								public static implicit operator Milligrams(Hectograms value)
				{
					return (value.value)*100000;
				}

				public static Hectograms operator +(Hectograms first, Milligrams second)
				{
					return new Hectograms(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centigrams(Hectograms value)
				{
					return (value.value)*10000;
				}

				public static Hectograms operator +(Hectograms first, Centigrams second)
				{
					return new Hectograms(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decigrams(Hectograms value)
				{
					return (value.value)*1000;
				}

				public static Hectograms operator +(Hectograms first, Decigrams second)
				{
					return new Hectograms(first.value + (second.value)*0.001);
				}
								public static implicit operator Decagrams(Hectograms value)
				{
					return (value.value)*10;
				}

				public static Hectograms operator +(Hectograms first, Decagrams second)
				{
					return new Hectograms(first.value + (second.value)*0.1);
				}
								public static implicit operator Kilograms(Hectograms value)
				{
					return (value.value)*0.1;
				}

				public static Hectograms operator +(Hectograms first, Kilograms second)
				{
					return new Hectograms(first.value + (second.value)*10);
				}
								public static implicit operator Megagrams(Hectograms value)
				{
					return (value.value)*0.0001;
				}

				public static Hectograms operator +(Hectograms first, Megagrams second)
				{
					return new Hectograms(first.value + (second.value)*10000);
				}
								public static implicit operator Gigagrams(Hectograms value)
				{
					return (value.value)*1E-07;
				}

				public static Hectograms operator +(Hectograms first, Gigagrams second)
				{
					return new Hectograms(first.value + (second.value)*10000000);
				}
								public static implicit operator Teragrams(Hectograms value)
				{
					return (value.value)*1E-10;
				}

				public static Hectograms operator +(Hectograms first, Teragrams second)
				{
					return new Hectograms(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petagrams(Hectograms value)
				{
					return (value.value)*1E-13;
				}

				public static Hectograms operator +(Hectograms first, Petagrams second)
				{
					return new Hectograms(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Exagrams(Hectograms value)
				{
					return (value.value)*1E-16;
				}

				public static Hectograms operator +(Hectograms first, Exagrams second)
				{
					return new Hectograms(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettagrams(Hectograms value)
				{
					return (value.value)*1E-19;
				}

				public static Hectograms operator +(Hectograms first, Zettagrams second)
				{
					return new Hectograms(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottagrams(Hectograms value)
				{
					return (value.value)*1E-22;
				}

				public static Hectograms operator +(Hectograms first, Yottagrams second)
				{
					return new Hectograms(first.value + (second.value)*1E+22);
				}
						}
		}

		public struct Kilograms : IValueWithUnit, IEquatable< Kilograms >, IEquatable<IValueWithUnit>
		{
			public static readonly Kilograms Zero = new Kilograms(0);
			public static readonly Kilograms One = new Kilograms(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.kilogram; } }

			public Kilograms(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} kg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Kilograms other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kilograms(double value)
			{
				return new Kilograms(value);
			}

			public static Kilograms operator *(Kilograms value, double times)
			{
				return new Kilograms(value.value * times);
			}

			public static Kilograms operator *(double times, Kilograms value)
			{
				return new Kilograms(value.value * times);
			}

			public static Kilograms operator +(Kilograms first, Kilograms second)
			{
				return new Kilograms(first.value * second.value);
			}

							public static implicit operator Grams(Kilograms value)
				{
					return (value.value)*1000;
				}

				public static Kilograms operator +(Kilograms first, Grams second)
				{
					return new Kilograms(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctograms(Kilograms value)
				{
					return (value.value)*1E+27;
				}

				public static Kilograms operator +(Kilograms first, Yoctograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptograms(Kilograms value)
				{
					return (value.value)*1E+24;
				}

				public static Kilograms operator +(Kilograms first, Zeptograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attograms(Kilograms value)
				{
					return (value.value)*1E+21;
				}

				public static Kilograms operator +(Kilograms first, Attograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtograms(Kilograms value)
				{
					return (value.value)*1E+18;
				}

				public static Kilograms operator +(Kilograms first, Femtograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picograms(Kilograms value)
				{
					return (value.value)*1E+15;
				}

				public static Kilograms operator +(Kilograms first, Picograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanograms(Kilograms value)
				{
					return (value.value)*1000000000000;
				}

				public static Kilograms operator +(Kilograms first, Nanograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-12);
				}
								public static implicit operator Micrograms(Kilograms value)
				{
					return (value.value)*1000000000;
				}

				public static Kilograms operator +(Kilograms first, Micrograms second)
				{
					return new Kilograms(first.value + (second.value)*1E-09);
				}
								public static implicit operator Milligrams(Kilograms value)
				{
					return (value.value)*1000000;
				}

				public static Kilograms operator +(Kilograms first, Milligrams second)
				{
					return new Kilograms(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centigrams(Kilograms value)
				{
					return (value.value)*100000;
				}

				public static Kilograms operator +(Kilograms first, Centigrams second)
				{
					return new Kilograms(first.value + (second.value)*1E-05);
				}
								public static implicit operator Decigrams(Kilograms value)
				{
					return (value.value)*10000;
				}

				public static Kilograms operator +(Kilograms first, Decigrams second)
				{
					return new Kilograms(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decagrams(Kilograms value)
				{
					return (value.value)*100;
				}

				public static Kilograms operator +(Kilograms first, Decagrams second)
				{
					return new Kilograms(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectograms(Kilograms value)
				{
					return (value.value)*10;
				}

				public static Kilograms operator +(Kilograms first, Hectograms second)
				{
					return new Kilograms(first.value + (second.value)*0.1);
				}
								public static implicit operator Megagrams(Kilograms value)
				{
					return (value.value)*0.001;
				}

				public static Kilograms operator +(Kilograms first, Megagrams second)
				{
					return new Kilograms(first.value + (second.value)*1000);
				}
								public static implicit operator Gigagrams(Kilograms value)
				{
					return (value.value)*1E-06;
				}

				public static Kilograms operator +(Kilograms first, Gigagrams second)
				{
					return new Kilograms(first.value + (second.value)*1000000);
				}
								public static implicit operator Teragrams(Kilograms value)
				{
					return (value.value)*1E-09;
				}

				public static Kilograms operator +(Kilograms first, Teragrams second)
				{
					return new Kilograms(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petagrams(Kilograms value)
				{
					return (value.value)*1E-12;
				}

				public static Kilograms operator +(Kilograms first, Petagrams second)
				{
					return new Kilograms(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Exagrams(Kilograms value)
				{
					return (value.value)*1E-15;
				}

				public static Kilograms operator +(Kilograms first, Exagrams second)
				{
					return new Kilograms(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettagrams(Kilograms value)
				{
					return (value.value)*1E-18;
				}

				public static Kilograms operator +(Kilograms first, Zettagrams second)
				{
					return new Kilograms(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottagrams(Kilograms value)
				{
					return (value.value)*1E-21;
				}

				public static Kilograms operator +(Kilograms first, Yottagrams second)
				{
					return new Kilograms(first.value + (second.value)*1E+21);
				}
						}
		namespace Multiples
{

		public struct Megagrams : IValueWithUnit, IEquatable< Megagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Megagrams Zero = new Megagrams(0);
			public static readonly Megagrams One = new Megagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.megagram; } }

			public Megagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Mg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1000);
				}
				
			public bool Equals(Megagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megagrams(double value)
			{
				return new Megagrams(value);
			}

			public static Megagrams operator *(Megagrams value, double times)
			{
				return new Megagrams(value.value * times);
			}

			public static Megagrams operator *(double times, Megagrams value)
			{
				return new Megagrams(value.value * times);
			}

			public static Megagrams operator +(Megagrams first, Megagrams second)
			{
				return new Megagrams(first.value * second.value);
			}

							public static implicit operator Grams(Megagrams value)
				{
					return (value.value)*1000000;
				}

				public static Megagrams operator +(Megagrams first, Grams second)
				{
					return new Megagrams(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctograms(Megagrams value)
				{
					return (value.value)*1E+30;
				}

				public static Megagrams operator +(Megagrams first, Yoctograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptograms(Megagrams value)
				{
					return (value.value)*1E+27;
				}

				public static Megagrams operator +(Megagrams first, Zeptograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attograms(Megagrams value)
				{
					return (value.value)*1E+24;
				}

				public static Megagrams operator +(Megagrams first, Attograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtograms(Megagrams value)
				{
					return (value.value)*1E+21;
				}

				public static Megagrams operator +(Megagrams first, Femtograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picograms(Megagrams value)
				{
					return (value.value)*1E+18;
				}

				public static Megagrams operator +(Megagrams first, Picograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanograms(Megagrams value)
				{
					return (value.value)*1E+15;
				}

				public static Megagrams operator +(Megagrams first, Nanograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Micrograms(Megagrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Megagrams operator +(Megagrams first, Micrograms second)
				{
					return new Megagrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Milligrams(Megagrams value)
				{
					return (value.value)*1000000000;
				}

				public static Megagrams operator +(Megagrams first, Milligrams second)
				{
					return new Megagrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centigrams(Megagrams value)
				{
					return (value.value)*100000000;
				}

				public static Megagrams operator +(Megagrams first, Centigrams second)
				{
					return new Megagrams(first.value + (second.value)*1E-08);
				}
								public static implicit operator Decigrams(Megagrams value)
				{
					return (value.value)*10000000;
				}

				public static Megagrams operator +(Megagrams first, Decigrams second)
				{
					return new Megagrams(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decagrams(Megagrams value)
				{
					return (value.value)*100000;
				}

				public static Megagrams operator +(Megagrams first, Decagrams second)
				{
					return new Megagrams(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectograms(Megagrams value)
				{
					return (value.value)*10000;
				}

				public static Megagrams operator +(Megagrams first, Hectograms second)
				{
					return new Megagrams(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kilograms(Megagrams value)
				{
					return (value.value)*1000;
				}

				public static Megagrams operator +(Megagrams first, Kilograms second)
				{
					return new Megagrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigagrams(Megagrams value)
				{
					return (value.value)*0.001;
				}

				public static Megagrams operator +(Megagrams first, Gigagrams second)
				{
					return new Megagrams(first.value + (second.value)*1000);
				}
								public static implicit operator Teragrams(Megagrams value)
				{
					return (value.value)*1E-06;
				}

				public static Megagrams operator +(Megagrams first, Teragrams second)
				{
					return new Megagrams(first.value + (second.value)*1000000);
				}
								public static implicit operator Petagrams(Megagrams value)
				{
					return (value.value)*1E-09;
				}

				public static Megagrams operator +(Megagrams first, Petagrams second)
				{
					return new Megagrams(first.value + (second.value)*1000000000);
				}
								public static implicit operator Exagrams(Megagrams value)
				{
					return (value.value)*1E-12;
				}

				public static Megagrams operator +(Megagrams first, Exagrams second)
				{
					return new Megagrams(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettagrams(Megagrams value)
				{
					return (value.value)*1E-15;
				}

				public static Megagrams operator +(Megagrams first, Zettagrams second)
				{
					return new Megagrams(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottagrams(Megagrams value)
				{
					return (value.value)*1E-18;
				}

				public static Megagrams operator +(Megagrams first, Yottagrams second)
				{
					return new Megagrams(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigagrams : IValueWithUnit, IEquatable< Gigagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigagrams Zero = new Gigagrams(0);
			public static readonly Gigagrams One = new Gigagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.gigagram; } }

			public Gigagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Gg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1000000);
				}
				
			public bool Equals(Gigagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigagrams(double value)
			{
				return new Gigagrams(value);
			}

			public static Gigagrams operator *(Gigagrams value, double times)
			{
				return new Gigagrams(value.value * times);
			}

			public static Gigagrams operator *(double times, Gigagrams value)
			{
				return new Gigagrams(value.value * times);
			}

			public static Gigagrams operator +(Gigagrams first, Gigagrams second)
			{
				return new Gigagrams(first.value * second.value);
			}

							public static implicit operator Grams(Gigagrams value)
				{
					return (value.value)*1000000000;
				}

				public static Gigagrams operator +(Gigagrams first, Grams second)
				{
					return new Gigagrams(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctograms(Gigagrams value)
				{
					return (value.value)*1E+33;
				}

				public static Gigagrams operator +(Gigagrams first, Yoctograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptograms(Gigagrams value)
				{
					return (value.value)*1E+30;
				}

				public static Gigagrams operator +(Gigagrams first, Zeptograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attograms(Gigagrams value)
				{
					return (value.value)*1E+27;
				}

				public static Gigagrams operator +(Gigagrams first, Attograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtograms(Gigagrams value)
				{
					return (value.value)*1E+24;
				}

				public static Gigagrams operator +(Gigagrams first, Femtograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picograms(Gigagrams value)
				{
					return (value.value)*1E+21;
				}

				public static Gigagrams operator +(Gigagrams first, Picograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanograms(Gigagrams value)
				{
					return (value.value)*1E+18;
				}

				public static Gigagrams operator +(Gigagrams first, Nanograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Micrograms(Gigagrams value)
				{
					return (value.value)*1E+15;
				}

				public static Gigagrams operator +(Gigagrams first, Micrograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Milligrams(Gigagrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigagrams operator +(Gigagrams first, Milligrams second)
				{
					return new Gigagrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centigrams(Gigagrams value)
				{
					return (value.value)*100000000000;
				}

				public static Gigagrams operator +(Gigagrams first, Centigrams second)
				{
					return new Gigagrams(first.value + (second.value)*1E-11);
				}
								public static implicit operator Decigrams(Gigagrams value)
				{
					return (value.value)*10000000000;
				}

				public static Gigagrams operator +(Gigagrams first, Decigrams second)
				{
					return new Gigagrams(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decagrams(Gigagrams value)
				{
					return (value.value)*100000000;
				}

				public static Gigagrams operator +(Gigagrams first, Decagrams second)
				{
					return new Gigagrams(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectograms(Gigagrams value)
				{
					return (value.value)*10000000;
				}

				public static Gigagrams operator +(Gigagrams first, Hectograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kilograms(Gigagrams value)
				{
					return (value.value)*1000000;
				}

				public static Gigagrams operator +(Gigagrams first, Kilograms second)
				{
					return new Gigagrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megagrams(Gigagrams value)
				{
					return (value.value)*1000;
				}

				public static Gigagrams operator +(Gigagrams first, Megagrams second)
				{
					return new Gigagrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Teragrams(Gigagrams value)
				{
					return (value.value)*0.001;
				}

				public static Gigagrams operator +(Gigagrams first, Teragrams second)
				{
					return new Gigagrams(first.value + (second.value)*1000);
				}
								public static implicit operator Petagrams(Gigagrams value)
				{
					return (value.value)*1E-06;
				}

				public static Gigagrams operator +(Gigagrams first, Petagrams second)
				{
					return new Gigagrams(first.value + (second.value)*1000000);
				}
								public static implicit operator Exagrams(Gigagrams value)
				{
					return (value.value)*1E-09;
				}

				public static Gigagrams operator +(Gigagrams first, Exagrams second)
				{
					return new Gigagrams(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettagrams(Gigagrams value)
				{
					return (value.value)*1E-12;
				}

				public static Gigagrams operator +(Gigagrams first, Zettagrams second)
				{
					return new Gigagrams(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottagrams(Gigagrams value)
				{
					return (value.value)*1E-15;
				}

				public static Gigagrams operator +(Gigagrams first, Yottagrams second)
				{
					return new Gigagrams(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Teragrams : IValueWithUnit, IEquatable< Teragrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Teragrams Zero = new Teragrams(0);
			public static readonly Teragrams One = new Teragrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.teragram; } }

			public Teragrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Tg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1000000000);
				}
				
			public bool Equals(Teragrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Teragrams(double value)
			{
				return new Teragrams(value);
			}

			public static Teragrams operator *(Teragrams value, double times)
			{
				return new Teragrams(value.value * times);
			}

			public static Teragrams operator *(double times, Teragrams value)
			{
				return new Teragrams(value.value * times);
			}

			public static Teragrams operator +(Teragrams first, Teragrams second)
			{
				return new Teragrams(first.value * second.value);
			}

							public static implicit operator Grams(Teragrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Teragrams operator +(Teragrams first, Grams second)
				{
					return new Teragrams(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctograms(Teragrams value)
				{
					return (value.value)*1E+36;
				}

				public static Teragrams operator +(Teragrams first, Yoctograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptograms(Teragrams value)
				{
					return (value.value)*1E+33;
				}

				public static Teragrams operator +(Teragrams first, Zeptograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attograms(Teragrams value)
				{
					return (value.value)*1E+30;
				}

				public static Teragrams operator +(Teragrams first, Attograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtograms(Teragrams value)
				{
					return (value.value)*1E+27;
				}

				public static Teragrams operator +(Teragrams first, Femtograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picograms(Teragrams value)
				{
					return (value.value)*1E+24;
				}

				public static Teragrams operator +(Teragrams first, Picograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanograms(Teragrams value)
				{
					return (value.value)*1E+21;
				}

				public static Teragrams operator +(Teragrams first, Nanograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Micrograms(Teragrams value)
				{
					return (value.value)*1E+18;
				}

				public static Teragrams operator +(Teragrams first, Micrograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Milligrams(Teragrams value)
				{
					return (value.value)*1E+15;
				}

				public static Teragrams operator +(Teragrams first, Milligrams second)
				{
					return new Teragrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centigrams(Teragrams value)
				{
					return (value.value)*100000000000000;
				}

				public static Teragrams operator +(Teragrams first, Centigrams second)
				{
					return new Teragrams(first.value + (second.value)*1E-14);
				}
								public static implicit operator Decigrams(Teragrams value)
				{
					return (value.value)*10000000000000;
				}

				public static Teragrams operator +(Teragrams first, Decigrams second)
				{
					return new Teragrams(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decagrams(Teragrams value)
				{
					return (value.value)*100000000000;
				}

				public static Teragrams operator +(Teragrams first, Decagrams second)
				{
					return new Teragrams(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectograms(Teragrams value)
				{
					return (value.value)*10000000000;
				}

				public static Teragrams operator +(Teragrams first, Hectograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kilograms(Teragrams value)
				{
					return (value.value)*1000000000;
				}

				public static Teragrams operator +(Teragrams first, Kilograms second)
				{
					return new Teragrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megagrams(Teragrams value)
				{
					return (value.value)*1000000;
				}

				public static Teragrams operator +(Teragrams first, Megagrams second)
				{
					return new Teragrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigagrams(Teragrams value)
				{
					return (value.value)*1000;
				}

				public static Teragrams operator +(Teragrams first, Gigagrams second)
				{
					return new Teragrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Petagrams(Teragrams value)
				{
					return (value.value)*0.001;
				}

				public static Teragrams operator +(Teragrams first, Petagrams second)
				{
					return new Teragrams(first.value + (second.value)*1000);
				}
								public static implicit operator Exagrams(Teragrams value)
				{
					return (value.value)*1E-06;
				}

				public static Teragrams operator +(Teragrams first, Exagrams second)
				{
					return new Teragrams(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettagrams(Teragrams value)
				{
					return (value.value)*1E-09;
				}

				public static Teragrams operator +(Teragrams first, Zettagrams second)
				{
					return new Teragrams(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottagrams(Teragrams value)
				{
					return (value.value)*1E-12;
				}

				public static Teragrams operator +(Teragrams first, Yottagrams second)
				{
					return new Teragrams(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petagrams : IValueWithUnit, IEquatable< Petagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Petagrams Zero = new Petagrams(0);
			public static readonly Petagrams One = new Petagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.petagram; } }

			public Petagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Pg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1000000000000);
				}
				
			public bool Equals(Petagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petagrams(double value)
			{
				return new Petagrams(value);
			}

			public static Petagrams operator *(Petagrams value, double times)
			{
				return new Petagrams(value.value * times);
			}

			public static Petagrams operator *(double times, Petagrams value)
			{
				return new Petagrams(value.value * times);
			}

			public static Petagrams operator +(Petagrams first, Petagrams second)
			{
				return new Petagrams(first.value * second.value);
			}

							public static implicit operator Grams(Petagrams value)
				{
					return (value.value)*1E+15;
				}

				public static Petagrams operator +(Petagrams first, Grams second)
				{
					return new Petagrams(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctograms(Petagrams value)
				{
					return (value.value)*1E+39;
				}

				public static Petagrams operator +(Petagrams first, Yoctograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptograms(Petagrams value)
				{
					return (value.value)*1E+36;
				}

				public static Petagrams operator +(Petagrams first, Zeptograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attograms(Petagrams value)
				{
					return (value.value)*1E+33;
				}

				public static Petagrams operator +(Petagrams first, Attograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtograms(Petagrams value)
				{
					return (value.value)*1E+30;
				}

				public static Petagrams operator +(Petagrams first, Femtograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picograms(Petagrams value)
				{
					return (value.value)*1E+27;
				}

				public static Petagrams operator +(Petagrams first, Picograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanograms(Petagrams value)
				{
					return (value.value)*1E+24;
				}

				public static Petagrams operator +(Petagrams first, Nanograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Micrograms(Petagrams value)
				{
					return (value.value)*1E+21;
				}

				public static Petagrams operator +(Petagrams first, Micrograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Milligrams(Petagrams value)
				{
					return (value.value)*1E+18;
				}

				public static Petagrams operator +(Petagrams first, Milligrams second)
				{
					return new Petagrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centigrams(Petagrams value)
				{
					return (value.value)*1E+17;
				}

				public static Petagrams operator +(Petagrams first, Centigrams second)
				{
					return new Petagrams(first.value + (second.value)*1E-17);
				}
								public static implicit operator Decigrams(Petagrams value)
				{
					return (value.value)*1E+16;
				}

				public static Petagrams operator +(Petagrams first, Decigrams second)
				{
					return new Petagrams(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decagrams(Petagrams value)
				{
					return (value.value)*100000000000000;
				}

				public static Petagrams operator +(Petagrams first, Decagrams second)
				{
					return new Petagrams(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectograms(Petagrams value)
				{
					return (value.value)*10000000000000;
				}

				public static Petagrams operator +(Petagrams first, Hectograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kilograms(Petagrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Petagrams operator +(Petagrams first, Kilograms second)
				{
					return new Petagrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megagrams(Petagrams value)
				{
					return (value.value)*1000000000;
				}

				public static Petagrams operator +(Petagrams first, Megagrams second)
				{
					return new Petagrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigagrams(Petagrams value)
				{
					return (value.value)*1000000;
				}

				public static Petagrams operator +(Petagrams first, Gigagrams second)
				{
					return new Petagrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Teragrams(Petagrams value)
				{
					return (value.value)*1000;
				}

				public static Petagrams operator +(Petagrams first, Teragrams second)
				{
					return new Petagrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Exagrams(Petagrams value)
				{
					return (value.value)*0.001;
				}

				public static Petagrams operator +(Petagrams first, Exagrams second)
				{
					return new Petagrams(first.value + (second.value)*1000);
				}
								public static implicit operator Zettagrams(Petagrams value)
				{
					return (value.value)*1E-06;
				}

				public static Petagrams operator +(Petagrams first, Zettagrams second)
				{
					return new Petagrams(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottagrams(Petagrams value)
				{
					return (value.value)*1E-09;
				}

				public static Petagrams operator +(Petagrams first, Yottagrams second)
				{
					return new Petagrams(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Exagrams : IValueWithUnit, IEquatable< Exagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Exagrams Zero = new Exagrams(0);
			public static readonly Exagrams One = new Exagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.exagram; } }

			public Exagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Eg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E+15);
				}
				
			public bool Equals(Exagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Exagrams(double value)
			{
				return new Exagrams(value);
			}

			public static Exagrams operator *(Exagrams value, double times)
			{
				return new Exagrams(value.value * times);
			}

			public static Exagrams operator *(double times, Exagrams value)
			{
				return new Exagrams(value.value * times);
			}

			public static Exagrams operator +(Exagrams first, Exagrams second)
			{
				return new Exagrams(first.value * second.value);
			}

							public static implicit operator Grams(Exagrams value)
				{
					return (value.value)*1E+18;
				}

				public static Exagrams operator +(Exagrams first, Grams second)
				{
					return new Exagrams(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctograms(Exagrams value)
				{
					return (value.value)*1E+42;
				}

				public static Exagrams operator +(Exagrams first, Yoctograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptograms(Exagrams value)
				{
					return (value.value)*1E+39;
				}

				public static Exagrams operator +(Exagrams first, Zeptograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attograms(Exagrams value)
				{
					return (value.value)*1E+36;
				}

				public static Exagrams operator +(Exagrams first, Attograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtograms(Exagrams value)
				{
					return (value.value)*1E+33;
				}

				public static Exagrams operator +(Exagrams first, Femtograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picograms(Exagrams value)
				{
					return (value.value)*1E+30;
				}

				public static Exagrams operator +(Exagrams first, Picograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanograms(Exagrams value)
				{
					return (value.value)*1E+27;
				}

				public static Exagrams operator +(Exagrams first, Nanograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Micrograms(Exagrams value)
				{
					return (value.value)*1E+24;
				}

				public static Exagrams operator +(Exagrams first, Micrograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Milligrams(Exagrams value)
				{
					return (value.value)*1E+21;
				}

				public static Exagrams operator +(Exagrams first, Milligrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centigrams(Exagrams value)
				{
					return (value.value)*1E+20;
				}

				public static Exagrams operator +(Exagrams first, Centigrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-20);
				}
								public static implicit operator Decigrams(Exagrams value)
				{
					return (value.value)*1E+19;
				}

				public static Exagrams operator +(Exagrams first, Decigrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decagrams(Exagrams value)
				{
					return (value.value)*1E+17;
				}

				public static Exagrams operator +(Exagrams first, Decagrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectograms(Exagrams value)
				{
					return (value.value)*1E+16;
				}

				public static Exagrams operator +(Exagrams first, Hectograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kilograms(Exagrams value)
				{
					return (value.value)*1E+15;
				}

				public static Exagrams operator +(Exagrams first, Kilograms second)
				{
					return new Exagrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megagrams(Exagrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Exagrams operator +(Exagrams first, Megagrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigagrams(Exagrams value)
				{
					return (value.value)*1000000000;
				}

				public static Exagrams operator +(Exagrams first, Gigagrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Teragrams(Exagrams value)
				{
					return (value.value)*1000000;
				}

				public static Exagrams operator +(Exagrams first, Teragrams second)
				{
					return new Exagrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petagrams(Exagrams value)
				{
					return (value.value)*1000;
				}

				public static Exagrams operator +(Exagrams first, Petagrams second)
				{
					return new Exagrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettagrams(Exagrams value)
				{
					return (value.value)*0.001;
				}

				public static Exagrams operator +(Exagrams first, Zettagrams second)
				{
					return new Exagrams(first.value + (second.value)*1000);
				}
								public static implicit operator Yottagrams(Exagrams value)
				{
					return (value.value)*1E-06;
				}

				public static Exagrams operator +(Exagrams first, Yottagrams second)
				{
					return new Exagrams(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettagrams : IValueWithUnit, IEquatable< Zettagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettagrams Zero = new Zettagrams(0);
			public static readonly Zettagrams One = new Zettagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.zettagram; } }

			public Zettagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Zg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E+18);
				}
				
			public bool Equals(Zettagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettagrams(double value)
			{
				return new Zettagrams(value);
			}

			public static Zettagrams operator *(Zettagrams value, double times)
			{
				return new Zettagrams(value.value * times);
			}

			public static Zettagrams operator *(double times, Zettagrams value)
			{
				return new Zettagrams(value.value * times);
			}

			public static Zettagrams operator +(Zettagrams first, Zettagrams second)
			{
				return new Zettagrams(first.value * second.value);
			}

							public static implicit operator Grams(Zettagrams value)
				{
					return (value.value)*1E+21;
				}

				public static Zettagrams operator +(Zettagrams first, Grams second)
				{
					return new Zettagrams(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctograms(Zettagrams value)
				{
					return (value.value)*1E+45;
				}

				public static Zettagrams operator +(Zettagrams first, Yoctograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptograms(Zettagrams value)
				{
					return (value.value)*1E+42;
				}

				public static Zettagrams operator +(Zettagrams first, Zeptograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attograms(Zettagrams value)
				{
					return (value.value)*1E+39;
				}

				public static Zettagrams operator +(Zettagrams first, Attograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtograms(Zettagrams value)
				{
					return (value.value)*1E+36;
				}

				public static Zettagrams operator +(Zettagrams first, Femtograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picograms(Zettagrams value)
				{
					return (value.value)*1E+33;
				}

				public static Zettagrams operator +(Zettagrams first, Picograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanograms(Zettagrams value)
				{
					return (value.value)*1E+30;
				}

				public static Zettagrams operator +(Zettagrams first, Nanograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Micrograms(Zettagrams value)
				{
					return (value.value)*1E+27;
				}

				public static Zettagrams operator +(Zettagrams first, Micrograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Milligrams(Zettagrams value)
				{
					return (value.value)*1E+24;
				}

				public static Zettagrams operator +(Zettagrams first, Milligrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centigrams(Zettagrams value)
				{
					return (value.value)*1E+23;
				}

				public static Zettagrams operator +(Zettagrams first, Centigrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-23);
				}
								public static implicit operator Decigrams(Zettagrams value)
				{
					return (value.value)*1E+22;
				}

				public static Zettagrams operator +(Zettagrams first, Decigrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decagrams(Zettagrams value)
				{
					return (value.value)*1E+20;
				}

				public static Zettagrams operator +(Zettagrams first, Decagrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectograms(Zettagrams value)
				{
					return (value.value)*1E+19;
				}

				public static Zettagrams operator +(Zettagrams first, Hectograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kilograms(Zettagrams value)
				{
					return (value.value)*1E+18;
				}

				public static Zettagrams operator +(Zettagrams first, Kilograms second)
				{
					return new Zettagrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megagrams(Zettagrams value)
				{
					return (value.value)*1E+15;
				}

				public static Zettagrams operator +(Zettagrams first, Megagrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigagrams(Zettagrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettagrams operator +(Zettagrams first, Gigagrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Teragrams(Zettagrams value)
				{
					return (value.value)*1000000000;
				}

				public static Zettagrams operator +(Zettagrams first, Teragrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petagrams(Zettagrams value)
				{
					return (value.value)*1000000;
				}

				public static Zettagrams operator +(Zettagrams first, Petagrams second)
				{
					return new Zettagrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Exagrams(Zettagrams value)
				{
					return (value.value)*1000;
				}

				public static Zettagrams operator +(Zettagrams first, Exagrams second)
				{
					return new Zettagrams(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottagrams(Zettagrams value)
				{
					return (value.value)*0.001;
				}

				public static Zettagrams operator +(Zettagrams first, Yottagrams second)
				{
					return new Zettagrams(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottagrams : IValueWithUnit, IEquatable< Yottagrams >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottagrams Zero = new Yottagrams(0);
			public static readonly Yottagrams One = new Yottagrams(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return Mass.Units.yottagram; } }

			public Yottagrams(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Yg", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kilograms ToBaseUnit()
				{
					return new Kilograms((this.value)*1E+21);
				}
				
			public bool Equals(Yottagrams other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottagrams(double value)
			{
				return new Yottagrams(value);
			}

			public static Yottagrams operator *(Yottagrams value, double times)
			{
				return new Yottagrams(value.value * times);
			}

			public static Yottagrams operator *(double times, Yottagrams value)
			{
				return new Yottagrams(value.value * times);
			}

			public static Yottagrams operator +(Yottagrams first, Yottagrams second)
			{
				return new Yottagrams(first.value * second.value);
			}

							public static implicit operator Grams(Yottagrams value)
				{
					return (value.value)*1E+24;
				}

				public static Yottagrams operator +(Yottagrams first, Grams second)
				{
					return new Yottagrams(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctograms(Yottagrams value)
				{
					return (value.value)*1E+48;
				}

				public static Yottagrams operator +(Yottagrams first, Yoctograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptograms(Yottagrams value)
				{
					return (value.value)*1E+45;
				}

				public static Yottagrams operator +(Yottagrams first, Zeptograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attograms(Yottagrams value)
				{
					return (value.value)*1E+42;
				}

				public static Yottagrams operator +(Yottagrams first, Attograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtograms(Yottagrams value)
				{
					return (value.value)*1E+39;
				}

				public static Yottagrams operator +(Yottagrams first, Femtograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picograms(Yottagrams value)
				{
					return (value.value)*1E+36;
				}

				public static Yottagrams operator +(Yottagrams first, Picograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanograms(Yottagrams value)
				{
					return (value.value)*1E+33;
				}

				public static Yottagrams operator +(Yottagrams first, Nanograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-33);
				}
								public static implicit operator Micrograms(Yottagrams value)
				{
					return (value.value)*1E+30;
				}

				public static Yottagrams operator +(Yottagrams first, Micrograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-30);
				}
								public static implicit operator Milligrams(Yottagrams value)
				{
					return (value.value)*1E+27;
				}

				public static Yottagrams operator +(Yottagrams first, Milligrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centigrams(Yottagrams value)
				{
					return (value.value)*1E+26;
				}

				public static Yottagrams operator +(Yottagrams first, Centigrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-26);
				}
								public static implicit operator Decigrams(Yottagrams value)
				{
					return (value.value)*1E+25;
				}

				public static Yottagrams operator +(Yottagrams first, Decigrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decagrams(Yottagrams value)
				{
					return (value.value)*1E+23;
				}

				public static Yottagrams operator +(Yottagrams first, Decagrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectograms(Yottagrams value)
				{
					return (value.value)*1E+22;
				}

				public static Yottagrams operator +(Yottagrams first, Hectograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kilograms(Yottagrams value)
				{
					return (value.value)*1E+21;
				}

				public static Yottagrams operator +(Yottagrams first, Kilograms second)
				{
					return new Yottagrams(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megagrams(Yottagrams value)
				{
					return (value.value)*1E+18;
				}

				public static Yottagrams operator +(Yottagrams first, Megagrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigagrams(Yottagrams value)
				{
					return (value.value)*1E+15;
				}

				public static Yottagrams operator +(Yottagrams first, Gigagrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-15);
				}
								public static implicit operator Teragrams(Yottagrams value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottagrams operator +(Yottagrams first, Teragrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petagrams(Yottagrams value)
				{
					return (value.value)*1000000000;
				}

				public static Yottagrams operator +(Yottagrams first, Petagrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-09);
				}
								public static implicit operator Exagrams(Yottagrams value)
				{
					return (value.value)*1000000;
				}

				public static Yottagrams operator +(Yottagrams first, Exagrams second)
				{
					return new Yottagrams(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettagrams(Yottagrams value)
				{
					return (value.value)*1000;
				}

				public static Yottagrams operator +(Yottagrams first, Zettagrams second)
				{
					return new Yottagrams(first.value + (second.value)*0.001);
				}
						}
		}

		public struct Amperes : IValueWithUnit, IEquatable< Amperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Amperes Zero = new Amperes(0);
			public static readonly Amperes One = new Amperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.ampere; } }

			public Amperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} A", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Amperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Amperes(double value)
			{
				return new Amperes(value);
			}

			public static Amperes operator *(Amperes value, double times)
			{
				return new Amperes(value.value * times);
			}

			public static Amperes operator *(double times, Amperes value)
			{
				return new Amperes(value.value * times);
			}

			public static Amperes operator +(Amperes first, Amperes second)
			{
				return new Amperes(first.value * second.value);
			}

							public static implicit operator Yoctoamperes(Amperes value)
				{
					return (value.value)/1E-24;
				}

				public static Amperes operator +(Amperes first, Yoctoamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptoamperes(Amperes value)
				{
					return (value.value)/1E-21;
				}

				public static Amperes operator +(Amperes first, Zeptoamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attoamperes(Amperes value)
				{
					return (value.value)/1E-18;
				}

				public static Amperes operator +(Amperes first, Attoamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtoamperes(Amperes value)
				{
					return (value.value)/1E-15;
				}

				public static Amperes operator +(Amperes first, Femtoamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picoamperes(Amperes value)
				{
					return (value.value)/1E-12;
				}

				public static Amperes operator +(Amperes first, Picoamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanoamperes(Amperes value)
				{
					return (value.value)/1E-09;
				}

				public static Amperes operator +(Amperes first, Nanoamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Microamperes(Amperes value)
				{
					return (value.value)/1E-06;
				}

				public static Amperes operator +(Amperes first, Microamperes second)
				{
					return new Amperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Milliamperes(Amperes value)
				{
					return (value.value)/0.001;
				}

				public static Amperes operator +(Amperes first, Milliamperes second)
				{
					return new Amperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Centiamperes(Amperes value)
				{
					return (value.value)/0.01;
				}

				public static Amperes operator +(Amperes first, Centiamperes second)
				{
					return new Amperes(first.value + (second.value)*0.01);
				}
								public static implicit operator Deciamperes(Amperes value)
				{
					return (value.value)/0.1;
				}

				public static Amperes operator +(Amperes first, Deciamperes second)
				{
					return new Amperes(first.value + (second.value)*0.1);
				}
								public static implicit operator Decaamperes(Amperes value)
				{
					return (value.value)/10;
				}

				public static Amperes operator +(Amperes first, Decaamperes second)
				{
					return new Amperes(first.value + (second.value)*10);
				}
								public static implicit operator Hectoamperes(Amperes value)
				{
					return (value.value)/100;
				}

				public static Amperes operator +(Amperes first, Hectoamperes second)
				{
					return new Amperes(first.value + (second.value)*100);
				}
								public static implicit operator Kiloamperes(Amperes value)
				{
					return (value.value)/1000;
				}

				public static Amperes operator +(Amperes first, Kiloamperes second)
				{
					return new Amperes(first.value + (second.value)*1000);
				}
								public static implicit operator Megaamperes(Amperes value)
				{
					return (value.value)/1000000;
				}

				public static Amperes operator +(Amperes first, Megaamperes second)
				{
					return new Amperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigaamperes(Amperes value)
				{
					return (value.value)/1000000000;
				}

				public static Amperes operator +(Amperes first, Gigaamperes second)
				{
					return new Amperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Teraamperes(Amperes value)
				{
					return (value.value)/1000000000000;
				}

				public static Amperes operator +(Amperes first, Teraamperes second)
				{
					return new Amperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petaamperes(Amperes value)
				{
					return (value.value)/1E+15;
				}

				public static Amperes operator +(Amperes first, Petaamperes second)
				{
					return new Amperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Exaamperes(Amperes value)
				{
					return (value.value)/1E+18;
				}

				public static Amperes operator +(Amperes first, Exaamperes second)
				{
					return new Amperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettaamperes(Amperes value)
				{
					return (value.value)/1E+21;
				}

				public static Amperes operator +(Amperes first, Zettaamperes second)
				{
					return new Amperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottaamperes(Amperes value)
				{
					return (value.value)/1E+24;
				}

				public static Amperes operator +(Amperes first, Yottaamperes second)
				{
					return new Amperes(first.value + (second.value)*1E+24);
				}
						}
		namespace Multiples
{

		public struct Yoctoamperes : IValueWithUnit, IEquatable< Yoctoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctoamperes Zero = new Yoctoamperes(0);
			public static readonly Yoctoamperes One = new Yoctoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.yoctoampere; } }

			public Yoctoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} yA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-24);
				}
				
			public bool Equals(Yoctoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctoamperes(double value)
			{
				return new Yoctoamperes(value);
			}

			public static Yoctoamperes operator *(Yoctoamperes value, double times)
			{
				return new Yoctoamperes(value.value * times);
			}

			public static Yoctoamperes operator *(double times, Yoctoamperes value)
			{
				return new Yoctoamperes(value.value * times);
			}

			public static Yoctoamperes operator +(Yoctoamperes first, Yoctoamperes second)
			{
				return new Yoctoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Yoctoamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Amperes second)
				{
					return new Yoctoamperes(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptoamperes(Yoctoamperes value)
				{
					return (value.value)*0.001;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Zeptoamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Attoamperes(Yoctoamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Attoamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtoamperes(Yoctoamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Femtoamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picoamperes(Yoctoamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Picoamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanoamperes(Yoctoamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Nanoamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Microamperes(Yoctoamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Microamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Milliamperes(Yoctoamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Milliamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centiamperes(Yoctoamperes value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Centiamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+22);
				}
								public static implicit operator Deciamperes(Yoctoamperes value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Deciamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Decaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectoamperes(Yoctoamperes value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Hectoamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kiloamperes(Yoctoamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Kiloamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Megaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Gigaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+33);
				}
								public static implicit operator Teraamperes(Yoctoamperes value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Teraamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Petaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+39);
				}
								public static implicit operator Exaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Exaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Zettaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottaamperes(Yoctoamperes value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctoamperes operator +(Yoctoamperes first, Yottaamperes second)
				{
					return new Yoctoamperes(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptoamperes : IValueWithUnit, IEquatable< Zeptoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptoamperes Zero = new Zeptoamperes(0);
			public static readonly Zeptoamperes One = new Zeptoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.zeptoampere; } }

			public Zeptoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-21);
				}
				
			public bool Equals(Zeptoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptoamperes(double value)
			{
				return new Zeptoamperes(value);
			}

			public static Zeptoamperes operator *(Zeptoamperes value, double times)
			{
				return new Zeptoamperes(value.value * times);
			}

			public static Zeptoamperes operator *(double times, Zeptoamperes value)
			{
				return new Zeptoamperes(value.value * times);
			}

			public static Zeptoamperes operator +(Zeptoamperes first, Zeptoamperes second)
			{
				return new Zeptoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Zeptoamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Amperes second)
				{
					return new Zeptoamperes(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctoamperes(Zeptoamperes value)
				{
					return (value.value)*1000;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Yoctoamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Attoamperes(Zeptoamperes value)
				{
					return (value.value)*0.001;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Attoamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Femtoamperes(Zeptoamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Femtoamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Picoamperes(Zeptoamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Picoamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanoamperes(Zeptoamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Nanoamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Microamperes(Zeptoamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Microamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Milliamperes(Zeptoamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Milliamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centiamperes(Zeptoamperes value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Centiamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+19);
				}
								public static implicit operator Deciamperes(Zeptoamperes value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Deciamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Decaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectoamperes(Zeptoamperes value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Hectoamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kiloamperes(Zeptoamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Kiloamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Megaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Gigaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+30);
				}
								public static implicit operator Teraamperes(Zeptoamperes value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Teraamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Petaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+36);
				}
								public static implicit operator Exaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Exaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Zettaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottaamperes(Zeptoamperes value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptoamperes operator +(Zeptoamperes first, Yottaamperes second)
				{
					return new Zeptoamperes(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attoamperes : IValueWithUnit, IEquatable< Attoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Attoamperes Zero = new Attoamperes(0);
			public static readonly Attoamperes One = new Attoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.attoampere; } }

			public Attoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} aA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-18);
				}
				
			public bool Equals(Attoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attoamperes(double value)
			{
				return new Attoamperes(value);
			}

			public static Attoamperes operator *(Attoamperes value, double times)
			{
				return new Attoamperes(value.value * times);
			}

			public static Attoamperes operator *(double times, Attoamperes value)
			{
				return new Attoamperes(value.value * times);
			}

			public static Attoamperes operator +(Attoamperes first, Attoamperes second)
			{
				return new Attoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Attoamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Attoamperes operator +(Attoamperes first, Amperes second)
				{
					return new Attoamperes(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctoamperes(Attoamperes value)
				{
					return (value.value)*1000000;
				}

				public static Attoamperes operator +(Attoamperes first, Yoctoamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptoamperes(Attoamperes value)
				{
					return (value.value)*1000;
				}

				public static Attoamperes operator +(Attoamperes first, Zeptoamperes second)
				{
					return new Attoamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtoamperes(Attoamperes value)
				{
					return (value.value)*0.001;
				}

				public static Attoamperes operator +(Attoamperes first, Femtoamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Picoamperes(Attoamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Attoamperes operator +(Attoamperes first, Picoamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanoamperes(Attoamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Attoamperes operator +(Attoamperes first, Nanoamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Microamperes(Attoamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Attoamperes operator +(Attoamperes first, Microamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Milliamperes(Attoamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Attoamperes operator +(Attoamperes first, Milliamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centiamperes(Attoamperes value)
				{
					return (value.value)*1E-16;
				}

				public static Attoamperes operator +(Attoamperes first, Centiamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+16);
				}
								public static implicit operator Deciamperes(Attoamperes value)
				{
					return (value.value)*1E-17;
				}

				public static Attoamperes operator +(Attoamperes first, Deciamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decaamperes(Attoamperes value)
				{
					return (value.value)*1E-19;
				}

				public static Attoamperes operator +(Attoamperes first, Decaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectoamperes(Attoamperes value)
				{
					return (value.value)*1E-20;
				}

				public static Attoamperes operator +(Attoamperes first, Hectoamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kiloamperes(Attoamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Attoamperes operator +(Attoamperes first, Kiloamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megaamperes(Attoamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Attoamperes operator +(Attoamperes first, Megaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigaamperes(Attoamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Attoamperes operator +(Attoamperes first, Gigaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Teraamperes(Attoamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Attoamperes operator +(Attoamperes first, Teraamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petaamperes(Attoamperes value)
				{
					return (value.value)*1E-33;
				}

				public static Attoamperes operator +(Attoamperes first, Petaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+33);
				}
								public static implicit operator Exaamperes(Attoamperes value)
				{
					return (value.value)*1E-36;
				}

				public static Attoamperes operator +(Attoamperes first, Exaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettaamperes(Attoamperes value)
				{
					return (value.value)*1E-39;
				}

				public static Attoamperes operator +(Attoamperes first, Zettaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottaamperes(Attoamperes value)
				{
					return (value.value)*1E-42;
				}

				public static Attoamperes operator +(Attoamperes first, Yottaamperes second)
				{
					return new Attoamperes(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtoamperes : IValueWithUnit, IEquatable< Femtoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtoamperes Zero = new Femtoamperes(0);
			public static readonly Femtoamperes One = new Femtoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.femtoampere; } }

			public Femtoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-15);
				}
				
			public bool Equals(Femtoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtoamperes(double value)
			{
				return new Femtoamperes(value);
			}

			public static Femtoamperes operator *(Femtoamperes value, double times)
			{
				return new Femtoamperes(value.value * times);
			}

			public static Femtoamperes operator *(double times, Femtoamperes value)
			{
				return new Femtoamperes(value.value * times);
			}

			public static Femtoamperes operator +(Femtoamperes first, Femtoamperes second)
			{
				return new Femtoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Femtoamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Femtoamperes operator +(Femtoamperes first, Amperes second)
				{
					return new Femtoamperes(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctoamperes(Femtoamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Femtoamperes operator +(Femtoamperes first, Yoctoamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptoamperes(Femtoamperes value)
				{
					return (value.value)*1000000;
				}

				public static Femtoamperes operator +(Femtoamperes first, Zeptoamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attoamperes(Femtoamperes value)
				{
					return (value.value)*1000;
				}

				public static Femtoamperes operator +(Femtoamperes first, Attoamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Picoamperes(Femtoamperes value)
				{
					return (value.value)*0.001;
				}

				public static Femtoamperes operator +(Femtoamperes first, Picoamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Nanoamperes(Femtoamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Femtoamperes operator +(Femtoamperes first, Nanoamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Microamperes(Femtoamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Femtoamperes operator +(Femtoamperes first, Microamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Milliamperes(Femtoamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Femtoamperes operator +(Femtoamperes first, Milliamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centiamperes(Femtoamperes value)
				{
					return (value.value)*1E-13;
				}

				public static Femtoamperes operator +(Femtoamperes first, Centiamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Deciamperes(Femtoamperes value)
				{
					return (value.value)*1E-14;
				}

				public static Femtoamperes operator +(Femtoamperes first, Deciamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decaamperes(Femtoamperes value)
				{
					return (value.value)*1E-16;
				}

				public static Femtoamperes operator +(Femtoamperes first, Decaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectoamperes(Femtoamperes value)
				{
					return (value.value)*1E-17;
				}

				public static Femtoamperes operator +(Femtoamperes first, Hectoamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kiloamperes(Femtoamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Femtoamperes operator +(Femtoamperes first, Kiloamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megaamperes(Femtoamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Femtoamperes operator +(Femtoamperes first, Megaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigaamperes(Femtoamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Femtoamperes operator +(Femtoamperes first, Gigaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Teraamperes(Femtoamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Femtoamperes operator +(Femtoamperes first, Teraamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petaamperes(Femtoamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Femtoamperes operator +(Femtoamperes first, Petaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+30);
				}
								public static implicit operator Exaamperes(Femtoamperes value)
				{
					return (value.value)*1E-33;
				}

				public static Femtoamperes operator +(Femtoamperes first, Exaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettaamperes(Femtoamperes value)
				{
					return (value.value)*1E-36;
				}

				public static Femtoamperes operator +(Femtoamperes first, Zettaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottaamperes(Femtoamperes value)
				{
					return (value.value)*1E-39;
				}

				public static Femtoamperes operator +(Femtoamperes first, Yottaamperes second)
				{
					return new Femtoamperes(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picoamperes : IValueWithUnit, IEquatable< Picoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Picoamperes Zero = new Picoamperes(0);
			public static readonly Picoamperes One = new Picoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.picoampere; } }

			public Picoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} pA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-12);
				}
				
			public bool Equals(Picoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picoamperes(double value)
			{
				return new Picoamperes(value);
			}

			public static Picoamperes operator *(Picoamperes value, double times)
			{
				return new Picoamperes(value.value * times);
			}

			public static Picoamperes operator *(double times, Picoamperes value)
			{
				return new Picoamperes(value.value * times);
			}

			public static Picoamperes operator +(Picoamperes first, Picoamperes second)
			{
				return new Picoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Picoamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Picoamperes operator +(Picoamperes first, Amperes second)
				{
					return new Picoamperes(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctoamperes(Picoamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Picoamperes operator +(Picoamperes first, Yoctoamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptoamperes(Picoamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Picoamperes operator +(Picoamperes first, Zeptoamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attoamperes(Picoamperes value)
				{
					return (value.value)*1000000;
				}

				public static Picoamperes operator +(Picoamperes first, Attoamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtoamperes(Picoamperes value)
				{
					return (value.value)*1000;
				}

				public static Picoamperes operator +(Picoamperes first, Femtoamperes second)
				{
					return new Picoamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanoamperes(Picoamperes value)
				{
					return (value.value)*0.001;
				}

				public static Picoamperes operator +(Picoamperes first, Nanoamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Microamperes(Picoamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Picoamperes operator +(Picoamperes first, Microamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Milliamperes(Picoamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Picoamperes operator +(Picoamperes first, Milliamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centiamperes(Picoamperes value)
				{
					return (value.value)*1E-10;
				}

				public static Picoamperes operator +(Picoamperes first, Centiamperes second)
				{
					return new Picoamperes(first.value + (second.value)*10000000000);
				}
								public static implicit operator Deciamperes(Picoamperes value)
				{
					return (value.value)*1E-11;
				}

				public static Picoamperes operator +(Picoamperes first, Deciamperes second)
				{
					return new Picoamperes(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decaamperes(Picoamperes value)
				{
					return (value.value)*1E-13;
				}

				public static Picoamperes operator +(Picoamperes first, Decaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectoamperes(Picoamperes value)
				{
					return (value.value)*1E-14;
				}

				public static Picoamperes operator +(Picoamperes first, Hectoamperes second)
				{
					return new Picoamperes(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kiloamperes(Picoamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Picoamperes operator +(Picoamperes first, Kiloamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megaamperes(Picoamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Picoamperes operator +(Picoamperes first, Megaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigaamperes(Picoamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Picoamperes operator +(Picoamperes first, Gigaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Teraamperes(Picoamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Picoamperes operator +(Picoamperes first, Teraamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petaamperes(Picoamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Picoamperes operator +(Picoamperes first, Petaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Exaamperes(Picoamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Picoamperes operator +(Picoamperes first, Exaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettaamperes(Picoamperes value)
				{
					return (value.value)*1E-33;
				}

				public static Picoamperes operator +(Picoamperes first, Zettaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottaamperes(Picoamperes value)
				{
					return (value.value)*1E-36;
				}

				public static Picoamperes operator +(Picoamperes first, Yottaamperes second)
				{
					return new Picoamperes(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanoamperes : IValueWithUnit, IEquatable< Nanoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanoamperes Zero = new Nanoamperes(0);
			public static readonly Nanoamperes One = new Nanoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.nanoampere; } }

			public Nanoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} nA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-09);
				}
				
			public bool Equals(Nanoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanoamperes(double value)
			{
				return new Nanoamperes(value);
			}

			public static Nanoamperes operator *(Nanoamperes value, double times)
			{
				return new Nanoamperes(value.value * times);
			}

			public static Nanoamperes operator *(double times, Nanoamperes value)
			{
				return new Nanoamperes(value.value * times);
			}

			public static Nanoamperes operator +(Nanoamperes first, Nanoamperes second)
			{
				return new Nanoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Nanoamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Nanoamperes operator +(Nanoamperes first, Amperes second)
				{
					return new Nanoamperes(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctoamperes(Nanoamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Nanoamperes operator +(Nanoamperes first, Yoctoamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptoamperes(Nanoamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanoamperes operator +(Nanoamperes first, Zeptoamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attoamperes(Nanoamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Nanoamperes operator +(Nanoamperes first, Attoamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtoamperes(Nanoamperes value)
				{
					return (value.value)*1000000;
				}

				public static Nanoamperes operator +(Nanoamperes first, Femtoamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picoamperes(Nanoamperes value)
				{
					return (value.value)*1000;
				}

				public static Nanoamperes operator +(Nanoamperes first, Picoamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Microamperes(Nanoamperes value)
				{
					return (value.value)*0.001;
				}

				public static Nanoamperes operator +(Nanoamperes first, Microamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Milliamperes(Nanoamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Nanoamperes operator +(Nanoamperes first, Milliamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Centiamperes(Nanoamperes value)
				{
					return (value.value)*1E-07;
				}

				public static Nanoamperes operator +(Nanoamperes first, Centiamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*10000000);
				}
								public static implicit operator Deciamperes(Nanoamperes value)
				{
					return (value.value)*1E-08;
				}

				public static Nanoamperes operator +(Nanoamperes first, Deciamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*100000000);
				}
								public static implicit operator Decaamperes(Nanoamperes value)
				{
					return (value.value)*1E-10;
				}

				public static Nanoamperes operator +(Nanoamperes first, Decaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectoamperes(Nanoamperes value)
				{
					return (value.value)*1E-11;
				}

				public static Nanoamperes operator +(Nanoamperes first, Hectoamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kiloamperes(Nanoamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Nanoamperes operator +(Nanoamperes first, Kiloamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megaamperes(Nanoamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Nanoamperes operator +(Nanoamperes first, Megaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigaamperes(Nanoamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Nanoamperes operator +(Nanoamperes first, Gigaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Teraamperes(Nanoamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Nanoamperes operator +(Nanoamperes first, Teraamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petaamperes(Nanoamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Nanoamperes operator +(Nanoamperes first, Petaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Exaamperes(Nanoamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Nanoamperes operator +(Nanoamperes first, Exaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettaamperes(Nanoamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Nanoamperes operator +(Nanoamperes first, Zettaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottaamperes(Nanoamperes value)
				{
					return (value.value)*1E-33;
				}

				public static Nanoamperes operator +(Nanoamperes first, Yottaamperes second)
				{
					return new Nanoamperes(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Microamperes : IValueWithUnit, IEquatable< Microamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Microamperes Zero = new Microamperes(0);
			public static readonly Microamperes One = new Microamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.microampere; } }

			public Microamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E-06);
				}
				
			public bool Equals(Microamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Microamperes(double value)
			{
				return new Microamperes(value);
			}

			public static Microamperes operator *(Microamperes value, double times)
			{
				return new Microamperes(value.value * times);
			}

			public static Microamperes operator *(double times, Microamperes value)
			{
				return new Microamperes(value.value * times);
			}

			public static Microamperes operator +(Microamperes first, Microamperes second)
			{
				return new Microamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Microamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Microamperes operator +(Microamperes first, Amperes second)
				{
					return new Microamperes(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctoamperes(Microamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Microamperes operator +(Microamperes first, Yoctoamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptoamperes(Microamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Microamperes operator +(Microamperes first, Zeptoamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attoamperes(Microamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Microamperes operator +(Microamperes first, Attoamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtoamperes(Microamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Microamperes operator +(Microamperes first, Femtoamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picoamperes(Microamperes value)
				{
					return (value.value)*1000000;
				}

				public static Microamperes operator +(Microamperes first, Picoamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanoamperes(Microamperes value)
				{
					return (value.value)*1000;
				}

				public static Microamperes operator +(Microamperes first, Nanoamperes second)
				{
					return new Microamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Milliamperes(Microamperes value)
				{
					return (value.value)*0.001;
				}

				public static Microamperes operator +(Microamperes first, Milliamperes second)
				{
					return new Microamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Centiamperes(Microamperes value)
				{
					return (value.value)*0.0001;
				}

				public static Microamperes operator +(Microamperes first, Centiamperes second)
				{
					return new Microamperes(first.value + (second.value)*10000);
				}
								public static implicit operator Deciamperes(Microamperes value)
				{
					return (value.value)*1E-05;
				}

				public static Microamperes operator +(Microamperes first, Deciamperes second)
				{
					return new Microamperes(first.value + (second.value)*100000);
				}
								public static implicit operator Decaamperes(Microamperes value)
				{
					return (value.value)*1E-07;
				}

				public static Microamperes operator +(Microamperes first, Decaamperes second)
				{
					return new Microamperes(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectoamperes(Microamperes value)
				{
					return (value.value)*1E-08;
				}

				public static Microamperes operator +(Microamperes first, Hectoamperes second)
				{
					return new Microamperes(first.value + (second.value)*100000000);
				}
								public static implicit operator Kiloamperes(Microamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Microamperes operator +(Microamperes first, Kiloamperes second)
				{
					return new Microamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megaamperes(Microamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Microamperes operator +(Microamperes first, Megaamperes second)
				{
					return new Microamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigaamperes(Microamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Microamperes operator +(Microamperes first, Gigaamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Teraamperes(Microamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Microamperes operator +(Microamperes first, Teraamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petaamperes(Microamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Microamperes operator +(Microamperes first, Petaamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Exaamperes(Microamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Microamperes operator +(Microamperes first, Exaamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettaamperes(Microamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Microamperes operator +(Microamperes first, Zettaamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottaamperes(Microamperes value)
				{
					return (value.value)*1E-30;
				}

				public static Microamperes operator +(Microamperes first, Yottaamperes second)
				{
					return new Microamperes(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Milliamperes : IValueWithUnit, IEquatable< Milliamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Milliamperes Zero = new Milliamperes(0);
			public static readonly Milliamperes One = new Milliamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.milliampere; } }

			public Milliamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*0.001);
				}
				
			public bool Equals(Milliamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Milliamperes(double value)
			{
				return new Milliamperes(value);
			}

			public static Milliamperes operator *(Milliamperes value, double times)
			{
				return new Milliamperes(value.value * times);
			}

			public static Milliamperes operator *(double times, Milliamperes value)
			{
				return new Milliamperes(value.value * times);
			}

			public static Milliamperes operator +(Milliamperes first, Milliamperes second)
			{
				return new Milliamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Milliamperes value)
				{
					return (value.value)*0.001;
				}

				public static Milliamperes operator +(Milliamperes first, Amperes second)
				{
					return new Milliamperes(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctoamperes(Milliamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Milliamperes operator +(Milliamperes first, Yoctoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptoamperes(Milliamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Milliamperes operator +(Milliamperes first, Zeptoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attoamperes(Milliamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Milliamperes operator +(Milliamperes first, Attoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtoamperes(Milliamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Milliamperes operator +(Milliamperes first, Femtoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picoamperes(Milliamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Milliamperes operator +(Milliamperes first, Picoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanoamperes(Milliamperes value)
				{
					return (value.value)*1000000;
				}

				public static Milliamperes operator +(Milliamperes first, Nanoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Microamperes(Milliamperes value)
				{
					return (value.value)*1000;
				}

				public static Milliamperes operator +(Milliamperes first, Microamperes second)
				{
					return new Milliamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Centiamperes(Milliamperes value)
				{
					return (value.value)*0.1;
				}

				public static Milliamperes operator +(Milliamperes first, Centiamperes second)
				{
					return new Milliamperes(first.value + (second.value)*10);
				}
								public static implicit operator Deciamperes(Milliamperes value)
				{
					return (value.value)*0.01;
				}

				public static Milliamperes operator +(Milliamperes first, Deciamperes second)
				{
					return new Milliamperes(first.value + (second.value)*100);
				}
								public static implicit operator Decaamperes(Milliamperes value)
				{
					return (value.value)*0.0001;
				}

				public static Milliamperes operator +(Milliamperes first, Decaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*10000);
				}
								public static implicit operator Hectoamperes(Milliamperes value)
				{
					return (value.value)*1E-05;
				}

				public static Milliamperes operator +(Milliamperes first, Hectoamperes second)
				{
					return new Milliamperes(first.value + (second.value)*100000);
				}
								public static implicit operator Kiloamperes(Milliamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Milliamperes operator +(Milliamperes first, Kiloamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Megaamperes(Milliamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Milliamperes operator +(Milliamperes first, Megaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigaamperes(Milliamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Milliamperes operator +(Milliamperes first, Gigaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Teraamperes(Milliamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Milliamperes operator +(Milliamperes first, Teraamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petaamperes(Milliamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Milliamperes operator +(Milliamperes first, Petaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Exaamperes(Milliamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Milliamperes operator +(Milliamperes first, Exaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettaamperes(Milliamperes value)
				{
					return (value.value)*1E-24;
				}

				public static Milliamperes operator +(Milliamperes first, Zettaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottaamperes(Milliamperes value)
				{
					return (value.value)*1E-27;
				}

				public static Milliamperes operator +(Milliamperes first, Yottaamperes second)
				{
					return new Milliamperes(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centiamperes : IValueWithUnit, IEquatable< Centiamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Centiamperes Zero = new Centiamperes(0);
			public static readonly Centiamperes One = new Centiamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.centiampere; } }

			public Centiamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*0.01);
				}
				
			public bool Equals(Centiamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centiamperes(double value)
			{
				return new Centiamperes(value);
			}

			public static Centiamperes operator *(Centiamperes value, double times)
			{
				return new Centiamperes(value.value * times);
			}

			public static Centiamperes operator *(double times, Centiamperes value)
			{
				return new Centiamperes(value.value * times);
			}

			public static Centiamperes operator +(Centiamperes first, Centiamperes second)
			{
				return new Centiamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Centiamperes value)
				{
					return (value.value)*0.01;
				}

				public static Centiamperes operator +(Centiamperes first, Amperes second)
				{
					return new Centiamperes(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctoamperes(Centiamperes value)
				{
					return (value.value)*1E+22;
				}

				public static Centiamperes operator +(Centiamperes first, Yoctoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptoamperes(Centiamperes value)
				{
					return (value.value)*1E+19;
				}

				public static Centiamperes operator +(Centiamperes first, Zeptoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attoamperes(Centiamperes value)
				{
					return (value.value)*1E+16;
				}

				public static Centiamperes operator +(Centiamperes first, Attoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtoamperes(Centiamperes value)
				{
					return (value.value)*10000000000000;
				}

				public static Centiamperes operator +(Centiamperes first, Femtoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picoamperes(Centiamperes value)
				{
					return (value.value)*10000000000;
				}

				public static Centiamperes operator +(Centiamperes first, Picoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanoamperes(Centiamperes value)
				{
					return (value.value)*10000000;
				}

				public static Centiamperes operator +(Centiamperes first, Nanoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E-07);
				}
								public static implicit operator Microamperes(Centiamperes value)
				{
					return (value.value)*10000;
				}

				public static Centiamperes operator +(Centiamperes first, Microamperes second)
				{
					return new Centiamperes(first.value + (second.value)*0.0001);
				}
								public static implicit operator Milliamperes(Centiamperes value)
				{
					return (value.value)*10;
				}

				public static Centiamperes operator +(Centiamperes first, Milliamperes second)
				{
					return new Centiamperes(first.value + (second.value)*0.1);
				}
								public static implicit operator Deciamperes(Centiamperes value)
				{
					return (value.value)*0.1;
				}

				public static Centiamperes operator +(Centiamperes first, Deciamperes second)
				{
					return new Centiamperes(first.value + (second.value)*10);
				}
								public static implicit operator Decaamperes(Centiamperes value)
				{
					return (value.value)*0.001;
				}

				public static Centiamperes operator +(Centiamperes first, Decaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Hectoamperes(Centiamperes value)
				{
					return (value.value)*0.0001;
				}

				public static Centiamperes operator +(Centiamperes first, Hectoamperes second)
				{
					return new Centiamperes(first.value + (second.value)*10000);
				}
								public static implicit operator Kiloamperes(Centiamperes value)
				{
					return (value.value)*1E-05;
				}

				public static Centiamperes operator +(Centiamperes first, Kiloamperes second)
				{
					return new Centiamperes(first.value + (second.value)*100000);
				}
								public static implicit operator Megaamperes(Centiamperes value)
				{
					return (value.value)*1E-08;
				}

				public static Centiamperes operator +(Centiamperes first, Megaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigaamperes(Centiamperes value)
				{
					return (value.value)*1E-11;
				}

				public static Centiamperes operator +(Centiamperes first, Gigaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*100000000000);
				}
								public static implicit operator Teraamperes(Centiamperes value)
				{
					return (value.value)*1E-14;
				}

				public static Centiamperes operator +(Centiamperes first, Teraamperes second)
				{
					return new Centiamperes(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petaamperes(Centiamperes value)
				{
					return (value.value)*1E-17;
				}

				public static Centiamperes operator +(Centiamperes first, Petaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E+17);
				}
								public static implicit operator Exaamperes(Centiamperes value)
				{
					return (value.value)*1E-20;
				}

				public static Centiamperes operator +(Centiamperes first, Exaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettaamperes(Centiamperes value)
				{
					return (value.value)*1E-23;
				}

				public static Centiamperes operator +(Centiamperes first, Zettaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottaamperes(Centiamperes value)
				{
					return (value.value)*1E-26;
				}

				public static Centiamperes operator +(Centiamperes first, Yottaamperes second)
				{
					return new Centiamperes(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Deciamperes : IValueWithUnit, IEquatable< Deciamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Deciamperes Zero = new Deciamperes(0);
			public static readonly Deciamperes One = new Deciamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.deciampere; } }

			public Deciamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*0.1);
				}
				
			public bool Equals(Deciamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Deciamperes(double value)
			{
				return new Deciamperes(value);
			}

			public static Deciamperes operator *(Deciamperes value, double times)
			{
				return new Deciamperes(value.value * times);
			}

			public static Deciamperes operator *(double times, Deciamperes value)
			{
				return new Deciamperes(value.value * times);
			}

			public static Deciamperes operator +(Deciamperes first, Deciamperes second)
			{
				return new Deciamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Deciamperes value)
				{
					return (value.value)*0.1;
				}

				public static Deciamperes operator +(Deciamperes first, Amperes second)
				{
					return new Deciamperes(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctoamperes(Deciamperes value)
				{
					return (value.value)*1E+23;
				}

				public static Deciamperes operator +(Deciamperes first, Yoctoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptoamperes(Deciamperes value)
				{
					return (value.value)*1E+20;
				}

				public static Deciamperes operator +(Deciamperes first, Zeptoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attoamperes(Deciamperes value)
				{
					return (value.value)*1E+17;
				}

				public static Deciamperes operator +(Deciamperes first, Attoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtoamperes(Deciamperes value)
				{
					return (value.value)*100000000000000;
				}

				public static Deciamperes operator +(Deciamperes first, Femtoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picoamperes(Deciamperes value)
				{
					return (value.value)*100000000000;
				}

				public static Deciamperes operator +(Deciamperes first, Picoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanoamperes(Deciamperes value)
				{
					return (value.value)*100000000;
				}

				public static Deciamperes operator +(Deciamperes first, Nanoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-08);
				}
								public static implicit operator Microamperes(Deciamperes value)
				{
					return (value.value)*100000;
				}

				public static Deciamperes operator +(Deciamperes first, Microamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E-05);
				}
								public static implicit operator Milliamperes(Deciamperes value)
				{
					return (value.value)*100;
				}

				public static Deciamperes operator +(Deciamperes first, Milliamperes second)
				{
					return new Deciamperes(first.value + (second.value)*0.01);
				}
								public static implicit operator Centiamperes(Deciamperes value)
				{
					return (value.value)*10;
				}

				public static Deciamperes operator +(Deciamperes first, Centiamperes second)
				{
					return new Deciamperes(first.value + (second.value)*0.1);
				}
								public static implicit operator Decaamperes(Deciamperes value)
				{
					return (value.value)*0.01;
				}

				public static Deciamperes operator +(Deciamperes first, Decaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*100);
				}
								public static implicit operator Hectoamperes(Deciamperes value)
				{
					return (value.value)*0.001;
				}

				public static Deciamperes operator +(Deciamperes first, Hectoamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Kiloamperes(Deciamperes value)
				{
					return (value.value)*0.0001;
				}

				public static Deciamperes operator +(Deciamperes first, Kiloamperes second)
				{
					return new Deciamperes(first.value + (second.value)*10000);
				}
								public static implicit operator Megaamperes(Deciamperes value)
				{
					return (value.value)*1E-07;
				}

				public static Deciamperes operator +(Deciamperes first, Megaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigaamperes(Deciamperes value)
				{
					return (value.value)*1E-10;
				}

				public static Deciamperes operator +(Deciamperes first, Gigaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*10000000000);
				}
								public static implicit operator Teraamperes(Deciamperes value)
				{
					return (value.value)*1E-13;
				}

				public static Deciamperes operator +(Deciamperes first, Teraamperes second)
				{
					return new Deciamperes(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petaamperes(Deciamperes value)
				{
					return (value.value)*1E-16;
				}

				public static Deciamperes operator +(Deciamperes first, Petaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E+16);
				}
								public static implicit operator Exaamperes(Deciamperes value)
				{
					return (value.value)*1E-19;
				}

				public static Deciamperes operator +(Deciamperes first, Exaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettaamperes(Deciamperes value)
				{
					return (value.value)*1E-22;
				}

				public static Deciamperes operator +(Deciamperes first, Zettaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottaamperes(Deciamperes value)
				{
					return (value.value)*1E-25;
				}

				public static Deciamperes operator +(Deciamperes first, Yottaamperes second)
				{
					return new Deciamperes(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decaamperes : IValueWithUnit, IEquatable< Decaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Decaamperes Zero = new Decaamperes(0);
			public static readonly Decaamperes One = new Decaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.decaampere; } }

			public Decaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} daA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*10);
				}
				
			public bool Equals(Decaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decaamperes(double value)
			{
				return new Decaamperes(value);
			}

			public static Decaamperes operator *(Decaamperes value, double times)
			{
				return new Decaamperes(value.value * times);
			}

			public static Decaamperes operator *(double times, Decaamperes value)
			{
				return new Decaamperes(value.value * times);
			}

			public static Decaamperes operator +(Decaamperes first, Decaamperes second)
			{
				return new Decaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Decaamperes value)
				{
					return (value.value)*10;
				}

				public static Decaamperes operator +(Decaamperes first, Amperes second)
				{
					return new Decaamperes(first.value + (second.value)/10);
				}
								public static implicit operator Yoctoamperes(Decaamperes value)
				{
					return (value.value)*1E+25;
				}

				public static Decaamperes operator +(Decaamperes first, Yoctoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptoamperes(Decaamperes value)
				{
					return (value.value)*1E+22;
				}

				public static Decaamperes operator +(Decaamperes first, Zeptoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attoamperes(Decaamperes value)
				{
					return (value.value)*1E+19;
				}

				public static Decaamperes operator +(Decaamperes first, Attoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtoamperes(Decaamperes value)
				{
					return (value.value)*1E+16;
				}

				public static Decaamperes operator +(Decaamperes first, Femtoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picoamperes(Decaamperes value)
				{
					return (value.value)*10000000000000;
				}

				public static Decaamperes operator +(Decaamperes first, Picoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanoamperes(Decaamperes value)
				{
					return (value.value)*10000000000;
				}

				public static Decaamperes operator +(Decaamperes first, Nanoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-10);
				}
								public static implicit operator Microamperes(Decaamperes value)
				{
					return (value.value)*10000000;
				}

				public static Decaamperes operator +(Decaamperes first, Microamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E-07);
				}
								public static implicit operator Milliamperes(Decaamperes value)
				{
					return (value.value)*10000;
				}

				public static Decaamperes operator +(Decaamperes first, Milliamperes second)
				{
					return new Decaamperes(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centiamperes(Decaamperes value)
				{
					return (value.value)*1000;
				}

				public static Decaamperes operator +(Decaamperes first, Centiamperes second)
				{
					return new Decaamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Deciamperes(Decaamperes value)
				{
					return (value.value)*100;
				}

				public static Decaamperes operator +(Decaamperes first, Deciamperes second)
				{
					return new Decaamperes(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectoamperes(Decaamperes value)
				{
					return (value.value)*0.1;
				}

				public static Decaamperes operator +(Decaamperes first, Hectoamperes second)
				{
					return new Decaamperes(first.value + (second.value)*10);
				}
								public static implicit operator Kiloamperes(Decaamperes value)
				{
					return (value.value)*0.01;
				}

				public static Decaamperes operator +(Decaamperes first, Kiloamperes second)
				{
					return new Decaamperes(first.value + (second.value)*100);
				}
								public static implicit operator Megaamperes(Decaamperes value)
				{
					return (value.value)*1E-05;
				}

				public static Decaamperes operator +(Decaamperes first, Megaamperes second)
				{
					return new Decaamperes(first.value + (second.value)*100000);
				}
								public static implicit operator Gigaamperes(Decaamperes value)
				{
					return (value.value)*1E-08;
				}

				public static Decaamperes operator +(Decaamperes first, Gigaamperes second)
				{
					return new Decaamperes(first.value + (second.value)*100000000);
				}
								public static implicit operator Teraamperes(Decaamperes value)
				{
					return (value.value)*1E-11;
				}

				public static Decaamperes operator +(Decaamperes first, Teraamperes second)
				{
					return new Decaamperes(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petaamperes(Decaamperes value)
				{
					return (value.value)*1E-14;
				}

				public static Decaamperes operator +(Decaamperes first, Petaamperes second)
				{
					return new Decaamperes(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Exaamperes(Decaamperes value)
				{
					return (value.value)*1E-17;
				}

				public static Decaamperes operator +(Decaamperes first, Exaamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettaamperes(Decaamperes value)
				{
					return (value.value)*1E-20;
				}

				public static Decaamperes operator +(Decaamperes first, Zettaamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottaamperes(Decaamperes value)
				{
					return (value.value)*1E-23;
				}

				public static Decaamperes operator +(Decaamperes first, Yottaamperes second)
				{
					return new Decaamperes(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectoamperes : IValueWithUnit, IEquatable< Hectoamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectoamperes Zero = new Hectoamperes(0);
			public static readonly Hectoamperes One = new Hectoamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.hectoampere; } }

			public Hectoamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*100);
				}
				
			public bool Equals(Hectoamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectoamperes(double value)
			{
				return new Hectoamperes(value);
			}

			public static Hectoamperes operator *(Hectoamperes value, double times)
			{
				return new Hectoamperes(value.value * times);
			}

			public static Hectoamperes operator *(double times, Hectoamperes value)
			{
				return new Hectoamperes(value.value * times);
			}

			public static Hectoamperes operator +(Hectoamperes first, Hectoamperes second)
			{
				return new Hectoamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Hectoamperes value)
				{
					return (value.value)*100;
				}

				public static Hectoamperes operator +(Hectoamperes first, Amperes second)
				{
					return new Hectoamperes(first.value + (second.value)/100);
				}
								public static implicit operator Yoctoamperes(Hectoamperes value)
				{
					return (value.value)*1E+26;
				}

				public static Hectoamperes operator +(Hectoamperes first, Yoctoamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptoamperes(Hectoamperes value)
				{
					return (value.value)*1E+23;
				}

				public static Hectoamperes operator +(Hectoamperes first, Zeptoamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attoamperes(Hectoamperes value)
				{
					return (value.value)*1E+20;
				}

				public static Hectoamperes operator +(Hectoamperes first, Attoamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtoamperes(Hectoamperes value)
				{
					return (value.value)*1E+17;
				}

				public static Hectoamperes operator +(Hectoamperes first, Femtoamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picoamperes(Hectoamperes value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectoamperes operator +(Hectoamperes first, Picoamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanoamperes(Hectoamperes value)
				{
					return (value.value)*100000000000;
				}

				public static Hectoamperes operator +(Hectoamperes first, Nanoamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-11);
				}
								public static implicit operator Microamperes(Hectoamperes value)
				{
					return (value.value)*100000000;
				}

				public static Hectoamperes operator +(Hectoamperes first, Microamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-08);
				}
								public static implicit operator Milliamperes(Hectoamperes value)
				{
					return (value.value)*100000;
				}

				public static Hectoamperes operator +(Hectoamperes first, Milliamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centiamperes(Hectoamperes value)
				{
					return (value.value)*10000;
				}

				public static Hectoamperes operator +(Hectoamperes first, Centiamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*0.0001);
				}
								public static implicit operator Deciamperes(Hectoamperes value)
				{
					return (value.value)*1000;
				}

				public static Hectoamperes operator +(Hectoamperes first, Deciamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Decaamperes(Hectoamperes value)
				{
					return (value.value)*10;
				}

				public static Hectoamperes operator +(Hectoamperes first, Decaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*0.1);
				}
								public static implicit operator Kiloamperes(Hectoamperes value)
				{
					return (value.value)*0.1;
				}

				public static Hectoamperes operator +(Hectoamperes first, Kiloamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*10);
				}
								public static implicit operator Megaamperes(Hectoamperes value)
				{
					return (value.value)*0.0001;
				}

				public static Hectoamperes operator +(Hectoamperes first, Megaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*10000);
				}
								public static implicit operator Gigaamperes(Hectoamperes value)
				{
					return (value.value)*1E-07;
				}

				public static Hectoamperes operator +(Hectoamperes first, Gigaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*10000000);
				}
								public static implicit operator Teraamperes(Hectoamperes value)
				{
					return (value.value)*1E-10;
				}

				public static Hectoamperes operator +(Hectoamperes first, Teraamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petaamperes(Hectoamperes value)
				{
					return (value.value)*1E-13;
				}

				public static Hectoamperes operator +(Hectoamperes first, Petaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Exaamperes(Hectoamperes value)
				{
					return (value.value)*1E-16;
				}

				public static Hectoamperes operator +(Hectoamperes first, Exaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettaamperes(Hectoamperes value)
				{
					return (value.value)*1E-19;
				}

				public static Hectoamperes operator +(Hectoamperes first, Zettaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottaamperes(Hectoamperes value)
				{
					return (value.value)*1E-22;
				}

				public static Hectoamperes operator +(Hectoamperes first, Yottaamperes second)
				{
					return new Hectoamperes(first.value + (second.value)*1E+22);
				}
						}
		}
namespace Multiples
{

		public struct Kiloamperes : IValueWithUnit, IEquatable< Kiloamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Kiloamperes Zero = new Kiloamperes(0);
			public static readonly Kiloamperes One = new Kiloamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.kiloampere; } }

			public Kiloamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} kA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1000);
				}
				
			public bool Equals(Kiloamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kiloamperes(double value)
			{
				return new Kiloamperes(value);
			}

			public static Kiloamperes operator *(Kiloamperes value, double times)
			{
				return new Kiloamperes(value.value * times);
			}

			public static Kiloamperes operator *(double times, Kiloamperes value)
			{
				return new Kiloamperes(value.value * times);
			}

			public static Kiloamperes operator +(Kiloamperes first, Kiloamperes second)
			{
				return new Kiloamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Kiloamperes value)
				{
					return (value.value)*1000;
				}

				public static Kiloamperes operator +(Kiloamperes first, Amperes second)
				{
					return new Kiloamperes(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctoamperes(Kiloamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Kiloamperes operator +(Kiloamperes first, Yoctoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptoamperes(Kiloamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Kiloamperes operator +(Kiloamperes first, Zeptoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attoamperes(Kiloamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Kiloamperes operator +(Kiloamperes first, Attoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtoamperes(Kiloamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Kiloamperes operator +(Kiloamperes first, Femtoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picoamperes(Kiloamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Kiloamperes operator +(Kiloamperes first, Picoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanoamperes(Kiloamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Kiloamperes operator +(Kiloamperes first, Nanoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Microamperes(Kiloamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Kiloamperes operator +(Kiloamperes first, Microamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Milliamperes(Kiloamperes value)
				{
					return (value.value)*1000000;
				}

				public static Kiloamperes operator +(Kiloamperes first, Milliamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centiamperes(Kiloamperes value)
				{
					return (value.value)*100000;
				}

				public static Kiloamperes operator +(Kiloamperes first, Centiamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E-05);
				}
								public static implicit operator Deciamperes(Kiloamperes value)
				{
					return (value.value)*10000;
				}

				public static Kiloamperes operator +(Kiloamperes first, Deciamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decaamperes(Kiloamperes value)
				{
					return (value.value)*100;
				}

				public static Kiloamperes operator +(Kiloamperes first, Decaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectoamperes(Kiloamperes value)
				{
					return (value.value)*10;
				}

				public static Kiloamperes operator +(Kiloamperes first, Hectoamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*0.1);
				}
								public static implicit operator Megaamperes(Kiloamperes value)
				{
					return (value.value)*0.001;
				}

				public static Kiloamperes operator +(Kiloamperes first, Megaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Gigaamperes(Kiloamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Kiloamperes operator +(Kiloamperes first, Gigaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Teraamperes(Kiloamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Kiloamperes operator +(Kiloamperes first, Teraamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petaamperes(Kiloamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Kiloamperes operator +(Kiloamperes first, Petaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Exaamperes(Kiloamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Kiloamperes operator +(Kiloamperes first, Exaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettaamperes(Kiloamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Kiloamperes operator +(Kiloamperes first, Zettaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottaamperes(Kiloamperes value)
				{
					return (value.value)*1E-21;
				}

				public static Kiloamperes operator +(Kiloamperes first, Yottaamperes second)
				{
					return new Kiloamperes(first.value + (second.value)*1E+21);
				}
						}
		}
namespace Multiples
{

		public struct Megaamperes : IValueWithUnit, IEquatable< Megaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Megaamperes Zero = new Megaamperes(0);
			public static readonly Megaamperes One = new Megaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.megaampere; } }

			public Megaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} MA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1000000);
				}
				
			public bool Equals(Megaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megaamperes(double value)
			{
				return new Megaamperes(value);
			}

			public static Megaamperes operator *(Megaamperes value, double times)
			{
				return new Megaamperes(value.value * times);
			}

			public static Megaamperes operator *(double times, Megaamperes value)
			{
				return new Megaamperes(value.value * times);
			}

			public static Megaamperes operator +(Megaamperes first, Megaamperes second)
			{
				return new Megaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Megaamperes value)
				{
					return (value.value)*1000000;
				}

				public static Megaamperes operator +(Megaamperes first, Amperes second)
				{
					return new Megaamperes(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctoamperes(Megaamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Megaamperes operator +(Megaamperes first, Yoctoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptoamperes(Megaamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Megaamperes operator +(Megaamperes first, Zeptoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attoamperes(Megaamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Megaamperes operator +(Megaamperes first, Attoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtoamperes(Megaamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Megaamperes operator +(Megaamperes first, Femtoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picoamperes(Megaamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Megaamperes operator +(Megaamperes first, Picoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanoamperes(Megaamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Megaamperes operator +(Megaamperes first, Nanoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Microamperes(Megaamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Megaamperes operator +(Megaamperes first, Microamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Milliamperes(Megaamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Megaamperes operator +(Megaamperes first, Milliamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centiamperes(Megaamperes value)
				{
					return (value.value)*100000000;
				}

				public static Megaamperes operator +(Megaamperes first, Centiamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-08);
				}
								public static implicit operator Deciamperes(Megaamperes value)
				{
					return (value.value)*10000000;
				}

				public static Megaamperes operator +(Megaamperes first, Deciamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decaamperes(Megaamperes value)
				{
					return (value.value)*100000;
				}

				public static Megaamperes operator +(Megaamperes first, Decaamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectoamperes(Megaamperes value)
				{
					return (value.value)*10000;
				}

				public static Megaamperes operator +(Megaamperes first, Hectoamperes second)
				{
					return new Megaamperes(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kiloamperes(Megaamperes value)
				{
					return (value.value)*1000;
				}

				public static Megaamperes operator +(Megaamperes first, Kiloamperes second)
				{
					return new Megaamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigaamperes(Megaamperes value)
				{
					return (value.value)*0.001;
				}

				public static Megaamperes operator +(Megaamperes first, Gigaamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Teraamperes(Megaamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Megaamperes operator +(Megaamperes first, Teraamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Petaamperes(Megaamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Megaamperes operator +(Megaamperes first, Petaamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Exaamperes(Megaamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Megaamperes operator +(Megaamperes first, Exaamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettaamperes(Megaamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Megaamperes operator +(Megaamperes first, Zettaamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottaamperes(Megaamperes value)
				{
					return (value.value)*1E-18;
				}

				public static Megaamperes operator +(Megaamperes first, Yottaamperes second)
				{
					return new Megaamperes(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigaamperes : IValueWithUnit, IEquatable< Gigaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigaamperes Zero = new Gigaamperes(0);
			public static readonly Gigaamperes One = new Gigaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.gigaampere; } }

			public Gigaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} GA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1000000000);
				}
				
			public bool Equals(Gigaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigaamperes(double value)
			{
				return new Gigaamperes(value);
			}

			public static Gigaamperes operator *(Gigaamperes value, double times)
			{
				return new Gigaamperes(value.value * times);
			}

			public static Gigaamperes operator *(double times, Gigaamperes value)
			{
				return new Gigaamperes(value.value * times);
			}

			public static Gigaamperes operator +(Gigaamperes first, Gigaamperes second)
			{
				return new Gigaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Gigaamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Amperes second)
				{
					return new Gigaamperes(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctoamperes(Gigaamperes value)
				{
					return (value.value)*1E+33;
				}

				public static Gigaamperes operator +(Gigaamperes first, Yoctoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptoamperes(Gigaamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Gigaamperes operator +(Gigaamperes first, Zeptoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attoamperes(Gigaamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Gigaamperes operator +(Gigaamperes first, Attoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtoamperes(Gigaamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Gigaamperes operator +(Gigaamperes first, Femtoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picoamperes(Gigaamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Gigaamperes operator +(Gigaamperes first, Picoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanoamperes(Gigaamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Gigaamperes operator +(Gigaamperes first, Nanoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Microamperes(Gigaamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Gigaamperes operator +(Gigaamperes first, Microamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Milliamperes(Gigaamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Milliamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centiamperes(Gigaamperes value)
				{
					return (value.value)*100000000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Centiamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-11);
				}
								public static implicit operator Deciamperes(Gigaamperes value)
				{
					return (value.value)*10000000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Deciamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decaamperes(Gigaamperes value)
				{
					return (value.value)*100000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Decaamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectoamperes(Gigaamperes value)
				{
					return (value.value)*10000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Hectoamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kiloamperes(Gigaamperes value)
				{
					return (value.value)*1000000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Kiloamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megaamperes(Gigaamperes value)
				{
					return (value.value)*1000;
				}

				public static Gigaamperes operator +(Gigaamperes first, Megaamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Teraamperes(Gigaamperes value)
				{
					return (value.value)*0.001;
				}

				public static Gigaamperes operator +(Gigaamperes first, Teraamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Petaamperes(Gigaamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Gigaamperes operator +(Gigaamperes first, Petaamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Exaamperes(Gigaamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Gigaamperes operator +(Gigaamperes first, Exaamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettaamperes(Gigaamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Gigaamperes operator +(Gigaamperes first, Zettaamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottaamperes(Gigaamperes value)
				{
					return (value.value)*1E-15;
				}

				public static Gigaamperes operator +(Gigaamperes first, Yottaamperes second)
				{
					return new Gigaamperes(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Teraamperes : IValueWithUnit, IEquatable< Teraamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Teraamperes Zero = new Teraamperes(0);
			public static readonly Teraamperes One = new Teraamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.teraampere; } }

			public Teraamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} TA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1000000000000);
				}
				
			public bool Equals(Teraamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Teraamperes(double value)
			{
				return new Teraamperes(value);
			}

			public static Teraamperes operator *(Teraamperes value, double times)
			{
				return new Teraamperes(value.value * times);
			}

			public static Teraamperes operator *(double times, Teraamperes value)
			{
				return new Teraamperes(value.value * times);
			}

			public static Teraamperes operator +(Teraamperes first, Teraamperes second)
			{
				return new Teraamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Teraamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Teraamperes operator +(Teraamperes first, Amperes second)
				{
					return new Teraamperes(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctoamperes(Teraamperes value)
				{
					return (value.value)*1E+36;
				}

				public static Teraamperes operator +(Teraamperes first, Yoctoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptoamperes(Teraamperes value)
				{
					return (value.value)*1E+33;
				}

				public static Teraamperes operator +(Teraamperes first, Zeptoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attoamperes(Teraamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Teraamperes operator +(Teraamperes first, Attoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtoamperes(Teraamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Teraamperes operator +(Teraamperes first, Femtoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picoamperes(Teraamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Teraamperes operator +(Teraamperes first, Picoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanoamperes(Teraamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Teraamperes operator +(Teraamperes first, Nanoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Microamperes(Teraamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Teraamperes operator +(Teraamperes first, Microamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Milliamperes(Teraamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Teraamperes operator +(Teraamperes first, Milliamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centiamperes(Teraamperes value)
				{
					return (value.value)*100000000000000;
				}

				public static Teraamperes operator +(Teraamperes first, Centiamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-14);
				}
								public static implicit operator Deciamperes(Teraamperes value)
				{
					return (value.value)*10000000000000;
				}

				public static Teraamperes operator +(Teraamperes first, Deciamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decaamperes(Teraamperes value)
				{
					return (value.value)*100000000000;
				}

				public static Teraamperes operator +(Teraamperes first, Decaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectoamperes(Teraamperes value)
				{
					return (value.value)*10000000000;
				}

				public static Teraamperes operator +(Teraamperes first, Hectoamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kiloamperes(Teraamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Teraamperes operator +(Teraamperes first, Kiloamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megaamperes(Teraamperes value)
				{
					return (value.value)*1000000;
				}

				public static Teraamperes operator +(Teraamperes first, Megaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigaamperes(Teraamperes value)
				{
					return (value.value)*1000;
				}

				public static Teraamperes operator +(Teraamperes first, Gigaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Petaamperes(Teraamperes value)
				{
					return (value.value)*0.001;
				}

				public static Teraamperes operator +(Teraamperes first, Petaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Exaamperes(Teraamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Teraamperes operator +(Teraamperes first, Exaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettaamperes(Teraamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Teraamperes operator +(Teraamperes first, Zettaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottaamperes(Teraamperes value)
				{
					return (value.value)*1E-12;
				}

				public static Teraamperes operator +(Teraamperes first, Yottaamperes second)
				{
					return new Teraamperes(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petaamperes : IValueWithUnit, IEquatable< Petaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Petaamperes Zero = new Petaamperes(0);
			public static readonly Petaamperes One = new Petaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.petaampere; } }

			public Petaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} PA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E+15);
				}
				
			public bool Equals(Petaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petaamperes(double value)
			{
				return new Petaamperes(value);
			}

			public static Petaamperes operator *(Petaamperes value, double times)
			{
				return new Petaamperes(value.value * times);
			}

			public static Petaamperes operator *(double times, Petaamperes value)
			{
				return new Petaamperes(value.value * times);
			}

			public static Petaamperes operator +(Petaamperes first, Petaamperes second)
			{
				return new Petaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Petaamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Petaamperes operator +(Petaamperes first, Amperes second)
				{
					return new Petaamperes(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctoamperes(Petaamperes value)
				{
					return (value.value)*1E+39;
				}

				public static Petaamperes operator +(Petaamperes first, Yoctoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptoamperes(Petaamperes value)
				{
					return (value.value)*1E+36;
				}

				public static Petaamperes operator +(Petaamperes first, Zeptoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attoamperes(Petaamperes value)
				{
					return (value.value)*1E+33;
				}

				public static Petaamperes operator +(Petaamperes first, Attoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtoamperes(Petaamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Petaamperes operator +(Petaamperes first, Femtoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picoamperes(Petaamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Petaamperes operator +(Petaamperes first, Picoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanoamperes(Petaamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Petaamperes operator +(Petaamperes first, Nanoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Microamperes(Petaamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Petaamperes operator +(Petaamperes first, Microamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Milliamperes(Petaamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Petaamperes operator +(Petaamperes first, Milliamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centiamperes(Petaamperes value)
				{
					return (value.value)*1E+17;
				}

				public static Petaamperes operator +(Petaamperes first, Centiamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-17);
				}
								public static implicit operator Deciamperes(Petaamperes value)
				{
					return (value.value)*1E+16;
				}

				public static Petaamperes operator +(Petaamperes first, Deciamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decaamperes(Petaamperes value)
				{
					return (value.value)*100000000000000;
				}

				public static Petaamperes operator +(Petaamperes first, Decaamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectoamperes(Petaamperes value)
				{
					return (value.value)*10000000000000;
				}

				public static Petaamperes operator +(Petaamperes first, Hectoamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kiloamperes(Petaamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Petaamperes operator +(Petaamperes first, Kiloamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megaamperes(Petaamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Petaamperes operator +(Petaamperes first, Megaamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigaamperes(Petaamperes value)
				{
					return (value.value)*1000000;
				}

				public static Petaamperes operator +(Petaamperes first, Gigaamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Teraamperes(Petaamperes value)
				{
					return (value.value)*1000;
				}

				public static Petaamperes operator +(Petaamperes first, Teraamperes second)
				{
					return new Petaamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Exaamperes(Petaamperes value)
				{
					return (value.value)*0.001;
				}

				public static Petaamperes operator +(Petaamperes first, Exaamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Zettaamperes(Petaamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Petaamperes operator +(Petaamperes first, Zettaamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottaamperes(Petaamperes value)
				{
					return (value.value)*1E-09;
				}

				public static Petaamperes operator +(Petaamperes first, Yottaamperes second)
				{
					return new Petaamperes(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Exaamperes : IValueWithUnit, IEquatable< Exaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Exaamperes Zero = new Exaamperes(0);
			public static readonly Exaamperes One = new Exaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.exaampere; } }

			public Exaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} EA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E+18);
				}
				
			public bool Equals(Exaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Exaamperes(double value)
			{
				return new Exaamperes(value);
			}

			public static Exaamperes operator *(Exaamperes value, double times)
			{
				return new Exaamperes(value.value * times);
			}

			public static Exaamperes operator *(double times, Exaamperes value)
			{
				return new Exaamperes(value.value * times);
			}

			public static Exaamperes operator +(Exaamperes first, Exaamperes second)
			{
				return new Exaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Exaamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Exaamperes operator +(Exaamperes first, Amperes second)
				{
					return new Exaamperes(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctoamperes(Exaamperes value)
				{
					return (value.value)*1E+42;
				}

				public static Exaamperes operator +(Exaamperes first, Yoctoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptoamperes(Exaamperes value)
				{
					return (value.value)*1E+39;
				}

				public static Exaamperes operator +(Exaamperes first, Zeptoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attoamperes(Exaamperes value)
				{
					return (value.value)*1E+36;
				}

				public static Exaamperes operator +(Exaamperes first, Attoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtoamperes(Exaamperes value)
				{
					return (value.value)*1E+33;
				}

				public static Exaamperes operator +(Exaamperes first, Femtoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picoamperes(Exaamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Exaamperes operator +(Exaamperes first, Picoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanoamperes(Exaamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Exaamperes operator +(Exaamperes first, Nanoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Microamperes(Exaamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Exaamperes operator +(Exaamperes first, Microamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Milliamperes(Exaamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Exaamperes operator +(Exaamperes first, Milliamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centiamperes(Exaamperes value)
				{
					return (value.value)*1E+20;
				}

				public static Exaamperes operator +(Exaamperes first, Centiamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-20);
				}
								public static implicit operator Deciamperes(Exaamperes value)
				{
					return (value.value)*1E+19;
				}

				public static Exaamperes operator +(Exaamperes first, Deciamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decaamperes(Exaamperes value)
				{
					return (value.value)*1E+17;
				}

				public static Exaamperes operator +(Exaamperes first, Decaamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectoamperes(Exaamperes value)
				{
					return (value.value)*1E+16;
				}

				public static Exaamperes operator +(Exaamperes first, Hectoamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kiloamperes(Exaamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Exaamperes operator +(Exaamperes first, Kiloamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megaamperes(Exaamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Exaamperes operator +(Exaamperes first, Megaamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigaamperes(Exaamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Exaamperes operator +(Exaamperes first, Gigaamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Teraamperes(Exaamperes value)
				{
					return (value.value)*1000000;
				}

				public static Exaamperes operator +(Exaamperes first, Teraamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petaamperes(Exaamperes value)
				{
					return (value.value)*1000;
				}

				public static Exaamperes operator +(Exaamperes first, Petaamperes second)
				{
					return new Exaamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettaamperes(Exaamperes value)
				{
					return (value.value)*0.001;
				}

				public static Exaamperes operator +(Exaamperes first, Zettaamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1000);
				}
								public static implicit operator Yottaamperes(Exaamperes value)
				{
					return (value.value)*1E-06;
				}

				public static Exaamperes operator +(Exaamperes first, Yottaamperes second)
				{
					return new Exaamperes(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettaamperes : IValueWithUnit, IEquatable< Zettaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettaamperes Zero = new Zettaamperes(0);
			public static readonly Zettaamperes One = new Zettaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.zettaampere; } }

			public Zettaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ZA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E+21);
				}
				
			public bool Equals(Zettaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettaamperes(double value)
			{
				return new Zettaamperes(value);
			}

			public static Zettaamperes operator *(Zettaamperes value, double times)
			{
				return new Zettaamperes(value.value * times);
			}

			public static Zettaamperes operator *(double times, Zettaamperes value)
			{
				return new Zettaamperes(value.value * times);
			}

			public static Zettaamperes operator +(Zettaamperes first, Zettaamperes second)
			{
				return new Zettaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Zettaamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Zettaamperes operator +(Zettaamperes first, Amperes second)
				{
					return new Zettaamperes(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctoamperes(Zettaamperes value)
				{
					return (value.value)*1E+45;
				}

				public static Zettaamperes operator +(Zettaamperes first, Yoctoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptoamperes(Zettaamperes value)
				{
					return (value.value)*1E+42;
				}

				public static Zettaamperes operator +(Zettaamperes first, Zeptoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attoamperes(Zettaamperes value)
				{
					return (value.value)*1E+39;
				}

				public static Zettaamperes operator +(Zettaamperes first, Attoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtoamperes(Zettaamperes value)
				{
					return (value.value)*1E+36;
				}

				public static Zettaamperes operator +(Zettaamperes first, Femtoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picoamperes(Zettaamperes value)
				{
					return (value.value)*1E+33;
				}

				public static Zettaamperes operator +(Zettaamperes first, Picoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanoamperes(Zettaamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Zettaamperes operator +(Zettaamperes first, Nanoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Microamperes(Zettaamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Zettaamperes operator +(Zettaamperes first, Microamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Milliamperes(Zettaamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Zettaamperes operator +(Zettaamperes first, Milliamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centiamperes(Zettaamperes value)
				{
					return (value.value)*1E+23;
				}

				public static Zettaamperes operator +(Zettaamperes first, Centiamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-23);
				}
								public static implicit operator Deciamperes(Zettaamperes value)
				{
					return (value.value)*1E+22;
				}

				public static Zettaamperes operator +(Zettaamperes first, Deciamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decaamperes(Zettaamperes value)
				{
					return (value.value)*1E+20;
				}

				public static Zettaamperes operator +(Zettaamperes first, Decaamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectoamperes(Zettaamperes value)
				{
					return (value.value)*1E+19;
				}

				public static Zettaamperes operator +(Zettaamperes first, Hectoamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kiloamperes(Zettaamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Zettaamperes operator +(Zettaamperes first, Kiloamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megaamperes(Zettaamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Zettaamperes operator +(Zettaamperes first, Megaamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigaamperes(Zettaamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettaamperes operator +(Zettaamperes first, Gigaamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Teraamperes(Zettaamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Zettaamperes operator +(Zettaamperes first, Teraamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petaamperes(Zettaamperes value)
				{
					return (value.value)*1000000;
				}

				public static Zettaamperes operator +(Zettaamperes first, Petaamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Exaamperes(Zettaamperes value)
				{
					return (value.value)*1000;
				}

				public static Zettaamperes operator +(Zettaamperes first, Exaamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottaamperes(Zettaamperes value)
				{
					return (value.value)*0.001;
				}

				public static Zettaamperes operator +(Zettaamperes first, Yottaamperes second)
				{
					return new Zettaamperes(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottaamperes : IValueWithUnit, IEquatable< Yottaamperes >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottaamperes Zero = new Yottaamperes(0);
			public static readonly Yottaamperes One = new Yottaamperes(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ElectricCurrent.Units.yottaampere; } }

			public Yottaamperes(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} YA", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Amperes ToBaseUnit()
				{
					return new Amperes((this.value)*1E+24);
				}
				
			public bool Equals(Yottaamperes other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottaamperes(double value)
			{
				return new Yottaamperes(value);
			}

			public static Yottaamperes operator *(Yottaamperes value, double times)
			{
				return new Yottaamperes(value.value * times);
			}

			public static Yottaamperes operator *(double times, Yottaamperes value)
			{
				return new Yottaamperes(value.value * times);
			}

			public static Yottaamperes operator +(Yottaamperes first, Yottaamperes second)
			{
				return new Yottaamperes(first.value * second.value);
			}

							public static implicit operator Amperes(Yottaamperes value)
				{
					return (value.value)*1E+24;
				}

				public static Yottaamperes operator +(Yottaamperes first, Amperes second)
				{
					return new Yottaamperes(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctoamperes(Yottaamperes value)
				{
					return (value.value)*1E+48;
				}

				public static Yottaamperes operator +(Yottaamperes first, Yoctoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptoamperes(Yottaamperes value)
				{
					return (value.value)*1E+45;
				}

				public static Yottaamperes operator +(Yottaamperes first, Zeptoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attoamperes(Yottaamperes value)
				{
					return (value.value)*1E+42;
				}

				public static Yottaamperes operator +(Yottaamperes first, Attoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtoamperes(Yottaamperes value)
				{
					return (value.value)*1E+39;
				}

				public static Yottaamperes operator +(Yottaamperes first, Femtoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picoamperes(Yottaamperes value)
				{
					return (value.value)*1E+36;
				}

				public static Yottaamperes operator +(Yottaamperes first, Picoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanoamperes(Yottaamperes value)
				{
					return (value.value)*1E+33;
				}

				public static Yottaamperes operator +(Yottaamperes first, Nanoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-33);
				}
								public static implicit operator Microamperes(Yottaamperes value)
				{
					return (value.value)*1E+30;
				}

				public static Yottaamperes operator +(Yottaamperes first, Microamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-30);
				}
								public static implicit operator Milliamperes(Yottaamperes value)
				{
					return (value.value)*1E+27;
				}

				public static Yottaamperes operator +(Yottaamperes first, Milliamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centiamperes(Yottaamperes value)
				{
					return (value.value)*1E+26;
				}

				public static Yottaamperes operator +(Yottaamperes first, Centiamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-26);
				}
								public static implicit operator Deciamperes(Yottaamperes value)
				{
					return (value.value)*1E+25;
				}

				public static Yottaamperes operator +(Yottaamperes first, Deciamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decaamperes(Yottaamperes value)
				{
					return (value.value)*1E+23;
				}

				public static Yottaamperes operator +(Yottaamperes first, Decaamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectoamperes(Yottaamperes value)
				{
					return (value.value)*1E+22;
				}

				public static Yottaamperes operator +(Yottaamperes first, Hectoamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kiloamperes(Yottaamperes value)
				{
					return (value.value)*1E+21;
				}

				public static Yottaamperes operator +(Yottaamperes first, Kiloamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megaamperes(Yottaamperes value)
				{
					return (value.value)*1E+18;
				}

				public static Yottaamperes operator +(Yottaamperes first, Megaamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigaamperes(Yottaamperes value)
				{
					return (value.value)*1E+15;
				}

				public static Yottaamperes operator +(Yottaamperes first, Gigaamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-15);
				}
								public static implicit operator Teraamperes(Yottaamperes value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottaamperes operator +(Yottaamperes first, Teraamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petaamperes(Yottaamperes value)
				{
					return (value.value)*1000000000;
				}

				public static Yottaamperes operator +(Yottaamperes first, Petaamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-09);
				}
								public static implicit operator Exaamperes(Yottaamperes value)
				{
					return (value.value)*1000000;
				}

				public static Yottaamperes operator +(Yottaamperes first, Exaamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettaamperes(Yottaamperes value)
				{
					return (value.value)*1000;
				}

				public static Yottaamperes operator +(Yottaamperes first, Zettaamperes second)
				{
					return new Yottaamperes(first.value + (second.value)*0.001);
				}
						}
		}

		public struct Kelvins : IValueWithUnit, IEquatable< Kelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Kelvins Zero = new Kelvins(0);
			public static readonly Kelvins One = new Kelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.kelvin; } }

			public Kelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} K", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Kelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kelvins(double value)
			{
				return new Kelvins(value);
			}

			public static Kelvins operator *(Kelvins value, double times)
			{
				return new Kelvins(value.value * times);
			}

			public static Kelvins operator *(double times, Kelvins value)
			{
				return new Kelvins(value.value * times);
			}

			public static Kelvins operator +(Kelvins first, Kelvins second)
			{
				return new Kelvins(first.value * second.value);
			}

							public static implicit operator Yoctokelvins(Kelvins value)
				{
					return (value.value)/1E-24;
				}

				public static Kelvins operator +(Kelvins first, Yoctokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptokelvins(Kelvins value)
				{
					return (value.value)/1E-21;
				}

				public static Kelvins operator +(Kelvins first, Zeptokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attokelvins(Kelvins value)
				{
					return (value.value)/1E-18;
				}

				public static Kelvins operator +(Kelvins first, Attokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtokelvins(Kelvins value)
				{
					return (value.value)/1E-15;
				}

				public static Kelvins operator +(Kelvins first, Femtokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picokelvins(Kelvins value)
				{
					return (value.value)/1E-12;
				}

				public static Kelvins operator +(Kelvins first, Picokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanokelvins(Kelvins value)
				{
					return (value.value)/1E-09;
				}

				public static Kelvins operator +(Kelvins first, Nanokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Microkelvins(Kelvins value)
				{
					return (value.value)/1E-06;
				}

				public static Kelvins operator +(Kelvins first, Microkelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Millikelvins(Kelvins value)
				{
					return (value.value)/0.001;
				}

				public static Kelvins operator +(Kelvins first, Millikelvins second)
				{
					return new Kelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Centikelvins(Kelvins value)
				{
					return (value.value)/0.01;
				}

				public static Kelvins operator +(Kelvins first, Centikelvins second)
				{
					return new Kelvins(first.value + (second.value)*0.01);
				}
								public static implicit operator Decikelvins(Kelvins value)
				{
					return (value.value)/0.1;
				}

				public static Kelvins operator +(Kelvins first, Decikelvins second)
				{
					return new Kelvins(first.value + (second.value)*0.1);
				}
								public static implicit operator Decakelvins(Kelvins value)
				{
					return (value.value)/10;
				}

				public static Kelvins operator +(Kelvins first, Decakelvins second)
				{
					return new Kelvins(first.value + (second.value)*10);
				}
								public static implicit operator Hectokelvins(Kelvins value)
				{
					return (value.value)/100;
				}

				public static Kelvins operator +(Kelvins first, Hectokelvins second)
				{
					return new Kelvins(first.value + (second.value)*100);
				}
								public static implicit operator Kilokelvins(Kelvins value)
				{
					return (value.value)/1000;
				}

				public static Kelvins operator +(Kelvins first, Kilokelvins second)
				{
					return new Kelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Megakelvins(Kelvins value)
				{
					return (value.value)/1000000;
				}

				public static Kelvins operator +(Kelvins first, Megakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigakelvins(Kelvins value)
				{
					return (value.value)/1000000000;
				}

				public static Kelvins operator +(Kelvins first, Gigakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Terakelvins(Kelvins value)
				{
					return (value.value)/1000000000000;
				}

				public static Kelvins operator +(Kelvins first, Terakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petakelvins(Kelvins value)
				{
					return (value.value)/1E+15;
				}

				public static Kelvins operator +(Kelvins first, Petakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Exakelvins(Kelvins value)
				{
					return (value.value)/1E+18;
				}

				public static Kelvins operator +(Kelvins first, Exakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettakelvins(Kelvins value)
				{
					return (value.value)/1E+21;
				}

				public static Kelvins operator +(Kelvins first, Zettakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottakelvins(Kelvins value)
				{
					return (value.value)/1E+24;
				}

				public static Kelvins operator +(Kelvins first, Yottakelvins second)
				{
					return new Kelvins(first.value + (second.value)*1E+24);
				}
						}
		namespace Multiples
{

		public struct Yoctokelvins : IValueWithUnit, IEquatable< Yoctokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctokelvins Zero = new Yoctokelvins(0);
			public static readonly Yoctokelvins One = new Yoctokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.yoctokelvin; } }

			public Yoctokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} yK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-24);
				}
				
			public bool Equals(Yoctokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctokelvins(double value)
			{
				return new Yoctokelvins(value);
			}

			public static Yoctokelvins operator *(Yoctokelvins value, double times)
			{
				return new Yoctokelvins(value.value * times);
			}

			public static Yoctokelvins operator *(double times, Yoctokelvins value)
			{
				return new Yoctokelvins(value.value * times);
			}

			public static Yoctokelvins operator +(Yoctokelvins first, Yoctokelvins second)
			{
				return new Yoctokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Yoctokelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Kelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptokelvins(Yoctokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Zeptokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Attokelvins(Yoctokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Attokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtokelvins(Yoctokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Femtokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picokelvins(Yoctokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Picokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanokelvins(Yoctokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Nanokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Microkelvins(Yoctokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Microkelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Millikelvins(Yoctokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Millikelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centikelvins(Yoctokelvins value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Centikelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+22);
				}
								public static implicit operator Decikelvins(Yoctokelvins value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Decikelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Decakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectokelvins(Yoctokelvins value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Hectokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kilokelvins(Yoctokelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Kilokelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Megakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Gigakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+33);
				}
								public static implicit operator Terakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Terakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Petakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+39);
				}
								public static implicit operator Exakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Exakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Zettakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottakelvins(Yoctokelvins value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctokelvins operator +(Yoctokelvins first, Yottakelvins second)
				{
					return new Yoctokelvins(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptokelvins : IValueWithUnit, IEquatable< Zeptokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptokelvins Zero = new Zeptokelvins(0);
			public static readonly Zeptokelvins One = new Zeptokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.zeptokelvin; } }

			public Zeptokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-21);
				}
				
			public bool Equals(Zeptokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptokelvins(double value)
			{
				return new Zeptokelvins(value);
			}

			public static Zeptokelvins operator *(Zeptokelvins value, double times)
			{
				return new Zeptokelvins(value.value * times);
			}

			public static Zeptokelvins operator *(double times, Zeptokelvins value)
			{
				return new Zeptokelvins(value.value * times);
			}

			public static Zeptokelvins operator +(Zeptokelvins first, Zeptokelvins second)
			{
				return new Zeptokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Zeptokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Kelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctokelvins(Zeptokelvins value)
				{
					return (value.value)*1000;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Yoctokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Attokelvins(Zeptokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Attokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Femtokelvins(Zeptokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Femtokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Picokelvins(Zeptokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Picokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanokelvins(Zeptokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Nanokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Microkelvins(Zeptokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Microkelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Millikelvins(Zeptokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Millikelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centikelvins(Zeptokelvins value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Centikelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+19);
				}
								public static implicit operator Decikelvins(Zeptokelvins value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Decikelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Decakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectokelvins(Zeptokelvins value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Hectokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kilokelvins(Zeptokelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Kilokelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Megakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Gigakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+30);
				}
								public static implicit operator Terakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Terakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Petakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+36);
				}
								public static implicit operator Exakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Exakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Zettakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottakelvins(Zeptokelvins value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptokelvins operator +(Zeptokelvins first, Yottakelvins second)
				{
					return new Zeptokelvins(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attokelvins : IValueWithUnit, IEquatable< Attokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Attokelvins Zero = new Attokelvins(0);
			public static readonly Attokelvins One = new Attokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.attokelvin; } }

			public Attokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} aK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-18);
				}
				
			public bool Equals(Attokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attokelvins(double value)
			{
				return new Attokelvins(value);
			}

			public static Attokelvins operator *(Attokelvins value, double times)
			{
				return new Attokelvins(value.value * times);
			}

			public static Attokelvins operator *(double times, Attokelvins value)
			{
				return new Attokelvins(value.value * times);
			}

			public static Attokelvins operator +(Attokelvins first, Attokelvins second)
			{
				return new Attokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Attokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Attokelvins operator +(Attokelvins first, Kelvins second)
				{
					return new Attokelvins(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctokelvins(Attokelvins value)
				{
					return (value.value)*1000000;
				}

				public static Attokelvins operator +(Attokelvins first, Yoctokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptokelvins(Attokelvins value)
				{
					return (value.value)*1000;
				}

				public static Attokelvins operator +(Attokelvins first, Zeptokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtokelvins(Attokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Attokelvins operator +(Attokelvins first, Femtokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Picokelvins(Attokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Attokelvins operator +(Attokelvins first, Picokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanokelvins(Attokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Attokelvins operator +(Attokelvins first, Nanokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Microkelvins(Attokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Attokelvins operator +(Attokelvins first, Microkelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Millikelvins(Attokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Attokelvins operator +(Attokelvins first, Millikelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centikelvins(Attokelvins value)
				{
					return (value.value)*1E-16;
				}

				public static Attokelvins operator +(Attokelvins first, Centikelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+16);
				}
								public static implicit operator Decikelvins(Attokelvins value)
				{
					return (value.value)*1E-17;
				}

				public static Attokelvins operator +(Attokelvins first, Decikelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decakelvins(Attokelvins value)
				{
					return (value.value)*1E-19;
				}

				public static Attokelvins operator +(Attokelvins first, Decakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectokelvins(Attokelvins value)
				{
					return (value.value)*1E-20;
				}

				public static Attokelvins operator +(Attokelvins first, Hectokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kilokelvins(Attokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Attokelvins operator +(Attokelvins first, Kilokelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megakelvins(Attokelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Attokelvins operator +(Attokelvins first, Megakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigakelvins(Attokelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Attokelvins operator +(Attokelvins first, Gigakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Terakelvins(Attokelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Attokelvins operator +(Attokelvins first, Terakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petakelvins(Attokelvins value)
				{
					return (value.value)*1E-33;
				}

				public static Attokelvins operator +(Attokelvins first, Petakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+33);
				}
								public static implicit operator Exakelvins(Attokelvins value)
				{
					return (value.value)*1E-36;
				}

				public static Attokelvins operator +(Attokelvins first, Exakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettakelvins(Attokelvins value)
				{
					return (value.value)*1E-39;
				}

				public static Attokelvins operator +(Attokelvins first, Zettakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottakelvins(Attokelvins value)
				{
					return (value.value)*1E-42;
				}

				public static Attokelvins operator +(Attokelvins first, Yottakelvins second)
				{
					return new Attokelvins(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtokelvins : IValueWithUnit, IEquatable< Femtokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtokelvins Zero = new Femtokelvins(0);
			public static readonly Femtokelvins One = new Femtokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.femtokelvin; } }

			public Femtokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-15);
				}
				
			public bool Equals(Femtokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtokelvins(double value)
			{
				return new Femtokelvins(value);
			}

			public static Femtokelvins operator *(Femtokelvins value, double times)
			{
				return new Femtokelvins(value.value * times);
			}

			public static Femtokelvins operator *(double times, Femtokelvins value)
			{
				return new Femtokelvins(value.value * times);
			}

			public static Femtokelvins operator +(Femtokelvins first, Femtokelvins second)
			{
				return new Femtokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Femtokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Femtokelvins operator +(Femtokelvins first, Kelvins second)
				{
					return new Femtokelvins(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctokelvins(Femtokelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Femtokelvins operator +(Femtokelvins first, Yoctokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptokelvins(Femtokelvins value)
				{
					return (value.value)*1000000;
				}

				public static Femtokelvins operator +(Femtokelvins first, Zeptokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attokelvins(Femtokelvins value)
				{
					return (value.value)*1000;
				}

				public static Femtokelvins operator +(Femtokelvins first, Attokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Picokelvins(Femtokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Femtokelvins operator +(Femtokelvins first, Picokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Nanokelvins(Femtokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Femtokelvins operator +(Femtokelvins first, Nanokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Microkelvins(Femtokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Femtokelvins operator +(Femtokelvins first, Microkelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Millikelvins(Femtokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Femtokelvins operator +(Femtokelvins first, Millikelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centikelvins(Femtokelvins value)
				{
					return (value.value)*1E-13;
				}

				public static Femtokelvins operator +(Femtokelvins first, Centikelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Decikelvins(Femtokelvins value)
				{
					return (value.value)*1E-14;
				}

				public static Femtokelvins operator +(Femtokelvins first, Decikelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decakelvins(Femtokelvins value)
				{
					return (value.value)*1E-16;
				}

				public static Femtokelvins operator +(Femtokelvins first, Decakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectokelvins(Femtokelvins value)
				{
					return (value.value)*1E-17;
				}

				public static Femtokelvins operator +(Femtokelvins first, Hectokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kilokelvins(Femtokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Femtokelvins operator +(Femtokelvins first, Kilokelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megakelvins(Femtokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Femtokelvins operator +(Femtokelvins first, Megakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigakelvins(Femtokelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Femtokelvins operator +(Femtokelvins first, Gigakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Terakelvins(Femtokelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Femtokelvins operator +(Femtokelvins first, Terakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petakelvins(Femtokelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Femtokelvins operator +(Femtokelvins first, Petakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+30);
				}
								public static implicit operator Exakelvins(Femtokelvins value)
				{
					return (value.value)*1E-33;
				}

				public static Femtokelvins operator +(Femtokelvins first, Exakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettakelvins(Femtokelvins value)
				{
					return (value.value)*1E-36;
				}

				public static Femtokelvins operator +(Femtokelvins first, Zettakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottakelvins(Femtokelvins value)
				{
					return (value.value)*1E-39;
				}

				public static Femtokelvins operator +(Femtokelvins first, Yottakelvins second)
				{
					return new Femtokelvins(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picokelvins : IValueWithUnit, IEquatable< Picokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Picokelvins Zero = new Picokelvins(0);
			public static readonly Picokelvins One = new Picokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.picokelvin; } }

			public Picokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} pK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-12);
				}
				
			public bool Equals(Picokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picokelvins(double value)
			{
				return new Picokelvins(value);
			}

			public static Picokelvins operator *(Picokelvins value, double times)
			{
				return new Picokelvins(value.value * times);
			}

			public static Picokelvins operator *(double times, Picokelvins value)
			{
				return new Picokelvins(value.value * times);
			}

			public static Picokelvins operator +(Picokelvins first, Picokelvins second)
			{
				return new Picokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Picokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Picokelvins operator +(Picokelvins first, Kelvins second)
				{
					return new Picokelvins(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctokelvins(Picokelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Picokelvins operator +(Picokelvins first, Yoctokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptokelvins(Picokelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Picokelvins operator +(Picokelvins first, Zeptokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attokelvins(Picokelvins value)
				{
					return (value.value)*1000000;
				}

				public static Picokelvins operator +(Picokelvins first, Attokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtokelvins(Picokelvins value)
				{
					return (value.value)*1000;
				}

				public static Picokelvins operator +(Picokelvins first, Femtokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanokelvins(Picokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Picokelvins operator +(Picokelvins first, Nanokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Microkelvins(Picokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Picokelvins operator +(Picokelvins first, Microkelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Millikelvins(Picokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Picokelvins operator +(Picokelvins first, Millikelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centikelvins(Picokelvins value)
				{
					return (value.value)*1E-10;
				}

				public static Picokelvins operator +(Picokelvins first, Centikelvins second)
				{
					return new Picokelvins(first.value + (second.value)*10000000000);
				}
								public static implicit operator Decikelvins(Picokelvins value)
				{
					return (value.value)*1E-11;
				}

				public static Picokelvins operator +(Picokelvins first, Decikelvins second)
				{
					return new Picokelvins(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decakelvins(Picokelvins value)
				{
					return (value.value)*1E-13;
				}

				public static Picokelvins operator +(Picokelvins first, Decakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectokelvins(Picokelvins value)
				{
					return (value.value)*1E-14;
				}

				public static Picokelvins operator +(Picokelvins first, Hectokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kilokelvins(Picokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Picokelvins operator +(Picokelvins first, Kilokelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megakelvins(Picokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Picokelvins operator +(Picokelvins first, Megakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigakelvins(Picokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Picokelvins operator +(Picokelvins first, Gigakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Terakelvins(Picokelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Picokelvins operator +(Picokelvins first, Terakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petakelvins(Picokelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Picokelvins operator +(Picokelvins first, Petakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Exakelvins(Picokelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Picokelvins operator +(Picokelvins first, Exakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettakelvins(Picokelvins value)
				{
					return (value.value)*1E-33;
				}

				public static Picokelvins operator +(Picokelvins first, Zettakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottakelvins(Picokelvins value)
				{
					return (value.value)*1E-36;
				}

				public static Picokelvins operator +(Picokelvins first, Yottakelvins second)
				{
					return new Picokelvins(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanokelvins : IValueWithUnit, IEquatable< Nanokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanokelvins Zero = new Nanokelvins(0);
			public static readonly Nanokelvins One = new Nanokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.nanokelvin; } }

			public Nanokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} nK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-09);
				}
				
			public bool Equals(Nanokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanokelvins(double value)
			{
				return new Nanokelvins(value);
			}

			public static Nanokelvins operator *(Nanokelvins value, double times)
			{
				return new Nanokelvins(value.value * times);
			}

			public static Nanokelvins operator *(double times, Nanokelvins value)
			{
				return new Nanokelvins(value.value * times);
			}

			public static Nanokelvins operator +(Nanokelvins first, Nanokelvins second)
			{
				return new Nanokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Nanokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Nanokelvins operator +(Nanokelvins first, Kelvins second)
				{
					return new Nanokelvins(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctokelvins(Nanokelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Nanokelvins operator +(Nanokelvins first, Yoctokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptokelvins(Nanokelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanokelvins operator +(Nanokelvins first, Zeptokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attokelvins(Nanokelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Nanokelvins operator +(Nanokelvins first, Attokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtokelvins(Nanokelvins value)
				{
					return (value.value)*1000000;
				}

				public static Nanokelvins operator +(Nanokelvins first, Femtokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picokelvins(Nanokelvins value)
				{
					return (value.value)*1000;
				}

				public static Nanokelvins operator +(Nanokelvins first, Picokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Microkelvins(Nanokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Nanokelvins operator +(Nanokelvins first, Microkelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Millikelvins(Nanokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Nanokelvins operator +(Nanokelvins first, Millikelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Centikelvins(Nanokelvins value)
				{
					return (value.value)*1E-07;
				}

				public static Nanokelvins operator +(Nanokelvins first, Centikelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*10000000);
				}
								public static implicit operator Decikelvins(Nanokelvins value)
				{
					return (value.value)*1E-08;
				}

				public static Nanokelvins operator +(Nanokelvins first, Decikelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*100000000);
				}
								public static implicit operator Decakelvins(Nanokelvins value)
				{
					return (value.value)*1E-10;
				}

				public static Nanokelvins operator +(Nanokelvins first, Decakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectokelvins(Nanokelvins value)
				{
					return (value.value)*1E-11;
				}

				public static Nanokelvins operator +(Nanokelvins first, Hectokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kilokelvins(Nanokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Nanokelvins operator +(Nanokelvins first, Kilokelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megakelvins(Nanokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Nanokelvins operator +(Nanokelvins first, Megakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigakelvins(Nanokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Nanokelvins operator +(Nanokelvins first, Gigakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Terakelvins(Nanokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Nanokelvins operator +(Nanokelvins first, Terakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petakelvins(Nanokelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Nanokelvins operator +(Nanokelvins first, Petakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Exakelvins(Nanokelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Nanokelvins operator +(Nanokelvins first, Exakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettakelvins(Nanokelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Nanokelvins operator +(Nanokelvins first, Zettakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottakelvins(Nanokelvins value)
				{
					return (value.value)*1E-33;
				}

				public static Nanokelvins operator +(Nanokelvins first, Yottakelvins second)
				{
					return new Nanokelvins(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Microkelvins : IValueWithUnit, IEquatable< Microkelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Microkelvins Zero = new Microkelvins(0);
			public static readonly Microkelvins One = new Microkelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.microkelvin; } }

			public Microkelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E-06);
				}
				
			public bool Equals(Microkelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Microkelvins(double value)
			{
				return new Microkelvins(value);
			}

			public static Microkelvins operator *(Microkelvins value, double times)
			{
				return new Microkelvins(value.value * times);
			}

			public static Microkelvins operator *(double times, Microkelvins value)
			{
				return new Microkelvins(value.value * times);
			}

			public static Microkelvins operator +(Microkelvins first, Microkelvins second)
			{
				return new Microkelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Microkelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Microkelvins operator +(Microkelvins first, Kelvins second)
				{
					return new Microkelvins(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctokelvins(Microkelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Microkelvins operator +(Microkelvins first, Yoctokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptokelvins(Microkelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Microkelvins operator +(Microkelvins first, Zeptokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attokelvins(Microkelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Microkelvins operator +(Microkelvins first, Attokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtokelvins(Microkelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Microkelvins operator +(Microkelvins first, Femtokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picokelvins(Microkelvins value)
				{
					return (value.value)*1000000;
				}

				public static Microkelvins operator +(Microkelvins first, Picokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanokelvins(Microkelvins value)
				{
					return (value.value)*1000;
				}

				public static Microkelvins operator +(Microkelvins first, Nanokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Millikelvins(Microkelvins value)
				{
					return (value.value)*0.001;
				}

				public static Microkelvins operator +(Microkelvins first, Millikelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Centikelvins(Microkelvins value)
				{
					return (value.value)*0.0001;
				}

				public static Microkelvins operator +(Microkelvins first, Centikelvins second)
				{
					return new Microkelvins(first.value + (second.value)*10000);
				}
								public static implicit operator Decikelvins(Microkelvins value)
				{
					return (value.value)*1E-05;
				}

				public static Microkelvins operator +(Microkelvins first, Decikelvins second)
				{
					return new Microkelvins(first.value + (second.value)*100000);
				}
								public static implicit operator Decakelvins(Microkelvins value)
				{
					return (value.value)*1E-07;
				}

				public static Microkelvins operator +(Microkelvins first, Decakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectokelvins(Microkelvins value)
				{
					return (value.value)*1E-08;
				}

				public static Microkelvins operator +(Microkelvins first, Hectokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*100000000);
				}
								public static implicit operator Kilokelvins(Microkelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Microkelvins operator +(Microkelvins first, Kilokelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megakelvins(Microkelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Microkelvins operator +(Microkelvins first, Megakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigakelvins(Microkelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Microkelvins operator +(Microkelvins first, Gigakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Terakelvins(Microkelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Microkelvins operator +(Microkelvins first, Terakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petakelvins(Microkelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Microkelvins operator +(Microkelvins first, Petakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Exakelvins(Microkelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Microkelvins operator +(Microkelvins first, Exakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettakelvins(Microkelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Microkelvins operator +(Microkelvins first, Zettakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottakelvins(Microkelvins value)
				{
					return (value.value)*1E-30;
				}

				public static Microkelvins operator +(Microkelvins first, Yottakelvins second)
				{
					return new Microkelvins(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Millikelvins : IValueWithUnit, IEquatable< Millikelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Millikelvins Zero = new Millikelvins(0);
			public static readonly Millikelvins One = new Millikelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.millikelvin; } }

			public Millikelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*0.001);
				}
				
			public bool Equals(Millikelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Millikelvins(double value)
			{
				return new Millikelvins(value);
			}

			public static Millikelvins operator *(Millikelvins value, double times)
			{
				return new Millikelvins(value.value * times);
			}

			public static Millikelvins operator *(double times, Millikelvins value)
			{
				return new Millikelvins(value.value * times);
			}

			public static Millikelvins operator +(Millikelvins first, Millikelvins second)
			{
				return new Millikelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Millikelvins value)
				{
					return (value.value)*0.001;
				}

				public static Millikelvins operator +(Millikelvins first, Kelvins second)
				{
					return new Millikelvins(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctokelvins(Millikelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Millikelvins operator +(Millikelvins first, Yoctokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptokelvins(Millikelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Millikelvins operator +(Millikelvins first, Zeptokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attokelvins(Millikelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Millikelvins operator +(Millikelvins first, Attokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtokelvins(Millikelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Millikelvins operator +(Millikelvins first, Femtokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picokelvins(Millikelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Millikelvins operator +(Millikelvins first, Picokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanokelvins(Millikelvins value)
				{
					return (value.value)*1000000;
				}

				public static Millikelvins operator +(Millikelvins first, Nanokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Microkelvins(Millikelvins value)
				{
					return (value.value)*1000;
				}

				public static Millikelvins operator +(Millikelvins first, Microkelvins second)
				{
					return new Millikelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Centikelvins(Millikelvins value)
				{
					return (value.value)*0.1;
				}

				public static Millikelvins operator +(Millikelvins first, Centikelvins second)
				{
					return new Millikelvins(first.value + (second.value)*10);
				}
								public static implicit operator Decikelvins(Millikelvins value)
				{
					return (value.value)*0.01;
				}

				public static Millikelvins operator +(Millikelvins first, Decikelvins second)
				{
					return new Millikelvins(first.value + (second.value)*100);
				}
								public static implicit operator Decakelvins(Millikelvins value)
				{
					return (value.value)*0.0001;
				}

				public static Millikelvins operator +(Millikelvins first, Decakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*10000);
				}
								public static implicit operator Hectokelvins(Millikelvins value)
				{
					return (value.value)*1E-05;
				}

				public static Millikelvins operator +(Millikelvins first, Hectokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*100000);
				}
								public static implicit operator Kilokelvins(Millikelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Millikelvins operator +(Millikelvins first, Kilokelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Megakelvins(Millikelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Millikelvins operator +(Millikelvins first, Megakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigakelvins(Millikelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Millikelvins operator +(Millikelvins first, Gigakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Terakelvins(Millikelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Millikelvins operator +(Millikelvins first, Terakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petakelvins(Millikelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Millikelvins operator +(Millikelvins first, Petakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Exakelvins(Millikelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Millikelvins operator +(Millikelvins first, Exakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettakelvins(Millikelvins value)
				{
					return (value.value)*1E-24;
				}

				public static Millikelvins operator +(Millikelvins first, Zettakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottakelvins(Millikelvins value)
				{
					return (value.value)*1E-27;
				}

				public static Millikelvins operator +(Millikelvins first, Yottakelvins second)
				{
					return new Millikelvins(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centikelvins : IValueWithUnit, IEquatable< Centikelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Centikelvins Zero = new Centikelvins(0);
			public static readonly Centikelvins One = new Centikelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.centikelvin; } }

			public Centikelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*0.01);
				}
				
			public bool Equals(Centikelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centikelvins(double value)
			{
				return new Centikelvins(value);
			}

			public static Centikelvins operator *(Centikelvins value, double times)
			{
				return new Centikelvins(value.value * times);
			}

			public static Centikelvins operator *(double times, Centikelvins value)
			{
				return new Centikelvins(value.value * times);
			}

			public static Centikelvins operator +(Centikelvins first, Centikelvins second)
			{
				return new Centikelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Centikelvins value)
				{
					return (value.value)*0.01;
				}

				public static Centikelvins operator +(Centikelvins first, Kelvins second)
				{
					return new Centikelvins(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctokelvins(Centikelvins value)
				{
					return (value.value)*1E+22;
				}

				public static Centikelvins operator +(Centikelvins first, Yoctokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptokelvins(Centikelvins value)
				{
					return (value.value)*1E+19;
				}

				public static Centikelvins operator +(Centikelvins first, Zeptokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attokelvins(Centikelvins value)
				{
					return (value.value)*1E+16;
				}

				public static Centikelvins operator +(Centikelvins first, Attokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtokelvins(Centikelvins value)
				{
					return (value.value)*10000000000000;
				}

				public static Centikelvins operator +(Centikelvins first, Femtokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picokelvins(Centikelvins value)
				{
					return (value.value)*10000000000;
				}

				public static Centikelvins operator +(Centikelvins first, Picokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanokelvins(Centikelvins value)
				{
					return (value.value)*10000000;
				}

				public static Centikelvins operator +(Centikelvins first, Nanokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E-07);
				}
								public static implicit operator Microkelvins(Centikelvins value)
				{
					return (value.value)*10000;
				}

				public static Centikelvins operator +(Centikelvins first, Microkelvins second)
				{
					return new Centikelvins(first.value + (second.value)*0.0001);
				}
								public static implicit operator Millikelvins(Centikelvins value)
				{
					return (value.value)*10;
				}

				public static Centikelvins operator +(Centikelvins first, Millikelvins second)
				{
					return new Centikelvins(first.value + (second.value)*0.1);
				}
								public static implicit operator Decikelvins(Centikelvins value)
				{
					return (value.value)*0.1;
				}

				public static Centikelvins operator +(Centikelvins first, Decikelvins second)
				{
					return new Centikelvins(first.value + (second.value)*10);
				}
								public static implicit operator Decakelvins(Centikelvins value)
				{
					return (value.value)*0.001;
				}

				public static Centikelvins operator +(Centikelvins first, Decakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Hectokelvins(Centikelvins value)
				{
					return (value.value)*0.0001;
				}

				public static Centikelvins operator +(Centikelvins first, Hectokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*10000);
				}
								public static implicit operator Kilokelvins(Centikelvins value)
				{
					return (value.value)*1E-05;
				}

				public static Centikelvins operator +(Centikelvins first, Kilokelvins second)
				{
					return new Centikelvins(first.value + (second.value)*100000);
				}
								public static implicit operator Megakelvins(Centikelvins value)
				{
					return (value.value)*1E-08;
				}

				public static Centikelvins operator +(Centikelvins first, Megakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigakelvins(Centikelvins value)
				{
					return (value.value)*1E-11;
				}

				public static Centikelvins operator +(Centikelvins first, Gigakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*100000000000);
				}
								public static implicit operator Terakelvins(Centikelvins value)
				{
					return (value.value)*1E-14;
				}

				public static Centikelvins operator +(Centikelvins first, Terakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petakelvins(Centikelvins value)
				{
					return (value.value)*1E-17;
				}

				public static Centikelvins operator +(Centikelvins first, Petakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E+17);
				}
								public static implicit operator Exakelvins(Centikelvins value)
				{
					return (value.value)*1E-20;
				}

				public static Centikelvins operator +(Centikelvins first, Exakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettakelvins(Centikelvins value)
				{
					return (value.value)*1E-23;
				}

				public static Centikelvins operator +(Centikelvins first, Zettakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottakelvins(Centikelvins value)
				{
					return (value.value)*1E-26;
				}

				public static Centikelvins operator +(Centikelvins first, Yottakelvins second)
				{
					return new Centikelvins(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Decikelvins : IValueWithUnit, IEquatable< Decikelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Decikelvins Zero = new Decikelvins(0);
			public static readonly Decikelvins One = new Decikelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.decikelvin; } }

			public Decikelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*0.1);
				}
				
			public bool Equals(Decikelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decikelvins(double value)
			{
				return new Decikelvins(value);
			}

			public static Decikelvins operator *(Decikelvins value, double times)
			{
				return new Decikelvins(value.value * times);
			}

			public static Decikelvins operator *(double times, Decikelvins value)
			{
				return new Decikelvins(value.value * times);
			}

			public static Decikelvins operator +(Decikelvins first, Decikelvins second)
			{
				return new Decikelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Decikelvins value)
				{
					return (value.value)*0.1;
				}

				public static Decikelvins operator +(Decikelvins first, Kelvins second)
				{
					return new Decikelvins(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctokelvins(Decikelvins value)
				{
					return (value.value)*1E+23;
				}

				public static Decikelvins operator +(Decikelvins first, Yoctokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptokelvins(Decikelvins value)
				{
					return (value.value)*1E+20;
				}

				public static Decikelvins operator +(Decikelvins first, Zeptokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attokelvins(Decikelvins value)
				{
					return (value.value)*1E+17;
				}

				public static Decikelvins operator +(Decikelvins first, Attokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtokelvins(Decikelvins value)
				{
					return (value.value)*100000000000000;
				}

				public static Decikelvins operator +(Decikelvins first, Femtokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picokelvins(Decikelvins value)
				{
					return (value.value)*100000000000;
				}

				public static Decikelvins operator +(Decikelvins first, Picokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanokelvins(Decikelvins value)
				{
					return (value.value)*100000000;
				}

				public static Decikelvins operator +(Decikelvins first, Nanokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-08);
				}
								public static implicit operator Microkelvins(Decikelvins value)
				{
					return (value.value)*100000;
				}

				public static Decikelvins operator +(Decikelvins first, Microkelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E-05);
				}
								public static implicit operator Millikelvins(Decikelvins value)
				{
					return (value.value)*100;
				}

				public static Decikelvins operator +(Decikelvins first, Millikelvins second)
				{
					return new Decikelvins(first.value + (second.value)*0.01);
				}
								public static implicit operator Centikelvins(Decikelvins value)
				{
					return (value.value)*10;
				}

				public static Decikelvins operator +(Decikelvins first, Centikelvins second)
				{
					return new Decikelvins(first.value + (second.value)*0.1);
				}
								public static implicit operator Decakelvins(Decikelvins value)
				{
					return (value.value)*0.01;
				}

				public static Decikelvins operator +(Decikelvins first, Decakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*100);
				}
								public static implicit operator Hectokelvins(Decikelvins value)
				{
					return (value.value)*0.001;
				}

				public static Decikelvins operator +(Decikelvins first, Hectokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Kilokelvins(Decikelvins value)
				{
					return (value.value)*0.0001;
				}

				public static Decikelvins operator +(Decikelvins first, Kilokelvins second)
				{
					return new Decikelvins(first.value + (second.value)*10000);
				}
								public static implicit operator Megakelvins(Decikelvins value)
				{
					return (value.value)*1E-07;
				}

				public static Decikelvins operator +(Decikelvins first, Megakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigakelvins(Decikelvins value)
				{
					return (value.value)*1E-10;
				}

				public static Decikelvins operator +(Decikelvins first, Gigakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*10000000000);
				}
								public static implicit operator Terakelvins(Decikelvins value)
				{
					return (value.value)*1E-13;
				}

				public static Decikelvins operator +(Decikelvins first, Terakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petakelvins(Decikelvins value)
				{
					return (value.value)*1E-16;
				}

				public static Decikelvins operator +(Decikelvins first, Petakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E+16);
				}
								public static implicit operator Exakelvins(Decikelvins value)
				{
					return (value.value)*1E-19;
				}

				public static Decikelvins operator +(Decikelvins first, Exakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettakelvins(Decikelvins value)
				{
					return (value.value)*1E-22;
				}

				public static Decikelvins operator +(Decikelvins first, Zettakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottakelvins(Decikelvins value)
				{
					return (value.value)*1E-25;
				}

				public static Decikelvins operator +(Decikelvins first, Yottakelvins second)
				{
					return new Decikelvins(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decakelvins : IValueWithUnit, IEquatable< Decakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Decakelvins Zero = new Decakelvins(0);
			public static readonly Decakelvins One = new Decakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.decakelvin; } }

			public Decakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} daK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*10);
				}
				
			public bool Equals(Decakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decakelvins(double value)
			{
				return new Decakelvins(value);
			}

			public static Decakelvins operator *(Decakelvins value, double times)
			{
				return new Decakelvins(value.value * times);
			}

			public static Decakelvins operator *(double times, Decakelvins value)
			{
				return new Decakelvins(value.value * times);
			}

			public static Decakelvins operator +(Decakelvins first, Decakelvins second)
			{
				return new Decakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Decakelvins value)
				{
					return (value.value)*10;
				}

				public static Decakelvins operator +(Decakelvins first, Kelvins second)
				{
					return new Decakelvins(first.value + (second.value)/10);
				}
								public static implicit operator Yoctokelvins(Decakelvins value)
				{
					return (value.value)*1E+25;
				}

				public static Decakelvins operator +(Decakelvins first, Yoctokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptokelvins(Decakelvins value)
				{
					return (value.value)*1E+22;
				}

				public static Decakelvins operator +(Decakelvins first, Zeptokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attokelvins(Decakelvins value)
				{
					return (value.value)*1E+19;
				}

				public static Decakelvins operator +(Decakelvins first, Attokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtokelvins(Decakelvins value)
				{
					return (value.value)*1E+16;
				}

				public static Decakelvins operator +(Decakelvins first, Femtokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picokelvins(Decakelvins value)
				{
					return (value.value)*10000000000000;
				}

				public static Decakelvins operator +(Decakelvins first, Picokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanokelvins(Decakelvins value)
				{
					return (value.value)*10000000000;
				}

				public static Decakelvins operator +(Decakelvins first, Nanokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-10);
				}
								public static implicit operator Microkelvins(Decakelvins value)
				{
					return (value.value)*10000000;
				}

				public static Decakelvins operator +(Decakelvins first, Microkelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E-07);
				}
								public static implicit operator Millikelvins(Decakelvins value)
				{
					return (value.value)*10000;
				}

				public static Decakelvins operator +(Decakelvins first, Millikelvins second)
				{
					return new Decakelvins(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centikelvins(Decakelvins value)
				{
					return (value.value)*1000;
				}

				public static Decakelvins operator +(Decakelvins first, Centikelvins second)
				{
					return new Decakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Decikelvins(Decakelvins value)
				{
					return (value.value)*100;
				}

				public static Decakelvins operator +(Decakelvins first, Decikelvins second)
				{
					return new Decakelvins(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectokelvins(Decakelvins value)
				{
					return (value.value)*0.1;
				}

				public static Decakelvins operator +(Decakelvins first, Hectokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*10);
				}
								public static implicit operator Kilokelvins(Decakelvins value)
				{
					return (value.value)*0.01;
				}

				public static Decakelvins operator +(Decakelvins first, Kilokelvins second)
				{
					return new Decakelvins(first.value + (second.value)*100);
				}
								public static implicit operator Megakelvins(Decakelvins value)
				{
					return (value.value)*1E-05;
				}

				public static Decakelvins operator +(Decakelvins first, Megakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*100000);
				}
								public static implicit operator Gigakelvins(Decakelvins value)
				{
					return (value.value)*1E-08;
				}

				public static Decakelvins operator +(Decakelvins first, Gigakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*100000000);
				}
								public static implicit operator Terakelvins(Decakelvins value)
				{
					return (value.value)*1E-11;
				}

				public static Decakelvins operator +(Decakelvins first, Terakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petakelvins(Decakelvins value)
				{
					return (value.value)*1E-14;
				}

				public static Decakelvins operator +(Decakelvins first, Petakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Exakelvins(Decakelvins value)
				{
					return (value.value)*1E-17;
				}

				public static Decakelvins operator +(Decakelvins first, Exakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettakelvins(Decakelvins value)
				{
					return (value.value)*1E-20;
				}

				public static Decakelvins operator +(Decakelvins first, Zettakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottakelvins(Decakelvins value)
				{
					return (value.value)*1E-23;
				}

				public static Decakelvins operator +(Decakelvins first, Yottakelvins second)
				{
					return new Decakelvins(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectokelvins : IValueWithUnit, IEquatable< Hectokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectokelvins Zero = new Hectokelvins(0);
			public static readonly Hectokelvins One = new Hectokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.hectokelvin; } }

			public Hectokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*100);
				}
				
			public bool Equals(Hectokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectokelvins(double value)
			{
				return new Hectokelvins(value);
			}

			public static Hectokelvins operator *(Hectokelvins value, double times)
			{
				return new Hectokelvins(value.value * times);
			}

			public static Hectokelvins operator *(double times, Hectokelvins value)
			{
				return new Hectokelvins(value.value * times);
			}

			public static Hectokelvins operator +(Hectokelvins first, Hectokelvins second)
			{
				return new Hectokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Hectokelvins value)
				{
					return (value.value)*100;
				}

				public static Hectokelvins operator +(Hectokelvins first, Kelvins second)
				{
					return new Hectokelvins(first.value + (second.value)/100);
				}
								public static implicit operator Yoctokelvins(Hectokelvins value)
				{
					return (value.value)*1E+26;
				}

				public static Hectokelvins operator +(Hectokelvins first, Yoctokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptokelvins(Hectokelvins value)
				{
					return (value.value)*1E+23;
				}

				public static Hectokelvins operator +(Hectokelvins first, Zeptokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attokelvins(Hectokelvins value)
				{
					return (value.value)*1E+20;
				}

				public static Hectokelvins operator +(Hectokelvins first, Attokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtokelvins(Hectokelvins value)
				{
					return (value.value)*1E+17;
				}

				public static Hectokelvins operator +(Hectokelvins first, Femtokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picokelvins(Hectokelvins value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectokelvins operator +(Hectokelvins first, Picokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanokelvins(Hectokelvins value)
				{
					return (value.value)*100000000000;
				}

				public static Hectokelvins operator +(Hectokelvins first, Nanokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-11);
				}
								public static implicit operator Microkelvins(Hectokelvins value)
				{
					return (value.value)*100000000;
				}

				public static Hectokelvins operator +(Hectokelvins first, Microkelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-08);
				}
								public static implicit operator Millikelvins(Hectokelvins value)
				{
					return (value.value)*100000;
				}

				public static Hectokelvins operator +(Hectokelvins first, Millikelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centikelvins(Hectokelvins value)
				{
					return (value.value)*10000;
				}

				public static Hectokelvins operator +(Hectokelvins first, Centikelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decikelvins(Hectokelvins value)
				{
					return (value.value)*1000;
				}

				public static Hectokelvins operator +(Hectokelvins first, Decikelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Decakelvins(Hectokelvins value)
				{
					return (value.value)*10;
				}

				public static Hectokelvins operator +(Hectokelvins first, Decakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*0.1);
				}
								public static implicit operator Kilokelvins(Hectokelvins value)
				{
					return (value.value)*0.1;
				}

				public static Hectokelvins operator +(Hectokelvins first, Kilokelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*10);
				}
								public static implicit operator Megakelvins(Hectokelvins value)
				{
					return (value.value)*0.0001;
				}

				public static Hectokelvins operator +(Hectokelvins first, Megakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*10000);
				}
								public static implicit operator Gigakelvins(Hectokelvins value)
				{
					return (value.value)*1E-07;
				}

				public static Hectokelvins operator +(Hectokelvins first, Gigakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*10000000);
				}
								public static implicit operator Terakelvins(Hectokelvins value)
				{
					return (value.value)*1E-10;
				}

				public static Hectokelvins operator +(Hectokelvins first, Terakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petakelvins(Hectokelvins value)
				{
					return (value.value)*1E-13;
				}

				public static Hectokelvins operator +(Hectokelvins first, Petakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Exakelvins(Hectokelvins value)
				{
					return (value.value)*1E-16;
				}

				public static Hectokelvins operator +(Hectokelvins first, Exakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettakelvins(Hectokelvins value)
				{
					return (value.value)*1E-19;
				}

				public static Hectokelvins operator +(Hectokelvins first, Zettakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottakelvins(Hectokelvins value)
				{
					return (value.value)*1E-22;
				}

				public static Hectokelvins operator +(Hectokelvins first, Yottakelvins second)
				{
					return new Hectokelvins(first.value + (second.value)*1E+22);
				}
						}
		}
namespace Multiples
{

		public struct Kilokelvins : IValueWithUnit, IEquatable< Kilokelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Kilokelvins Zero = new Kilokelvins(0);
			public static readonly Kilokelvins One = new Kilokelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.kilokelvin; } }

			public Kilokelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} kK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1000);
				}
				
			public bool Equals(Kilokelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kilokelvins(double value)
			{
				return new Kilokelvins(value);
			}

			public static Kilokelvins operator *(Kilokelvins value, double times)
			{
				return new Kilokelvins(value.value * times);
			}

			public static Kilokelvins operator *(double times, Kilokelvins value)
			{
				return new Kilokelvins(value.value * times);
			}

			public static Kilokelvins operator +(Kilokelvins first, Kilokelvins second)
			{
				return new Kilokelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Kilokelvins value)
				{
					return (value.value)*1000;
				}

				public static Kilokelvins operator +(Kilokelvins first, Kelvins second)
				{
					return new Kilokelvins(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctokelvins(Kilokelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Kilokelvins operator +(Kilokelvins first, Yoctokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptokelvins(Kilokelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Kilokelvins operator +(Kilokelvins first, Zeptokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attokelvins(Kilokelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Kilokelvins operator +(Kilokelvins first, Attokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtokelvins(Kilokelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Kilokelvins operator +(Kilokelvins first, Femtokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picokelvins(Kilokelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Kilokelvins operator +(Kilokelvins first, Picokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanokelvins(Kilokelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Kilokelvins operator +(Kilokelvins first, Nanokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Microkelvins(Kilokelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Kilokelvins operator +(Kilokelvins first, Microkelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Millikelvins(Kilokelvins value)
				{
					return (value.value)*1000000;
				}

				public static Kilokelvins operator +(Kilokelvins first, Millikelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centikelvins(Kilokelvins value)
				{
					return (value.value)*100000;
				}

				public static Kilokelvins operator +(Kilokelvins first, Centikelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E-05);
				}
								public static implicit operator Decikelvins(Kilokelvins value)
				{
					return (value.value)*10000;
				}

				public static Kilokelvins operator +(Kilokelvins first, Decikelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decakelvins(Kilokelvins value)
				{
					return (value.value)*100;
				}

				public static Kilokelvins operator +(Kilokelvins first, Decakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectokelvins(Kilokelvins value)
				{
					return (value.value)*10;
				}

				public static Kilokelvins operator +(Kilokelvins first, Hectokelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*0.1);
				}
								public static implicit operator Megakelvins(Kilokelvins value)
				{
					return (value.value)*0.001;
				}

				public static Kilokelvins operator +(Kilokelvins first, Megakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Gigakelvins(Kilokelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Kilokelvins operator +(Kilokelvins first, Gigakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Terakelvins(Kilokelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Kilokelvins operator +(Kilokelvins first, Terakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petakelvins(Kilokelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Kilokelvins operator +(Kilokelvins first, Petakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Exakelvins(Kilokelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Kilokelvins operator +(Kilokelvins first, Exakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettakelvins(Kilokelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Kilokelvins operator +(Kilokelvins first, Zettakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottakelvins(Kilokelvins value)
				{
					return (value.value)*1E-21;
				}

				public static Kilokelvins operator +(Kilokelvins first, Yottakelvins second)
				{
					return new Kilokelvins(first.value + (second.value)*1E+21);
				}
						}
		}
namespace Multiples
{

		public struct Megakelvins : IValueWithUnit, IEquatable< Megakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Megakelvins Zero = new Megakelvins(0);
			public static readonly Megakelvins One = new Megakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.megakelvin; } }

			public Megakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} MK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1000000);
				}
				
			public bool Equals(Megakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megakelvins(double value)
			{
				return new Megakelvins(value);
			}

			public static Megakelvins operator *(Megakelvins value, double times)
			{
				return new Megakelvins(value.value * times);
			}

			public static Megakelvins operator *(double times, Megakelvins value)
			{
				return new Megakelvins(value.value * times);
			}

			public static Megakelvins operator +(Megakelvins first, Megakelvins second)
			{
				return new Megakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Megakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Megakelvins operator +(Megakelvins first, Kelvins second)
				{
					return new Megakelvins(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctokelvins(Megakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Megakelvins operator +(Megakelvins first, Yoctokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptokelvins(Megakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Megakelvins operator +(Megakelvins first, Zeptokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attokelvins(Megakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Megakelvins operator +(Megakelvins first, Attokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtokelvins(Megakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Megakelvins operator +(Megakelvins first, Femtokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picokelvins(Megakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Megakelvins operator +(Megakelvins first, Picokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanokelvins(Megakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Megakelvins operator +(Megakelvins first, Nanokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Microkelvins(Megakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Megakelvins operator +(Megakelvins first, Microkelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Millikelvins(Megakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Megakelvins operator +(Megakelvins first, Millikelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centikelvins(Megakelvins value)
				{
					return (value.value)*100000000;
				}

				public static Megakelvins operator +(Megakelvins first, Centikelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-08);
				}
								public static implicit operator Decikelvins(Megakelvins value)
				{
					return (value.value)*10000000;
				}

				public static Megakelvins operator +(Megakelvins first, Decikelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decakelvins(Megakelvins value)
				{
					return (value.value)*100000;
				}

				public static Megakelvins operator +(Megakelvins first, Decakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectokelvins(Megakelvins value)
				{
					return (value.value)*10000;
				}

				public static Megakelvins operator +(Megakelvins first, Hectokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kilokelvins(Megakelvins value)
				{
					return (value.value)*1000;
				}

				public static Megakelvins operator +(Megakelvins first, Kilokelvins second)
				{
					return new Megakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigakelvins(Megakelvins value)
				{
					return (value.value)*0.001;
				}

				public static Megakelvins operator +(Megakelvins first, Gigakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Terakelvins(Megakelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Megakelvins operator +(Megakelvins first, Terakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Petakelvins(Megakelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Megakelvins operator +(Megakelvins first, Petakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Exakelvins(Megakelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Megakelvins operator +(Megakelvins first, Exakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettakelvins(Megakelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Megakelvins operator +(Megakelvins first, Zettakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottakelvins(Megakelvins value)
				{
					return (value.value)*1E-18;
				}

				public static Megakelvins operator +(Megakelvins first, Yottakelvins second)
				{
					return new Megakelvins(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigakelvins : IValueWithUnit, IEquatable< Gigakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigakelvins Zero = new Gigakelvins(0);
			public static readonly Gigakelvins One = new Gigakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.gigakelvin; } }

			public Gigakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} GK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1000000000);
				}
				
			public bool Equals(Gigakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigakelvins(double value)
			{
				return new Gigakelvins(value);
			}

			public static Gigakelvins operator *(Gigakelvins value, double times)
			{
				return new Gigakelvins(value.value * times);
			}

			public static Gigakelvins operator *(double times, Gigakelvins value)
			{
				return new Gigakelvins(value.value * times);
			}

			public static Gigakelvins operator +(Gigakelvins first, Gigakelvins second)
			{
				return new Gigakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Gigakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Kelvins second)
				{
					return new Gigakelvins(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctokelvins(Gigakelvins value)
				{
					return (value.value)*1E+33;
				}

				public static Gigakelvins operator +(Gigakelvins first, Yoctokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptokelvins(Gigakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Gigakelvins operator +(Gigakelvins first, Zeptokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attokelvins(Gigakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Gigakelvins operator +(Gigakelvins first, Attokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtokelvins(Gigakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Gigakelvins operator +(Gigakelvins first, Femtokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picokelvins(Gigakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Gigakelvins operator +(Gigakelvins first, Picokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanokelvins(Gigakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Gigakelvins operator +(Gigakelvins first, Nanokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Microkelvins(Gigakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Gigakelvins operator +(Gigakelvins first, Microkelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Millikelvins(Gigakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Millikelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centikelvins(Gigakelvins value)
				{
					return (value.value)*100000000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Centikelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-11);
				}
								public static implicit operator Decikelvins(Gigakelvins value)
				{
					return (value.value)*10000000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Decikelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decakelvins(Gigakelvins value)
				{
					return (value.value)*100000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Decakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectokelvins(Gigakelvins value)
				{
					return (value.value)*10000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Hectokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kilokelvins(Gigakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Kilokelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megakelvins(Gigakelvins value)
				{
					return (value.value)*1000;
				}

				public static Gigakelvins operator +(Gigakelvins first, Megakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Terakelvins(Gigakelvins value)
				{
					return (value.value)*0.001;
				}

				public static Gigakelvins operator +(Gigakelvins first, Terakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Petakelvins(Gigakelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Gigakelvins operator +(Gigakelvins first, Petakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Exakelvins(Gigakelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Gigakelvins operator +(Gigakelvins first, Exakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettakelvins(Gigakelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Gigakelvins operator +(Gigakelvins first, Zettakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottakelvins(Gigakelvins value)
				{
					return (value.value)*1E-15;
				}

				public static Gigakelvins operator +(Gigakelvins first, Yottakelvins second)
				{
					return new Gigakelvins(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Terakelvins : IValueWithUnit, IEquatable< Terakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Terakelvins Zero = new Terakelvins(0);
			public static readonly Terakelvins One = new Terakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.terakelvin; } }

			public Terakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} TK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1000000000000);
				}
				
			public bool Equals(Terakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Terakelvins(double value)
			{
				return new Terakelvins(value);
			}

			public static Terakelvins operator *(Terakelvins value, double times)
			{
				return new Terakelvins(value.value * times);
			}

			public static Terakelvins operator *(double times, Terakelvins value)
			{
				return new Terakelvins(value.value * times);
			}

			public static Terakelvins operator +(Terakelvins first, Terakelvins second)
			{
				return new Terakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Terakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Terakelvins operator +(Terakelvins first, Kelvins second)
				{
					return new Terakelvins(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctokelvins(Terakelvins value)
				{
					return (value.value)*1E+36;
				}

				public static Terakelvins operator +(Terakelvins first, Yoctokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptokelvins(Terakelvins value)
				{
					return (value.value)*1E+33;
				}

				public static Terakelvins operator +(Terakelvins first, Zeptokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attokelvins(Terakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Terakelvins operator +(Terakelvins first, Attokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtokelvins(Terakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Terakelvins operator +(Terakelvins first, Femtokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picokelvins(Terakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Terakelvins operator +(Terakelvins first, Picokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanokelvins(Terakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Terakelvins operator +(Terakelvins first, Nanokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Microkelvins(Terakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Terakelvins operator +(Terakelvins first, Microkelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Millikelvins(Terakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Terakelvins operator +(Terakelvins first, Millikelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centikelvins(Terakelvins value)
				{
					return (value.value)*100000000000000;
				}

				public static Terakelvins operator +(Terakelvins first, Centikelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-14);
				}
								public static implicit operator Decikelvins(Terakelvins value)
				{
					return (value.value)*10000000000000;
				}

				public static Terakelvins operator +(Terakelvins first, Decikelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decakelvins(Terakelvins value)
				{
					return (value.value)*100000000000;
				}

				public static Terakelvins operator +(Terakelvins first, Decakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectokelvins(Terakelvins value)
				{
					return (value.value)*10000000000;
				}

				public static Terakelvins operator +(Terakelvins first, Hectokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kilokelvins(Terakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Terakelvins operator +(Terakelvins first, Kilokelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megakelvins(Terakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Terakelvins operator +(Terakelvins first, Megakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigakelvins(Terakelvins value)
				{
					return (value.value)*1000;
				}

				public static Terakelvins operator +(Terakelvins first, Gigakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Petakelvins(Terakelvins value)
				{
					return (value.value)*0.001;
				}

				public static Terakelvins operator +(Terakelvins first, Petakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Exakelvins(Terakelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Terakelvins operator +(Terakelvins first, Exakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettakelvins(Terakelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Terakelvins operator +(Terakelvins first, Zettakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottakelvins(Terakelvins value)
				{
					return (value.value)*1E-12;
				}

				public static Terakelvins operator +(Terakelvins first, Yottakelvins second)
				{
					return new Terakelvins(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petakelvins : IValueWithUnit, IEquatable< Petakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Petakelvins Zero = new Petakelvins(0);
			public static readonly Petakelvins One = new Petakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.petakelvin; } }

			public Petakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} PK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E+15);
				}
				
			public bool Equals(Petakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petakelvins(double value)
			{
				return new Petakelvins(value);
			}

			public static Petakelvins operator *(Petakelvins value, double times)
			{
				return new Petakelvins(value.value * times);
			}

			public static Petakelvins operator *(double times, Petakelvins value)
			{
				return new Petakelvins(value.value * times);
			}

			public static Petakelvins operator +(Petakelvins first, Petakelvins second)
			{
				return new Petakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Petakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Petakelvins operator +(Petakelvins first, Kelvins second)
				{
					return new Petakelvins(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctokelvins(Petakelvins value)
				{
					return (value.value)*1E+39;
				}

				public static Petakelvins operator +(Petakelvins first, Yoctokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptokelvins(Petakelvins value)
				{
					return (value.value)*1E+36;
				}

				public static Petakelvins operator +(Petakelvins first, Zeptokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attokelvins(Petakelvins value)
				{
					return (value.value)*1E+33;
				}

				public static Petakelvins operator +(Petakelvins first, Attokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtokelvins(Petakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Petakelvins operator +(Petakelvins first, Femtokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picokelvins(Petakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Petakelvins operator +(Petakelvins first, Picokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanokelvins(Petakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Petakelvins operator +(Petakelvins first, Nanokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Microkelvins(Petakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Petakelvins operator +(Petakelvins first, Microkelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Millikelvins(Petakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Petakelvins operator +(Petakelvins first, Millikelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centikelvins(Petakelvins value)
				{
					return (value.value)*1E+17;
				}

				public static Petakelvins operator +(Petakelvins first, Centikelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-17);
				}
								public static implicit operator Decikelvins(Petakelvins value)
				{
					return (value.value)*1E+16;
				}

				public static Petakelvins operator +(Petakelvins first, Decikelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decakelvins(Petakelvins value)
				{
					return (value.value)*100000000000000;
				}

				public static Petakelvins operator +(Petakelvins first, Decakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectokelvins(Petakelvins value)
				{
					return (value.value)*10000000000000;
				}

				public static Petakelvins operator +(Petakelvins first, Hectokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kilokelvins(Petakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Petakelvins operator +(Petakelvins first, Kilokelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megakelvins(Petakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Petakelvins operator +(Petakelvins first, Megakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigakelvins(Petakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Petakelvins operator +(Petakelvins first, Gigakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Terakelvins(Petakelvins value)
				{
					return (value.value)*1000;
				}

				public static Petakelvins operator +(Petakelvins first, Terakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Exakelvins(Petakelvins value)
				{
					return (value.value)*0.001;
				}

				public static Petakelvins operator +(Petakelvins first, Exakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Zettakelvins(Petakelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Petakelvins operator +(Petakelvins first, Zettakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottakelvins(Petakelvins value)
				{
					return (value.value)*1E-09;
				}

				public static Petakelvins operator +(Petakelvins first, Yottakelvins second)
				{
					return new Petakelvins(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Exakelvins : IValueWithUnit, IEquatable< Exakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Exakelvins Zero = new Exakelvins(0);
			public static readonly Exakelvins One = new Exakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.exakelvin; } }

			public Exakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} EK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E+18);
				}
				
			public bool Equals(Exakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Exakelvins(double value)
			{
				return new Exakelvins(value);
			}

			public static Exakelvins operator *(Exakelvins value, double times)
			{
				return new Exakelvins(value.value * times);
			}

			public static Exakelvins operator *(double times, Exakelvins value)
			{
				return new Exakelvins(value.value * times);
			}

			public static Exakelvins operator +(Exakelvins first, Exakelvins second)
			{
				return new Exakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Exakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Exakelvins operator +(Exakelvins first, Kelvins second)
				{
					return new Exakelvins(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctokelvins(Exakelvins value)
				{
					return (value.value)*1E+42;
				}

				public static Exakelvins operator +(Exakelvins first, Yoctokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptokelvins(Exakelvins value)
				{
					return (value.value)*1E+39;
				}

				public static Exakelvins operator +(Exakelvins first, Zeptokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attokelvins(Exakelvins value)
				{
					return (value.value)*1E+36;
				}

				public static Exakelvins operator +(Exakelvins first, Attokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtokelvins(Exakelvins value)
				{
					return (value.value)*1E+33;
				}

				public static Exakelvins operator +(Exakelvins first, Femtokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picokelvins(Exakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Exakelvins operator +(Exakelvins first, Picokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanokelvins(Exakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Exakelvins operator +(Exakelvins first, Nanokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Microkelvins(Exakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Exakelvins operator +(Exakelvins first, Microkelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Millikelvins(Exakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Exakelvins operator +(Exakelvins first, Millikelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centikelvins(Exakelvins value)
				{
					return (value.value)*1E+20;
				}

				public static Exakelvins operator +(Exakelvins first, Centikelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-20);
				}
								public static implicit operator Decikelvins(Exakelvins value)
				{
					return (value.value)*1E+19;
				}

				public static Exakelvins operator +(Exakelvins first, Decikelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decakelvins(Exakelvins value)
				{
					return (value.value)*1E+17;
				}

				public static Exakelvins operator +(Exakelvins first, Decakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectokelvins(Exakelvins value)
				{
					return (value.value)*1E+16;
				}

				public static Exakelvins operator +(Exakelvins first, Hectokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kilokelvins(Exakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Exakelvins operator +(Exakelvins first, Kilokelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megakelvins(Exakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Exakelvins operator +(Exakelvins first, Megakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigakelvins(Exakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Exakelvins operator +(Exakelvins first, Gigakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Terakelvins(Exakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Exakelvins operator +(Exakelvins first, Terakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petakelvins(Exakelvins value)
				{
					return (value.value)*1000;
				}

				public static Exakelvins operator +(Exakelvins first, Petakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettakelvins(Exakelvins value)
				{
					return (value.value)*0.001;
				}

				public static Exakelvins operator +(Exakelvins first, Zettakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1000);
				}
								public static implicit operator Yottakelvins(Exakelvins value)
				{
					return (value.value)*1E-06;
				}

				public static Exakelvins operator +(Exakelvins first, Yottakelvins second)
				{
					return new Exakelvins(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettakelvins : IValueWithUnit, IEquatable< Zettakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettakelvins Zero = new Zettakelvins(0);
			public static readonly Zettakelvins One = new Zettakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.zettakelvin; } }

			public Zettakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ZK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E+21);
				}
				
			public bool Equals(Zettakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettakelvins(double value)
			{
				return new Zettakelvins(value);
			}

			public static Zettakelvins operator *(Zettakelvins value, double times)
			{
				return new Zettakelvins(value.value * times);
			}

			public static Zettakelvins operator *(double times, Zettakelvins value)
			{
				return new Zettakelvins(value.value * times);
			}

			public static Zettakelvins operator +(Zettakelvins first, Zettakelvins second)
			{
				return new Zettakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Zettakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Zettakelvins operator +(Zettakelvins first, Kelvins second)
				{
					return new Zettakelvins(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctokelvins(Zettakelvins value)
				{
					return (value.value)*1E+45;
				}

				public static Zettakelvins operator +(Zettakelvins first, Yoctokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptokelvins(Zettakelvins value)
				{
					return (value.value)*1E+42;
				}

				public static Zettakelvins operator +(Zettakelvins first, Zeptokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attokelvins(Zettakelvins value)
				{
					return (value.value)*1E+39;
				}

				public static Zettakelvins operator +(Zettakelvins first, Attokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtokelvins(Zettakelvins value)
				{
					return (value.value)*1E+36;
				}

				public static Zettakelvins operator +(Zettakelvins first, Femtokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picokelvins(Zettakelvins value)
				{
					return (value.value)*1E+33;
				}

				public static Zettakelvins operator +(Zettakelvins first, Picokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanokelvins(Zettakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Zettakelvins operator +(Zettakelvins first, Nanokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Microkelvins(Zettakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Zettakelvins operator +(Zettakelvins first, Microkelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Millikelvins(Zettakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Zettakelvins operator +(Zettakelvins first, Millikelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centikelvins(Zettakelvins value)
				{
					return (value.value)*1E+23;
				}

				public static Zettakelvins operator +(Zettakelvins first, Centikelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-23);
				}
								public static implicit operator Decikelvins(Zettakelvins value)
				{
					return (value.value)*1E+22;
				}

				public static Zettakelvins operator +(Zettakelvins first, Decikelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decakelvins(Zettakelvins value)
				{
					return (value.value)*1E+20;
				}

				public static Zettakelvins operator +(Zettakelvins first, Decakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectokelvins(Zettakelvins value)
				{
					return (value.value)*1E+19;
				}

				public static Zettakelvins operator +(Zettakelvins first, Hectokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kilokelvins(Zettakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Zettakelvins operator +(Zettakelvins first, Kilokelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megakelvins(Zettakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Zettakelvins operator +(Zettakelvins first, Megakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigakelvins(Zettakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettakelvins operator +(Zettakelvins first, Gigakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Terakelvins(Zettakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Zettakelvins operator +(Zettakelvins first, Terakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petakelvins(Zettakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Zettakelvins operator +(Zettakelvins first, Petakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Exakelvins(Zettakelvins value)
				{
					return (value.value)*1000;
				}

				public static Zettakelvins operator +(Zettakelvins first, Exakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottakelvins(Zettakelvins value)
				{
					return (value.value)*0.001;
				}

				public static Zettakelvins operator +(Zettakelvins first, Yottakelvins second)
				{
					return new Zettakelvins(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottakelvins : IValueWithUnit, IEquatable< Yottakelvins >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottakelvins Zero = new Yottakelvins(0);
			public static readonly Yottakelvins One = new Yottakelvins(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return ThermodynamicTemperature.Units.yottakelvin; } }

			public Yottakelvins(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} YK", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Kelvins ToBaseUnit()
				{
					return new Kelvins((this.value)*1E+24);
				}
				
			public bool Equals(Yottakelvins other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottakelvins(double value)
			{
				return new Yottakelvins(value);
			}

			public static Yottakelvins operator *(Yottakelvins value, double times)
			{
				return new Yottakelvins(value.value * times);
			}

			public static Yottakelvins operator *(double times, Yottakelvins value)
			{
				return new Yottakelvins(value.value * times);
			}

			public static Yottakelvins operator +(Yottakelvins first, Yottakelvins second)
			{
				return new Yottakelvins(first.value * second.value);
			}

							public static implicit operator Kelvins(Yottakelvins value)
				{
					return (value.value)*1E+24;
				}

				public static Yottakelvins operator +(Yottakelvins first, Kelvins second)
				{
					return new Yottakelvins(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctokelvins(Yottakelvins value)
				{
					return (value.value)*1E+48;
				}

				public static Yottakelvins operator +(Yottakelvins first, Yoctokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptokelvins(Yottakelvins value)
				{
					return (value.value)*1E+45;
				}

				public static Yottakelvins operator +(Yottakelvins first, Zeptokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attokelvins(Yottakelvins value)
				{
					return (value.value)*1E+42;
				}

				public static Yottakelvins operator +(Yottakelvins first, Attokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtokelvins(Yottakelvins value)
				{
					return (value.value)*1E+39;
				}

				public static Yottakelvins operator +(Yottakelvins first, Femtokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picokelvins(Yottakelvins value)
				{
					return (value.value)*1E+36;
				}

				public static Yottakelvins operator +(Yottakelvins first, Picokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanokelvins(Yottakelvins value)
				{
					return (value.value)*1E+33;
				}

				public static Yottakelvins operator +(Yottakelvins first, Nanokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-33);
				}
								public static implicit operator Microkelvins(Yottakelvins value)
				{
					return (value.value)*1E+30;
				}

				public static Yottakelvins operator +(Yottakelvins first, Microkelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-30);
				}
								public static implicit operator Millikelvins(Yottakelvins value)
				{
					return (value.value)*1E+27;
				}

				public static Yottakelvins operator +(Yottakelvins first, Millikelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centikelvins(Yottakelvins value)
				{
					return (value.value)*1E+26;
				}

				public static Yottakelvins operator +(Yottakelvins first, Centikelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-26);
				}
								public static implicit operator Decikelvins(Yottakelvins value)
				{
					return (value.value)*1E+25;
				}

				public static Yottakelvins operator +(Yottakelvins first, Decikelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decakelvins(Yottakelvins value)
				{
					return (value.value)*1E+23;
				}

				public static Yottakelvins operator +(Yottakelvins first, Decakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectokelvins(Yottakelvins value)
				{
					return (value.value)*1E+22;
				}

				public static Yottakelvins operator +(Yottakelvins first, Hectokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kilokelvins(Yottakelvins value)
				{
					return (value.value)*1E+21;
				}

				public static Yottakelvins operator +(Yottakelvins first, Kilokelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megakelvins(Yottakelvins value)
				{
					return (value.value)*1E+18;
				}

				public static Yottakelvins operator +(Yottakelvins first, Megakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigakelvins(Yottakelvins value)
				{
					return (value.value)*1E+15;
				}

				public static Yottakelvins operator +(Yottakelvins first, Gigakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-15);
				}
								public static implicit operator Terakelvins(Yottakelvins value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottakelvins operator +(Yottakelvins first, Terakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petakelvins(Yottakelvins value)
				{
					return (value.value)*1000000000;
				}

				public static Yottakelvins operator +(Yottakelvins first, Petakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-09);
				}
								public static implicit operator Exakelvins(Yottakelvins value)
				{
					return (value.value)*1000000;
				}

				public static Yottakelvins operator +(Yottakelvins first, Exakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettakelvins(Yottakelvins value)
				{
					return (value.value)*1000;
				}

				public static Yottakelvins operator +(Yottakelvins first, Zettakelvins second)
				{
					return new Yottakelvins(first.value + (second.value)*0.001);
				}
						}
		}

		public struct Candelas : IValueWithUnit, IEquatable< Candelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Candelas Zero = new Candelas(0);
			public static readonly Candelas One = new Candelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.candela; } }

			public Candelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Candelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Candelas(double value)
			{
				return new Candelas(value);
			}

			public static Candelas operator *(Candelas value, double times)
			{
				return new Candelas(value.value * times);
			}

			public static Candelas operator *(double times, Candelas value)
			{
				return new Candelas(value.value * times);
			}

			public static Candelas operator +(Candelas first, Candelas second)
			{
				return new Candelas(first.value * second.value);
			}

							public static implicit operator Yoctocandelas(Candelas value)
				{
					return (value.value)/1E-24;
				}

				public static Candelas operator +(Candelas first, Yoctocandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptocandelas(Candelas value)
				{
					return (value.value)/1E-21;
				}

				public static Candelas operator +(Candelas first, Zeptocandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attocandelas(Candelas value)
				{
					return (value.value)/1E-18;
				}

				public static Candelas operator +(Candelas first, Attocandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtocandelas(Candelas value)
				{
					return (value.value)/1E-15;
				}

				public static Candelas operator +(Candelas first, Femtocandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picocandelas(Candelas value)
				{
					return (value.value)/1E-12;
				}

				public static Candelas operator +(Candelas first, Picocandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanocandelas(Candelas value)
				{
					return (value.value)/1E-09;
				}

				public static Candelas operator +(Candelas first, Nanocandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Microcandelas(Candelas value)
				{
					return (value.value)/1E-06;
				}

				public static Candelas operator +(Candelas first, Microcandelas second)
				{
					return new Candelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Millicandelas(Candelas value)
				{
					return (value.value)/0.001;
				}

				public static Candelas operator +(Candelas first, Millicandelas second)
				{
					return new Candelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Centicandelas(Candelas value)
				{
					return (value.value)/0.01;
				}

				public static Candelas operator +(Candelas first, Centicandelas second)
				{
					return new Candelas(first.value + (second.value)*0.01);
				}
								public static implicit operator Decicandelas(Candelas value)
				{
					return (value.value)/0.1;
				}

				public static Candelas operator +(Candelas first, Decicandelas second)
				{
					return new Candelas(first.value + (second.value)*0.1);
				}
								public static implicit operator Decacandelas(Candelas value)
				{
					return (value.value)/10;
				}

				public static Candelas operator +(Candelas first, Decacandelas second)
				{
					return new Candelas(first.value + (second.value)*10);
				}
								public static implicit operator Hectocandelas(Candelas value)
				{
					return (value.value)/100;
				}

				public static Candelas operator +(Candelas first, Hectocandelas second)
				{
					return new Candelas(first.value + (second.value)*100);
				}
								public static implicit operator Kilocandelas(Candelas value)
				{
					return (value.value)/1000;
				}

				public static Candelas operator +(Candelas first, Kilocandelas second)
				{
					return new Candelas(first.value + (second.value)*1000);
				}
								public static implicit operator Megacandelas(Candelas value)
				{
					return (value.value)/1000000;
				}

				public static Candelas operator +(Candelas first, Megacandelas second)
				{
					return new Candelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigacandelas(Candelas value)
				{
					return (value.value)/1000000000;
				}

				public static Candelas operator +(Candelas first, Gigacandelas second)
				{
					return new Candelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Teracandelas(Candelas value)
				{
					return (value.value)/1000000000000;
				}

				public static Candelas operator +(Candelas first, Teracandelas second)
				{
					return new Candelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petacandelas(Candelas value)
				{
					return (value.value)/1E+15;
				}

				public static Candelas operator +(Candelas first, Petacandelas second)
				{
					return new Candelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Exacandelas(Candelas value)
				{
					return (value.value)/1E+18;
				}

				public static Candelas operator +(Candelas first, Exacandelas second)
				{
					return new Candelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettacandelas(Candelas value)
				{
					return (value.value)/1E+21;
				}

				public static Candelas operator +(Candelas first, Zettacandelas second)
				{
					return new Candelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottacandelas(Candelas value)
				{
					return (value.value)/1E+24;
				}

				public static Candelas operator +(Candelas first, Yottacandelas second)
				{
					return new Candelas(first.value + (second.value)*1E+24);
				}
						}
		namespace Multiples
{

		public struct Yoctocandelas : IValueWithUnit, IEquatable< Yoctocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctocandelas Zero = new Yoctocandelas(0);
			public static readonly Yoctocandelas One = new Yoctocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.yoctocandela; } }

			public Yoctocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ycd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-24);
				}
				
			public bool Equals(Yoctocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctocandelas(double value)
			{
				return new Yoctocandelas(value);
			}

			public static Yoctocandelas operator *(Yoctocandelas value, double times)
			{
				return new Yoctocandelas(value.value * times);
			}

			public static Yoctocandelas operator *(double times, Yoctocandelas value)
			{
				return new Yoctocandelas(value.value * times);
			}

			public static Yoctocandelas operator +(Yoctocandelas first, Yoctocandelas second)
			{
				return new Yoctocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Yoctocandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Candelas second)
				{
					return new Yoctocandelas(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptocandelas(Yoctocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Zeptocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Attocandelas(Yoctocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Attocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtocandelas(Yoctocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Femtocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picocandelas(Yoctocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Picocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanocandelas(Yoctocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Nanocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Microcandelas(Yoctocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Microcandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Millicandelas(Yoctocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Millicandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centicandelas(Yoctocandelas value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Centicandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+22);
				}
								public static implicit operator Decicandelas(Yoctocandelas value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Decicandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Decacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectocandelas(Yoctocandelas value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Hectocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kilocandelas(Yoctocandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Kilocandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Megacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Gigacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+33);
				}
								public static implicit operator Teracandelas(Yoctocandelas value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Teracandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Petacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+39);
				}
								public static implicit operator Exacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Exacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Zettacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottacandelas(Yoctocandelas value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctocandelas operator +(Yoctocandelas first, Yottacandelas second)
				{
					return new Yoctocandelas(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptocandelas : IValueWithUnit, IEquatable< Zeptocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptocandelas Zero = new Zeptocandelas(0);
			public static readonly Zeptocandelas One = new Zeptocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.zeptocandela; } }

			public Zeptocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-21);
				}
				
			public bool Equals(Zeptocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptocandelas(double value)
			{
				return new Zeptocandelas(value);
			}

			public static Zeptocandelas operator *(Zeptocandelas value, double times)
			{
				return new Zeptocandelas(value.value * times);
			}

			public static Zeptocandelas operator *(double times, Zeptocandelas value)
			{
				return new Zeptocandelas(value.value * times);
			}

			public static Zeptocandelas operator +(Zeptocandelas first, Zeptocandelas second)
			{
				return new Zeptocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Zeptocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Candelas second)
				{
					return new Zeptocandelas(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctocandelas(Zeptocandelas value)
				{
					return (value.value)*1000;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Yoctocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Attocandelas(Zeptocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Attocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Femtocandelas(Zeptocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Femtocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Picocandelas(Zeptocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Picocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanocandelas(Zeptocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Nanocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Microcandelas(Zeptocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Microcandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Millicandelas(Zeptocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Millicandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centicandelas(Zeptocandelas value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Centicandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+19);
				}
								public static implicit operator Decicandelas(Zeptocandelas value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Decicandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Decacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectocandelas(Zeptocandelas value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Hectocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kilocandelas(Zeptocandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Kilocandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Megacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Gigacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+30);
				}
								public static implicit operator Teracandelas(Zeptocandelas value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Teracandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Petacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+36);
				}
								public static implicit operator Exacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Exacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Zettacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottacandelas(Zeptocandelas value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptocandelas operator +(Zeptocandelas first, Yottacandelas second)
				{
					return new Zeptocandelas(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attocandelas : IValueWithUnit, IEquatable< Attocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Attocandelas Zero = new Attocandelas(0);
			public static readonly Attocandelas One = new Attocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.attocandela; } }

			public Attocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} acd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-18);
				}
				
			public bool Equals(Attocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attocandelas(double value)
			{
				return new Attocandelas(value);
			}

			public static Attocandelas operator *(Attocandelas value, double times)
			{
				return new Attocandelas(value.value * times);
			}

			public static Attocandelas operator *(double times, Attocandelas value)
			{
				return new Attocandelas(value.value * times);
			}

			public static Attocandelas operator +(Attocandelas first, Attocandelas second)
			{
				return new Attocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Attocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Attocandelas operator +(Attocandelas first, Candelas second)
				{
					return new Attocandelas(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctocandelas(Attocandelas value)
				{
					return (value.value)*1000000;
				}

				public static Attocandelas operator +(Attocandelas first, Yoctocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptocandelas(Attocandelas value)
				{
					return (value.value)*1000;
				}

				public static Attocandelas operator +(Attocandelas first, Zeptocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtocandelas(Attocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Attocandelas operator +(Attocandelas first, Femtocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Picocandelas(Attocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Attocandelas operator +(Attocandelas first, Picocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanocandelas(Attocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Attocandelas operator +(Attocandelas first, Nanocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Microcandelas(Attocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Attocandelas operator +(Attocandelas first, Microcandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Millicandelas(Attocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Attocandelas operator +(Attocandelas first, Millicandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centicandelas(Attocandelas value)
				{
					return (value.value)*1E-16;
				}

				public static Attocandelas operator +(Attocandelas first, Centicandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+16);
				}
								public static implicit operator Decicandelas(Attocandelas value)
				{
					return (value.value)*1E-17;
				}

				public static Attocandelas operator +(Attocandelas first, Decicandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decacandelas(Attocandelas value)
				{
					return (value.value)*1E-19;
				}

				public static Attocandelas operator +(Attocandelas first, Decacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectocandelas(Attocandelas value)
				{
					return (value.value)*1E-20;
				}

				public static Attocandelas operator +(Attocandelas first, Hectocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kilocandelas(Attocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Attocandelas operator +(Attocandelas first, Kilocandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megacandelas(Attocandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Attocandelas operator +(Attocandelas first, Megacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigacandelas(Attocandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Attocandelas operator +(Attocandelas first, Gigacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Teracandelas(Attocandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Attocandelas operator +(Attocandelas first, Teracandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petacandelas(Attocandelas value)
				{
					return (value.value)*1E-33;
				}

				public static Attocandelas operator +(Attocandelas first, Petacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+33);
				}
								public static implicit operator Exacandelas(Attocandelas value)
				{
					return (value.value)*1E-36;
				}

				public static Attocandelas operator +(Attocandelas first, Exacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettacandelas(Attocandelas value)
				{
					return (value.value)*1E-39;
				}

				public static Attocandelas operator +(Attocandelas first, Zettacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottacandelas(Attocandelas value)
				{
					return (value.value)*1E-42;
				}

				public static Attocandelas operator +(Attocandelas first, Yottacandelas second)
				{
					return new Attocandelas(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtocandelas : IValueWithUnit, IEquatable< Femtocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtocandelas Zero = new Femtocandelas(0);
			public static readonly Femtocandelas One = new Femtocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.femtocandela; } }

			public Femtocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-15);
				}
				
			public bool Equals(Femtocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtocandelas(double value)
			{
				return new Femtocandelas(value);
			}

			public static Femtocandelas operator *(Femtocandelas value, double times)
			{
				return new Femtocandelas(value.value * times);
			}

			public static Femtocandelas operator *(double times, Femtocandelas value)
			{
				return new Femtocandelas(value.value * times);
			}

			public static Femtocandelas operator +(Femtocandelas first, Femtocandelas second)
			{
				return new Femtocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Femtocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Femtocandelas operator +(Femtocandelas first, Candelas second)
				{
					return new Femtocandelas(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctocandelas(Femtocandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Femtocandelas operator +(Femtocandelas first, Yoctocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptocandelas(Femtocandelas value)
				{
					return (value.value)*1000000;
				}

				public static Femtocandelas operator +(Femtocandelas first, Zeptocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attocandelas(Femtocandelas value)
				{
					return (value.value)*1000;
				}

				public static Femtocandelas operator +(Femtocandelas first, Attocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Picocandelas(Femtocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Femtocandelas operator +(Femtocandelas first, Picocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Nanocandelas(Femtocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Femtocandelas operator +(Femtocandelas first, Nanocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Microcandelas(Femtocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Femtocandelas operator +(Femtocandelas first, Microcandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Millicandelas(Femtocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Femtocandelas operator +(Femtocandelas first, Millicandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centicandelas(Femtocandelas value)
				{
					return (value.value)*1E-13;
				}

				public static Femtocandelas operator +(Femtocandelas first, Centicandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Decicandelas(Femtocandelas value)
				{
					return (value.value)*1E-14;
				}

				public static Femtocandelas operator +(Femtocandelas first, Decicandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decacandelas(Femtocandelas value)
				{
					return (value.value)*1E-16;
				}

				public static Femtocandelas operator +(Femtocandelas first, Decacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectocandelas(Femtocandelas value)
				{
					return (value.value)*1E-17;
				}

				public static Femtocandelas operator +(Femtocandelas first, Hectocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kilocandelas(Femtocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Femtocandelas operator +(Femtocandelas first, Kilocandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megacandelas(Femtocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Femtocandelas operator +(Femtocandelas first, Megacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigacandelas(Femtocandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Femtocandelas operator +(Femtocandelas first, Gigacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Teracandelas(Femtocandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Femtocandelas operator +(Femtocandelas first, Teracandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petacandelas(Femtocandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Femtocandelas operator +(Femtocandelas first, Petacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+30);
				}
								public static implicit operator Exacandelas(Femtocandelas value)
				{
					return (value.value)*1E-33;
				}

				public static Femtocandelas operator +(Femtocandelas first, Exacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettacandelas(Femtocandelas value)
				{
					return (value.value)*1E-36;
				}

				public static Femtocandelas operator +(Femtocandelas first, Zettacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottacandelas(Femtocandelas value)
				{
					return (value.value)*1E-39;
				}

				public static Femtocandelas operator +(Femtocandelas first, Yottacandelas second)
				{
					return new Femtocandelas(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picocandelas : IValueWithUnit, IEquatable< Picocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Picocandelas Zero = new Picocandelas(0);
			public static readonly Picocandelas One = new Picocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.picocandela; } }

			public Picocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} pcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-12);
				}
				
			public bool Equals(Picocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picocandelas(double value)
			{
				return new Picocandelas(value);
			}

			public static Picocandelas operator *(Picocandelas value, double times)
			{
				return new Picocandelas(value.value * times);
			}

			public static Picocandelas operator *(double times, Picocandelas value)
			{
				return new Picocandelas(value.value * times);
			}

			public static Picocandelas operator +(Picocandelas first, Picocandelas second)
			{
				return new Picocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Picocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Picocandelas operator +(Picocandelas first, Candelas second)
				{
					return new Picocandelas(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctocandelas(Picocandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Picocandelas operator +(Picocandelas first, Yoctocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptocandelas(Picocandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Picocandelas operator +(Picocandelas first, Zeptocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attocandelas(Picocandelas value)
				{
					return (value.value)*1000000;
				}

				public static Picocandelas operator +(Picocandelas first, Attocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtocandelas(Picocandelas value)
				{
					return (value.value)*1000;
				}

				public static Picocandelas operator +(Picocandelas first, Femtocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanocandelas(Picocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Picocandelas operator +(Picocandelas first, Nanocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Microcandelas(Picocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Picocandelas operator +(Picocandelas first, Microcandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Millicandelas(Picocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Picocandelas operator +(Picocandelas first, Millicandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centicandelas(Picocandelas value)
				{
					return (value.value)*1E-10;
				}

				public static Picocandelas operator +(Picocandelas first, Centicandelas second)
				{
					return new Picocandelas(first.value + (second.value)*10000000000);
				}
								public static implicit operator Decicandelas(Picocandelas value)
				{
					return (value.value)*1E-11;
				}

				public static Picocandelas operator +(Picocandelas first, Decicandelas second)
				{
					return new Picocandelas(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decacandelas(Picocandelas value)
				{
					return (value.value)*1E-13;
				}

				public static Picocandelas operator +(Picocandelas first, Decacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectocandelas(Picocandelas value)
				{
					return (value.value)*1E-14;
				}

				public static Picocandelas operator +(Picocandelas first, Hectocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kilocandelas(Picocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Picocandelas operator +(Picocandelas first, Kilocandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megacandelas(Picocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Picocandelas operator +(Picocandelas first, Megacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigacandelas(Picocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Picocandelas operator +(Picocandelas first, Gigacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Teracandelas(Picocandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Picocandelas operator +(Picocandelas first, Teracandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petacandelas(Picocandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Picocandelas operator +(Picocandelas first, Petacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Exacandelas(Picocandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Picocandelas operator +(Picocandelas first, Exacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettacandelas(Picocandelas value)
				{
					return (value.value)*1E-33;
				}

				public static Picocandelas operator +(Picocandelas first, Zettacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottacandelas(Picocandelas value)
				{
					return (value.value)*1E-36;
				}

				public static Picocandelas operator +(Picocandelas first, Yottacandelas second)
				{
					return new Picocandelas(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanocandelas : IValueWithUnit, IEquatable< Nanocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanocandelas Zero = new Nanocandelas(0);
			public static readonly Nanocandelas One = new Nanocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.nanocandela; } }

			public Nanocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ncd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-09);
				}
				
			public bool Equals(Nanocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanocandelas(double value)
			{
				return new Nanocandelas(value);
			}

			public static Nanocandelas operator *(Nanocandelas value, double times)
			{
				return new Nanocandelas(value.value * times);
			}

			public static Nanocandelas operator *(double times, Nanocandelas value)
			{
				return new Nanocandelas(value.value * times);
			}

			public static Nanocandelas operator +(Nanocandelas first, Nanocandelas second)
			{
				return new Nanocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Nanocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Nanocandelas operator +(Nanocandelas first, Candelas second)
				{
					return new Nanocandelas(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctocandelas(Nanocandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Nanocandelas operator +(Nanocandelas first, Yoctocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptocandelas(Nanocandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanocandelas operator +(Nanocandelas first, Zeptocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attocandelas(Nanocandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Nanocandelas operator +(Nanocandelas first, Attocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtocandelas(Nanocandelas value)
				{
					return (value.value)*1000000;
				}

				public static Nanocandelas operator +(Nanocandelas first, Femtocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picocandelas(Nanocandelas value)
				{
					return (value.value)*1000;
				}

				public static Nanocandelas operator +(Nanocandelas first, Picocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Microcandelas(Nanocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Nanocandelas operator +(Nanocandelas first, Microcandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Millicandelas(Nanocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Nanocandelas operator +(Nanocandelas first, Millicandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Centicandelas(Nanocandelas value)
				{
					return (value.value)*1E-07;
				}

				public static Nanocandelas operator +(Nanocandelas first, Centicandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*10000000);
				}
								public static implicit operator Decicandelas(Nanocandelas value)
				{
					return (value.value)*1E-08;
				}

				public static Nanocandelas operator +(Nanocandelas first, Decicandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*100000000);
				}
								public static implicit operator Decacandelas(Nanocandelas value)
				{
					return (value.value)*1E-10;
				}

				public static Nanocandelas operator +(Nanocandelas first, Decacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectocandelas(Nanocandelas value)
				{
					return (value.value)*1E-11;
				}

				public static Nanocandelas operator +(Nanocandelas first, Hectocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kilocandelas(Nanocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Nanocandelas operator +(Nanocandelas first, Kilocandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megacandelas(Nanocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Nanocandelas operator +(Nanocandelas first, Megacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigacandelas(Nanocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Nanocandelas operator +(Nanocandelas first, Gigacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Teracandelas(Nanocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Nanocandelas operator +(Nanocandelas first, Teracandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petacandelas(Nanocandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Nanocandelas operator +(Nanocandelas first, Petacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Exacandelas(Nanocandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Nanocandelas operator +(Nanocandelas first, Exacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettacandelas(Nanocandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Nanocandelas operator +(Nanocandelas first, Zettacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottacandelas(Nanocandelas value)
				{
					return (value.value)*1E-33;
				}

				public static Nanocandelas operator +(Nanocandelas first, Yottacandelas second)
				{
					return new Nanocandelas(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Microcandelas : IValueWithUnit, IEquatable< Microcandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Microcandelas Zero = new Microcandelas(0);
			public static readonly Microcandelas One = new Microcandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.microcandela; } }

			public Microcandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E-06);
				}
				
			public bool Equals(Microcandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Microcandelas(double value)
			{
				return new Microcandelas(value);
			}

			public static Microcandelas operator *(Microcandelas value, double times)
			{
				return new Microcandelas(value.value * times);
			}

			public static Microcandelas operator *(double times, Microcandelas value)
			{
				return new Microcandelas(value.value * times);
			}

			public static Microcandelas operator +(Microcandelas first, Microcandelas second)
			{
				return new Microcandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Microcandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Microcandelas operator +(Microcandelas first, Candelas second)
				{
					return new Microcandelas(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctocandelas(Microcandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Microcandelas operator +(Microcandelas first, Yoctocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptocandelas(Microcandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Microcandelas operator +(Microcandelas first, Zeptocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attocandelas(Microcandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Microcandelas operator +(Microcandelas first, Attocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtocandelas(Microcandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Microcandelas operator +(Microcandelas first, Femtocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picocandelas(Microcandelas value)
				{
					return (value.value)*1000000;
				}

				public static Microcandelas operator +(Microcandelas first, Picocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanocandelas(Microcandelas value)
				{
					return (value.value)*1000;
				}

				public static Microcandelas operator +(Microcandelas first, Nanocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Millicandelas(Microcandelas value)
				{
					return (value.value)*0.001;
				}

				public static Microcandelas operator +(Microcandelas first, Millicandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Centicandelas(Microcandelas value)
				{
					return (value.value)*0.0001;
				}

				public static Microcandelas operator +(Microcandelas first, Centicandelas second)
				{
					return new Microcandelas(first.value + (second.value)*10000);
				}
								public static implicit operator Decicandelas(Microcandelas value)
				{
					return (value.value)*1E-05;
				}

				public static Microcandelas operator +(Microcandelas first, Decicandelas second)
				{
					return new Microcandelas(first.value + (second.value)*100000);
				}
								public static implicit operator Decacandelas(Microcandelas value)
				{
					return (value.value)*1E-07;
				}

				public static Microcandelas operator +(Microcandelas first, Decacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectocandelas(Microcandelas value)
				{
					return (value.value)*1E-08;
				}

				public static Microcandelas operator +(Microcandelas first, Hectocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*100000000);
				}
								public static implicit operator Kilocandelas(Microcandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Microcandelas operator +(Microcandelas first, Kilocandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megacandelas(Microcandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Microcandelas operator +(Microcandelas first, Megacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigacandelas(Microcandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Microcandelas operator +(Microcandelas first, Gigacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Teracandelas(Microcandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Microcandelas operator +(Microcandelas first, Teracandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petacandelas(Microcandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Microcandelas operator +(Microcandelas first, Petacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Exacandelas(Microcandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Microcandelas operator +(Microcandelas first, Exacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettacandelas(Microcandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Microcandelas operator +(Microcandelas first, Zettacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottacandelas(Microcandelas value)
				{
					return (value.value)*1E-30;
				}

				public static Microcandelas operator +(Microcandelas first, Yottacandelas second)
				{
					return new Microcandelas(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Millicandelas : IValueWithUnit, IEquatable< Millicandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Millicandelas Zero = new Millicandelas(0);
			public static readonly Millicandelas One = new Millicandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.millicandela; } }

			public Millicandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*0.001);
				}
				
			public bool Equals(Millicandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Millicandelas(double value)
			{
				return new Millicandelas(value);
			}

			public static Millicandelas operator *(Millicandelas value, double times)
			{
				return new Millicandelas(value.value * times);
			}

			public static Millicandelas operator *(double times, Millicandelas value)
			{
				return new Millicandelas(value.value * times);
			}

			public static Millicandelas operator +(Millicandelas first, Millicandelas second)
			{
				return new Millicandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Millicandelas value)
				{
					return (value.value)*0.001;
				}

				public static Millicandelas operator +(Millicandelas first, Candelas second)
				{
					return new Millicandelas(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctocandelas(Millicandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Millicandelas operator +(Millicandelas first, Yoctocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptocandelas(Millicandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Millicandelas operator +(Millicandelas first, Zeptocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attocandelas(Millicandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Millicandelas operator +(Millicandelas first, Attocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtocandelas(Millicandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Millicandelas operator +(Millicandelas first, Femtocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picocandelas(Millicandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Millicandelas operator +(Millicandelas first, Picocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanocandelas(Millicandelas value)
				{
					return (value.value)*1000000;
				}

				public static Millicandelas operator +(Millicandelas first, Nanocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Microcandelas(Millicandelas value)
				{
					return (value.value)*1000;
				}

				public static Millicandelas operator +(Millicandelas first, Microcandelas second)
				{
					return new Millicandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Centicandelas(Millicandelas value)
				{
					return (value.value)*0.1;
				}

				public static Millicandelas operator +(Millicandelas first, Centicandelas second)
				{
					return new Millicandelas(first.value + (second.value)*10);
				}
								public static implicit operator Decicandelas(Millicandelas value)
				{
					return (value.value)*0.01;
				}

				public static Millicandelas operator +(Millicandelas first, Decicandelas second)
				{
					return new Millicandelas(first.value + (second.value)*100);
				}
								public static implicit operator Decacandelas(Millicandelas value)
				{
					return (value.value)*0.0001;
				}

				public static Millicandelas operator +(Millicandelas first, Decacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*10000);
				}
								public static implicit operator Hectocandelas(Millicandelas value)
				{
					return (value.value)*1E-05;
				}

				public static Millicandelas operator +(Millicandelas first, Hectocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*100000);
				}
								public static implicit operator Kilocandelas(Millicandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Millicandelas operator +(Millicandelas first, Kilocandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Megacandelas(Millicandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Millicandelas operator +(Millicandelas first, Megacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigacandelas(Millicandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Millicandelas operator +(Millicandelas first, Gigacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Teracandelas(Millicandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Millicandelas operator +(Millicandelas first, Teracandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petacandelas(Millicandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Millicandelas operator +(Millicandelas first, Petacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Exacandelas(Millicandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Millicandelas operator +(Millicandelas first, Exacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettacandelas(Millicandelas value)
				{
					return (value.value)*1E-24;
				}

				public static Millicandelas operator +(Millicandelas first, Zettacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottacandelas(Millicandelas value)
				{
					return (value.value)*1E-27;
				}

				public static Millicandelas operator +(Millicandelas first, Yottacandelas second)
				{
					return new Millicandelas(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centicandelas : IValueWithUnit, IEquatable< Centicandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Centicandelas Zero = new Centicandelas(0);
			public static readonly Centicandelas One = new Centicandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.centicandela; } }

			public Centicandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ccd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*0.01);
				}
				
			public bool Equals(Centicandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centicandelas(double value)
			{
				return new Centicandelas(value);
			}

			public static Centicandelas operator *(Centicandelas value, double times)
			{
				return new Centicandelas(value.value * times);
			}

			public static Centicandelas operator *(double times, Centicandelas value)
			{
				return new Centicandelas(value.value * times);
			}

			public static Centicandelas operator +(Centicandelas first, Centicandelas second)
			{
				return new Centicandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Centicandelas value)
				{
					return (value.value)*0.01;
				}

				public static Centicandelas operator +(Centicandelas first, Candelas second)
				{
					return new Centicandelas(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctocandelas(Centicandelas value)
				{
					return (value.value)*1E+22;
				}

				public static Centicandelas operator +(Centicandelas first, Yoctocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptocandelas(Centicandelas value)
				{
					return (value.value)*1E+19;
				}

				public static Centicandelas operator +(Centicandelas first, Zeptocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attocandelas(Centicandelas value)
				{
					return (value.value)*1E+16;
				}

				public static Centicandelas operator +(Centicandelas first, Attocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtocandelas(Centicandelas value)
				{
					return (value.value)*10000000000000;
				}

				public static Centicandelas operator +(Centicandelas first, Femtocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picocandelas(Centicandelas value)
				{
					return (value.value)*10000000000;
				}

				public static Centicandelas operator +(Centicandelas first, Picocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanocandelas(Centicandelas value)
				{
					return (value.value)*10000000;
				}

				public static Centicandelas operator +(Centicandelas first, Nanocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E-07);
				}
								public static implicit operator Microcandelas(Centicandelas value)
				{
					return (value.value)*10000;
				}

				public static Centicandelas operator +(Centicandelas first, Microcandelas second)
				{
					return new Centicandelas(first.value + (second.value)*0.0001);
				}
								public static implicit operator Millicandelas(Centicandelas value)
				{
					return (value.value)*10;
				}

				public static Centicandelas operator +(Centicandelas first, Millicandelas second)
				{
					return new Centicandelas(first.value + (second.value)*0.1);
				}
								public static implicit operator Decicandelas(Centicandelas value)
				{
					return (value.value)*0.1;
				}

				public static Centicandelas operator +(Centicandelas first, Decicandelas second)
				{
					return new Centicandelas(first.value + (second.value)*10);
				}
								public static implicit operator Decacandelas(Centicandelas value)
				{
					return (value.value)*0.001;
				}

				public static Centicandelas operator +(Centicandelas first, Decacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Hectocandelas(Centicandelas value)
				{
					return (value.value)*0.0001;
				}

				public static Centicandelas operator +(Centicandelas first, Hectocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*10000);
				}
								public static implicit operator Kilocandelas(Centicandelas value)
				{
					return (value.value)*1E-05;
				}

				public static Centicandelas operator +(Centicandelas first, Kilocandelas second)
				{
					return new Centicandelas(first.value + (second.value)*100000);
				}
								public static implicit operator Megacandelas(Centicandelas value)
				{
					return (value.value)*1E-08;
				}

				public static Centicandelas operator +(Centicandelas first, Megacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigacandelas(Centicandelas value)
				{
					return (value.value)*1E-11;
				}

				public static Centicandelas operator +(Centicandelas first, Gigacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*100000000000);
				}
								public static implicit operator Teracandelas(Centicandelas value)
				{
					return (value.value)*1E-14;
				}

				public static Centicandelas operator +(Centicandelas first, Teracandelas second)
				{
					return new Centicandelas(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petacandelas(Centicandelas value)
				{
					return (value.value)*1E-17;
				}

				public static Centicandelas operator +(Centicandelas first, Petacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E+17);
				}
								public static implicit operator Exacandelas(Centicandelas value)
				{
					return (value.value)*1E-20;
				}

				public static Centicandelas operator +(Centicandelas first, Exacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettacandelas(Centicandelas value)
				{
					return (value.value)*1E-23;
				}

				public static Centicandelas operator +(Centicandelas first, Zettacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottacandelas(Centicandelas value)
				{
					return (value.value)*1E-26;
				}

				public static Centicandelas operator +(Centicandelas first, Yottacandelas second)
				{
					return new Centicandelas(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Decicandelas : IValueWithUnit, IEquatable< Decicandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Decicandelas Zero = new Decicandelas(0);
			public static readonly Decicandelas One = new Decicandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.decicandela; } }

			public Decicandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*0.1);
				}
				
			public bool Equals(Decicandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decicandelas(double value)
			{
				return new Decicandelas(value);
			}

			public static Decicandelas operator *(Decicandelas value, double times)
			{
				return new Decicandelas(value.value * times);
			}

			public static Decicandelas operator *(double times, Decicandelas value)
			{
				return new Decicandelas(value.value * times);
			}

			public static Decicandelas operator +(Decicandelas first, Decicandelas second)
			{
				return new Decicandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Decicandelas value)
				{
					return (value.value)*0.1;
				}

				public static Decicandelas operator +(Decicandelas first, Candelas second)
				{
					return new Decicandelas(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctocandelas(Decicandelas value)
				{
					return (value.value)*1E+23;
				}

				public static Decicandelas operator +(Decicandelas first, Yoctocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptocandelas(Decicandelas value)
				{
					return (value.value)*1E+20;
				}

				public static Decicandelas operator +(Decicandelas first, Zeptocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attocandelas(Decicandelas value)
				{
					return (value.value)*1E+17;
				}

				public static Decicandelas operator +(Decicandelas first, Attocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtocandelas(Decicandelas value)
				{
					return (value.value)*100000000000000;
				}

				public static Decicandelas operator +(Decicandelas first, Femtocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picocandelas(Decicandelas value)
				{
					return (value.value)*100000000000;
				}

				public static Decicandelas operator +(Decicandelas first, Picocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanocandelas(Decicandelas value)
				{
					return (value.value)*100000000;
				}

				public static Decicandelas operator +(Decicandelas first, Nanocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-08);
				}
								public static implicit operator Microcandelas(Decicandelas value)
				{
					return (value.value)*100000;
				}

				public static Decicandelas operator +(Decicandelas first, Microcandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E-05);
				}
								public static implicit operator Millicandelas(Decicandelas value)
				{
					return (value.value)*100;
				}

				public static Decicandelas operator +(Decicandelas first, Millicandelas second)
				{
					return new Decicandelas(first.value + (second.value)*0.01);
				}
								public static implicit operator Centicandelas(Decicandelas value)
				{
					return (value.value)*10;
				}

				public static Decicandelas operator +(Decicandelas first, Centicandelas second)
				{
					return new Decicandelas(first.value + (second.value)*0.1);
				}
								public static implicit operator Decacandelas(Decicandelas value)
				{
					return (value.value)*0.01;
				}

				public static Decicandelas operator +(Decicandelas first, Decacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*100);
				}
								public static implicit operator Hectocandelas(Decicandelas value)
				{
					return (value.value)*0.001;
				}

				public static Decicandelas operator +(Decicandelas first, Hectocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Kilocandelas(Decicandelas value)
				{
					return (value.value)*0.0001;
				}

				public static Decicandelas operator +(Decicandelas first, Kilocandelas second)
				{
					return new Decicandelas(first.value + (second.value)*10000);
				}
								public static implicit operator Megacandelas(Decicandelas value)
				{
					return (value.value)*1E-07;
				}

				public static Decicandelas operator +(Decicandelas first, Megacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigacandelas(Decicandelas value)
				{
					return (value.value)*1E-10;
				}

				public static Decicandelas operator +(Decicandelas first, Gigacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*10000000000);
				}
								public static implicit operator Teracandelas(Decicandelas value)
				{
					return (value.value)*1E-13;
				}

				public static Decicandelas operator +(Decicandelas first, Teracandelas second)
				{
					return new Decicandelas(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petacandelas(Decicandelas value)
				{
					return (value.value)*1E-16;
				}

				public static Decicandelas operator +(Decicandelas first, Petacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E+16);
				}
								public static implicit operator Exacandelas(Decicandelas value)
				{
					return (value.value)*1E-19;
				}

				public static Decicandelas operator +(Decicandelas first, Exacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettacandelas(Decicandelas value)
				{
					return (value.value)*1E-22;
				}

				public static Decicandelas operator +(Decicandelas first, Zettacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottacandelas(Decicandelas value)
				{
					return (value.value)*1E-25;
				}

				public static Decicandelas operator +(Decicandelas first, Yottacandelas second)
				{
					return new Decicandelas(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decacandelas : IValueWithUnit, IEquatable< Decacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Decacandelas Zero = new Decacandelas(0);
			public static readonly Decacandelas One = new Decacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.decacandela; } }

			public Decacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dacd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*10);
				}
				
			public bool Equals(Decacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decacandelas(double value)
			{
				return new Decacandelas(value);
			}

			public static Decacandelas operator *(Decacandelas value, double times)
			{
				return new Decacandelas(value.value * times);
			}

			public static Decacandelas operator *(double times, Decacandelas value)
			{
				return new Decacandelas(value.value * times);
			}

			public static Decacandelas operator +(Decacandelas first, Decacandelas second)
			{
				return new Decacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Decacandelas value)
				{
					return (value.value)*10;
				}

				public static Decacandelas operator +(Decacandelas first, Candelas second)
				{
					return new Decacandelas(first.value + (second.value)/10);
				}
								public static implicit operator Yoctocandelas(Decacandelas value)
				{
					return (value.value)*1E+25;
				}

				public static Decacandelas operator +(Decacandelas first, Yoctocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptocandelas(Decacandelas value)
				{
					return (value.value)*1E+22;
				}

				public static Decacandelas operator +(Decacandelas first, Zeptocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attocandelas(Decacandelas value)
				{
					return (value.value)*1E+19;
				}

				public static Decacandelas operator +(Decacandelas first, Attocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtocandelas(Decacandelas value)
				{
					return (value.value)*1E+16;
				}

				public static Decacandelas operator +(Decacandelas first, Femtocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picocandelas(Decacandelas value)
				{
					return (value.value)*10000000000000;
				}

				public static Decacandelas operator +(Decacandelas first, Picocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanocandelas(Decacandelas value)
				{
					return (value.value)*10000000000;
				}

				public static Decacandelas operator +(Decacandelas first, Nanocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-10);
				}
								public static implicit operator Microcandelas(Decacandelas value)
				{
					return (value.value)*10000000;
				}

				public static Decacandelas operator +(Decacandelas first, Microcandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E-07);
				}
								public static implicit operator Millicandelas(Decacandelas value)
				{
					return (value.value)*10000;
				}

				public static Decacandelas operator +(Decacandelas first, Millicandelas second)
				{
					return new Decacandelas(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centicandelas(Decacandelas value)
				{
					return (value.value)*1000;
				}

				public static Decacandelas operator +(Decacandelas first, Centicandelas second)
				{
					return new Decacandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Decicandelas(Decacandelas value)
				{
					return (value.value)*100;
				}

				public static Decacandelas operator +(Decacandelas first, Decicandelas second)
				{
					return new Decacandelas(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectocandelas(Decacandelas value)
				{
					return (value.value)*0.1;
				}

				public static Decacandelas operator +(Decacandelas first, Hectocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*10);
				}
								public static implicit operator Kilocandelas(Decacandelas value)
				{
					return (value.value)*0.01;
				}

				public static Decacandelas operator +(Decacandelas first, Kilocandelas second)
				{
					return new Decacandelas(first.value + (second.value)*100);
				}
								public static implicit operator Megacandelas(Decacandelas value)
				{
					return (value.value)*1E-05;
				}

				public static Decacandelas operator +(Decacandelas first, Megacandelas second)
				{
					return new Decacandelas(first.value + (second.value)*100000);
				}
								public static implicit operator Gigacandelas(Decacandelas value)
				{
					return (value.value)*1E-08;
				}

				public static Decacandelas operator +(Decacandelas first, Gigacandelas second)
				{
					return new Decacandelas(first.value + (second.value)*100000000);
				}
								public static implicit operator Teracandelas(Decacandelas value)
				{
					return (value.value)*1E-11;
				}

				public static Decacandelas operator +(Decacandelas first, Teracandelas second)
				{
					return new Decacandelas(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petacandelas(Decacandelas value)
				{
					return (value.value)*1E-14;
				}

				public static Decacandelas operator +(Decacandelas first, Petacandelas second)
				{
					return new Decacandelas(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Exacandelas(Decacandelas value)
				{
					return (value.value)*1E-17;
				}

				public static Decacandelas operator +(Decacandelas first, Exacandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettacandelas(Decacandelas value)
				{
					return (value.value)*1E-20;
				}

				public static Decacandelas operator +(Decacandelas first, Zettacandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottacandelas(Decacandelas value)
				{
					return (value.value)*1E-23;
				}

				public static Decacandelas operator +(Decacandelas first, Yottacandelas second)
				{
					return new Decacandelas(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectocandelas : IValueWithUnit, IEquatable< Hectocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectocandelas Zero = new Hectocandelas(0);
			public static readonly Hectocandelas One = new Hectocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.hectocandela; } }

			public Hectocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*100);
				}
				
			public bool Equals(Hectocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectocandelas(double value)
			{
				return new Hectocandelas(value);
			}

			public static Hectocandelas operator *(Hectocandelas value, double times)
			{
				return new Hectocandelas(value.value * times);
			}

			public static Hectocandelas operator *(double times, Hectocandelas value)
			{
				return new Hectocandelas(value.value * times);
			}

			public static Hectocandelas operator +(Hectocandelas first, Hectocandelas second)
			{
				return new Hectocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Hectocandelas value)
				{
					return (value.value)*100;
				}

				public static Hectocandelas operator +(Hectocandelas first, Candelas second)
				{
					return new Hectocandelas(first.value + (second.value)/100);
				}
								public static implicit operator Yoctocandelas(Hectocandelas value)
				{
					return (value.value)*1E+26;
				}

				public static Hectocandelas operator +(Hectocandelas first, Yoctocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptocandelas(Hectocandelas value)
				{
					return (value.value)*1E+23;
				}

				public static Hectocandelas operator +(Hectocandelas first, Zeptocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attocandelas(Hectocandelas value)
				{
					return (value.value)*1E+20;
				}

				public static Hectocandelas operator +(Hectocandelas first, Attocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtocandelas(Hectocandelas value)
				{
					return (value.value)*1E+17;
				}

				public static Hectocandelas operator +(Hectocandelas first, Femtocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picocandelas(Hectocandelas value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectocandelas operator +(Hectocandelas first, Picocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanocandelas(Hectocandelas value)
				{
					return (value.value)*100000000000;
				}

				public static Hectocandelas operator +(Hectocandelas first, Nanocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-11);
				}
								public static implicit operator Microcandelas(Hectocandelas value)
				{
					return (value.value)*100000000;
				}

				public static Hectocandelas operator +(Hectocandelas first, Microcandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-08);
				}
								public static implicit operator Millicandelas(Hectocandelas value)
				{
					return (value.value)*100000;
				}

				public static Hectocandelas operator +(Hectocandelas first, Millicandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centicandelas(Hectocandelas value)
				{
					return (value.value)*10000;
				}

				public static Hectocandelas operator +(Hectocandelas first, Centicandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decicandelas(Hectocandelas value)
				{
					return (value.value)*1000;
				}

				public static Hectocandelas operator +(Hectocandelas first, Decicandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Decacandelas(Hectocandelas value)
				{
					return (value.value)*10;
				}

				public static Hectocandelas operator +(Hectocandelas first, Decacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*0.1);
				}
								public static implicit operator Kilocandelas(Hectocandelas value)
				{
					return (value.value)*0.1;
				}

				public static Hectocandelas operator +(Hectocandelas first, Kilocandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*10);
				}
								public static implicit operator Megacandelas(Hectocandelas value)
				{
					return (value.value)*0.0001;
				}

				public static Hectocandelas operator +(Hectocandelas first, Megacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*10000);
				}
								public static implicit operator Gigacandelas(Hectocandelas value)
				{
					return (value.value)*1E-07;
				}

				public static Hectocandelas operator +(Hectocandelas first, Gigacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*10000000);
				}
								public static implicit operator Teracandelas(Hectocandelas value)
				{
					return (value.value)*1E-10;
				}

				public static Hectocandelas operator +(Hectocandelas first, Teracandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petacandelas(Hectocandelas value)
				{
					return (value.value)*1E-13;
				}

				public static Hectocandelas operator +(Hectocandelas first, Petacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Exacandelas(Hectocandelas value)
				{
					return (value.value)*1E-16;
				}

				public static Hectocandelas operator +(Hectocandelas first, Exacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettacandelas(Hectocandelas value)
				{
					return (value.value)*1E-19;
				}

				public static Hectocandelas operator +(Hectocandelas first, Zettacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottacandelas(Hectocandelas value)
				{
					return (value.value)*1E-22;
				}

				public static Hectocandelas operator +(Hectocandelas first, Yottacandelas second)
				{
					return new Hectocandelas(first.value + (second.value)*1E+22);
				}
						}
		}
namespace Multiples
{

		public struct Kilocandelas : IValueWithUnit, IEquatable< Kilocandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Kilocandelas Zero = new Kilocandelas(0);
			public static readonly Kilocandelas One = new Kilocandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.kilocandela; } }

			public Kilocandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} kcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1000);
				}
				
			public bool Equals(Kilocandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kilocandelas(double value)
			{
				return new Kilocandelas(value);
			}

			public static Kilocandelas operator *(Kilocandelas value, double times)
			{
				return new Kilocandelas(value.value * times);
			}

			public static Kilocandelas operator *(double times, Kilocandelas value)
			{
				return new Kilocandelas(value.value * times);
			}

			public static Kilocandelas operator +(Kilocandelas first, Kilocandelas second)
			{
				return new Kilocandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Kilocandelas value)
				{
					return (value.value)*1000;
				}

				public static Kilocandelas operator +(Kilocandelas first, Candelas second)
				{
					return new Kilocandelas(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctocandelas(Kilocandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Kilocandelas operator +(Kilocandelas first, Yoctocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptocandelas(Kilocandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Kilocandelas operator +(Kilocandelas first, Zeptocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attocandelas(Kilocandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Kilocandelas operator +(Kilocandelas first, Attocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtocandelas(Kilocandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Kilocandelas operator +(Kilocandelas first, Femtocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picocandelas(Kilocandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Kilocandelas operator +(Kilocandelas first, Picocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanocandelas(Kilocandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Kilocandelas operator +(Kilocandelas first, Nanocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Microcandelas(Kilocandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Kilocandelas operator +(Kilocandelas first, Microcandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Millicandelas(Kilocandelas value)
				{
					return (value.value)*1000000;
				}

				public static Kilocandelas operator +(Kilocandelas first, Millicandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centicandelas(Kilocandelas value)
				{
					return (value.value)*100000;
				}

				public static Kilocandelas operator +(Kilocandelas first, Centicandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E-05);
				}
								public static implicit operator Decicandelas(Kilocandelas value)
				{
					return (value.value)*10000;
				}

				public static Kilocandelas operator +(Kilocandelas first, Decicandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decacandelas(Kilocandelas value)
				{
					return (value.value)*100;
				}

				public static Kilocandelas operator +(Kilocandelas first, Decacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectocandelas(Kilocandelas value)
				{
					return (value.value)*10;
				}

				public static Kilocandelas operator +(Kilocandelas first, Hectocandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*0.1);
				}
								public static implicit operator Megacandelas(Kilocandelas value)
				{
					return (value.value)*0.001;
				}

				public static Kilocandelas operator +(Kilocandelas first, Megacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Gigacandelas(Kilocandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Kilocandelas operator +(Kilocandelas first, Gigacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Teracandelas(Kilocandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Kilocandelas operator +(Kilocandelas first, Teracandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petacandelas(Kilocandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Kilocandelas operator +(Kilocandelas first, Petacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Exacandelas(Kilocandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Kilocandelas operator +(Kilocandelas first, Exacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettacandelas(Kilocandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Kilocandelas operator +(Kilocandelas first, Zettacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottacandelas(Kilocandelas value)
				{
					return (value.value)*1E-21;
				}

				public static Kilocandelas operator +(Kilocandelas first, Yottacandelas second)
				{
					return new Kilocandelas(first.value + (second.value)*1E+21);
				}
						}
		}
namespace Multiples
{

		public struct Megacandelas : IValueWithUnit, IEquatable< Megacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Megacandelas Zero = new Megacandelas(0);
			public static readonly Megacandelas One = new Megacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.megacandela; } }

			public Megacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Mcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1000000);
				}
				
			public bool Equals(Megacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megacandelas(double value)
			{
				return new Megacandelas(value);
			}

			public static Megacandelas operator *(Megacandelas value, double times)
			{
				return new Megacandelas(value.value * times);
			}

			public static Megacandelas operator *(double times, Megacandelas value)
			{
				return new Megacandelas(value.value * times);
			}

			public static Megacandelas operator +(Megacandelas first, Megacandelas second)
			{
				return new Megacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Megacandelas value)
				{
					return (value.value)*1000000;
				}

				public static Megacandelas operator +(Megacandelas first, Candelas second)
				{
					return new Megacandelas(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctocandelas(Megacandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Megacandelas operator +(Megacandelas first, Yoctocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptocandelas(Megacandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Megacandelas operator +(Megacandelas first, Zeptocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attocandelas(Megacandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Megacandelas operator +(Megacandelas first, Attocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtocandelas(Megacandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Megacandelas operator +(Megacandelas first, Femtocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picocandelas(Megacandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Megacandelas operator +(Megacandelas first, Picocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanocandelas(Megacandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Megacandelas operator +(Megacandelas first, Nanocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Microcandelas(Megacandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Megacandelas operator +(Megacandelas first, Microcandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Millicandelas(Megacandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Megacandelas operator +(Megacandelas first, Millicandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centicandelas(Megacandelas value)
				{
					return (value.value)*100000000;
				}

				public static Megacandelas operator +(Megacandelas first, Centicandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-08);
				}
								public static implicit operator Decicandelas(Megacandelas value)
				{
					return (value.value)*10000000;
				}

				public static Megacandelas operator +(Megacandelas first, Decicandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decacandelas(Megacandelas value)
				{
					return (value.value)*100000;
				}

				public static Megacandelas operator +(Megacandelas first, Decacandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectocandelas(Megacandelas value)
				{
					return (value.value)*10000;
				}

				public static Megacandelas operator +(Megacandelas first, Hectocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kilocandelas(Megacandelas value)
				{
					return (value.value)*1000;
				}

				public static Megacandelas operator +(Megacandelas first, Kilocandelas second)
				{
					return new Megacandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigacandelas(Megacandelas value)
				{
					return (value.value)*0.001;
				}

				public static Megacandelas operator +(Megacandelas first, Gigacandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Teracandelas(Megacandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Megacandelas operator +(Megacandelas first, Teracandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Petacandelas(Megacandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Megacandelas operator +(Megacandelas first, Petacandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Exacandelas(Megacandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Megacandelas operator +(Megacandelas first, Exacandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettacandelas(Megacandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Megacandelas operator +(Megacandelas first, Zettacandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottacandelas(Megacandelas value)
				{
					return (value.value)*1E-18;
				}

				public static Megacandelas operator +(Megacandelas first, Yottacandelas second)
				{
					return new Megacandelas(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigacandelas : IValueWithUnit, IEquatable< Gigacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigacandelas Zero = new Gigacandelas(0);
			public static readonly Gigacandelas One = new Gigacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.gigacandela; } }

			public Gigacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Gcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1000000000);
				}
				
			public bool Equals(Gigacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigacandelas(double value)
			{
				return new Gigacandelas(value);
			}

			public static Gigacandelas operator *(Gigacandelas value, double times)
			{
				return new Gigacandelas(value.value * times);
			}

			public static Gigacandelas operator *(double times, Gigacandelas value)
			{
				return new Gigacandelas(value.value * times);
			}

			public static Gigacandelas operator +(Gigacandelas first, Gigacandelas second)
			{
				return new Gigacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Gigacandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Candelas second)
				{
					return new Gigacandelas(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctocandelas(Gigacandelas value)
				{
					return (value.value)*1E+33;
				}

				public static Gigacandelas operator +(Gigacandelas first, Yoctocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptocandelas(Gigacandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Gigacandelas operator +(Gigacandelas first, Zeptocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attocandelas(Gigacandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Gigacandelas operator +(Gigacandelas first, Attocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtocandelas(Gigacandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Gigacandelas operator +(Gigacandelas first, Femtocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picocandelas(Gigacandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Gigacandelas operator +(Gigacandelas first, Picocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanocandelas(Gigacandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Gigacandelas operator +(Gigacandelas first, Nanocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Microcandelas(Gigacandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Gigacandelas operator +(Gigacandelas first, Microcandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Millicandelas(Gigacandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Millicandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centicandelas(Gigacandelas value)
				{
					return (value.value)*100000000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Centicandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-11);
				}
								public static implicit operator Decicandelas(Gigacandelas value)
				{
					return (value.value)*10000000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Decicandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decacandelas(Gigacandelas value)
				{
					return (value.value)*100000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Decacandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectocandelas(Gigacandelas value)
				{
					return (value.value)*10000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Hectocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kilocandelas(Gigacandelas value)
				{
					return (value.value)*1000000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Kilocandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megacandelas(Gigacandelas value)
				{
					return (value.value)*1000;
				}

				public static Gigacandelas operator +(Gigacandelas first, Megacandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Teracandelas(Gigacandelas value)
				{
					return (value.value)*0.001;
				}

				public static Gigacandelas operator +(Gigacandelas first, Teracandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Petacandelas(Gigacandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Gigacandelas operator +(Gigacandelas first, Petacandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Exacandelas(Gigacandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Gigacandelas operator +(Gigacandelas first, Exacandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettacandelas(Gigacandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Gigacandelas operator +(Gigacandelas first, Zettacandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottacandelas(Gigacandelas value)
				{
					return (value.value)*1E-15;
				}

				public static Gigacandelas operator +(Gigacandelas first, Yottacandelas second)
				{
					return new Gigacandelas(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Teracandelas : IValueWithUnit, IEquatable< Teracandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Teracandelas Zero = new Teracandelas(0);
			public static readonly Teracandelas One = new Teracandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.teracandela; } }

			public Teracandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Tcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1000000000000);
				}
				
			public bool Equals(Teracandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Teracandelas(double value)
			{
				return new Teracandelas(value);
			}

			public static Teracandelas operator *(Teracandelas value, double times)
			{
				return new Teracandelas(value.value * times);
			}

			public static Teracandelas operator *(double times, Teracandelas value)
			{
				return new Teracandelas(value.value * times);
			}

			public static Teracandelas operator +(Teracandelas first, Teracandelas second)
			{
				return new Teracandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Teracandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Teracandelas operator +(Teracandelas first, Candelas second)
				{
					return new Teracandelas(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctocandelas(Teracandelas value)
				{
					return (value.value)*1E+36;
				}

				public static Teracandelas operator +(Teracandelas first, Yoctocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptocandelas(Teracandelas value)
				{
					return (value.value)*1E+33;
				}

				public static Teracandelas operator +(Teracandelas first, Zeptocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attocandelas(Teracandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Teracandelas operator +(Teracandelas first, Attocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtocandelas(Teracandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Teracandelas operator +(Teracandelas first, Femtocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picocandelas(Teracandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Teracandelas operator +(Teracandelas first, Picocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanocandelas(Teracandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Teracandelas operator +(Teracandelas first, Nanocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Microcandelas(Teracandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Teracandelas operator +(Teracandelas first, Microcandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Millicandelas(Teracandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Teracandelas operator +(Teracandelas first, Millicandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centicandelas(Teracandelas value)
				{
					return (value.value)*100000000000000;
				}

				public static Teracandelas operator +(Teracandelas first, Centicandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-14);
				}
								public static implicit operator Decicandelas(Teracandelas value)
				{
					return (value.value)*10000000000000;
				}

				public static Teracandelas operator +(Teracandelas first, Decicandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decacandelas(Teracandelas value)
				{
					return (value.value)*100000000000;
				}

				public static Teracandelas operator +(Teracandelas first, Decacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectocandelas(Teracandelas value)
				{
					return (value.value)*10000000000;
				}

				public static Teracandelas operator +(Teracandelas first, Hectocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kilocandelas(Teracandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Teracandelas operator +(Teracandelas first, Kilocandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megacandelas(Teracandelas value)
				{
					return (value.value)*1000000;
				}

				public static Teracandelas operator +(Teracandelas first, Megacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigacandelas(Teracandelas value)
				{
					return (value.value)*1000;
				}

				public static Teracandelas operator +(Teracandelas first, Gigacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Petacandelas(Teracandelas value)
				{
					return (value.value)*0.001;
				}

				public static Teracandelas operator +(Teracandelas first, Petacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Exacandelas(Teracandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Teracandelas operator +(Teracandelas first, Exacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettacandelas(Teracandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Teracandelas operator +(Teracandelas first, Zettacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottacandelas(Teracandelas value)
				{
					return (value.value)*1E-12;
				}

				public static Teracandelas operator +(Teracandelas first, Yottacandelas second)
				{
					return new Teracandelas(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petacandelas : IValueWithUnit, IEquatable< Petacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Petacandelas Zero = new Petacandelas(0);
			public static readonly Petacandelas One = new Petacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.petacandela; } }

			public Petacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Pcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E+15);
				}
				
			public bool Equals(Petacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petacandelas(double value)
			{
				return new Petacandelas(value);
			}

			public static Petacandelas operator *(Petacandelas value, double times)
			{
				return new Petacandelas(value.value * times);
			}

			public static Petacandelas operator *(double times, Petacandelas value)
			{
				return new Petacandelas(value.value * times);
			}

			public static Petacandelas operator +(Petacandelas first, Petacandelas second)
			{
				return new Petacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Petacandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Petacandelas operator +(Petacandelas first, Candelas second)
				{
					return new Petacandelas(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctocandelas(Petacandelas value)
				{
					return (value.value)*1E+39;
				}

				public static Petacandelas operator +(Petacandelas first, Yoctocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptocandelas(Petacandelas value)
				{
					return (value.value)*1E+36;
				}

				public static Petacandelas operator +(Petacandelas first, Zeptocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attocandelas(Petacandelas value)
				{
					return (value.value)*1E+33;
				}

				public static Petacandelas operator +(Petacandelas first, Attocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtocandelas(Petacandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Petacandelas operator +(Petacandelas first, Femtocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picocandelas(Petacandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Petacandelas operator +(Petacandelas first, Picocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanocandelas(Petacandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Petacandelas operator +(Petacandelas first, Nanocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Microcandelas(Petacandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Petacandelas operator +(Petacandelas first, Microcandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Millicandelas(Petacandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Petacandelas operator +(Petacandelas first, Millicandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centicandelas(Petacandelas value)
				{
					return (value.value)*1E+17;
				}

				public static Petacandelas operator +(Petacandelas first, Centicandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-17);
				}
								public static implicit operator Decicandelas(Petacandelas value)
				{
					return (value.value)*1E+16;
				}

				public static Petacandelas operator +(Petacandelas first, Decicandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decacandelas(Petacandelas value)
				{
					return (value.value)*100000000000000;
				}

				public static Petacandelas operator +(Petacandelas first, Decacandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectocandelas(Petacandelas value)
				{
					return (value.value)*10000000000000;
				}

				public static Petacandelas operator +(Petacandelas first, Hectocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kilocandelas(Petacandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Petacandelas operator +(Petacandelas first, Kilocandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megacandelas(Petacandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Petacandelas operator +(Petacandelas first, Megacandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigacandelas(Petacandelas value)
				{
					return (value.value)*1000000;
				}

				public static Petacandelas operator +(Petacandelas first, Gigacandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Teracandelas(Petacandelas value)
				{
					return (value.value)*1000;
				}

				public static Petacandelas operator +(Petacandelas first, Teracandelas second)
				{
					return new Petacandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Exacandelas(Petacandelas value)
				{
					return (value.value)*0.001;
				}

				public static Petacandelas operator +(Petacandelas first, Exacandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Zettacandelas(Petacandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Petacandelas operator +(Petacandelas first, Zettacandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottacandelas(Petacandelas value)
				{
					return (value.value)*1E-09;
				}

				public static Petacandelas operator +(Petacandelas first, Yottacandelas second)
				{
					return new Petacandelas(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Exacandelas : IValueWithUnit, IEquatable< Exacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Exacandelas Zero = new Exacandelas(0);
			public static readonly Exacandelas One = new Exacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.exacandela; } }

			public Exacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ecd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E+18);
				}
				
			public bool Equals(Exacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Exacandelas(double value)
			{
				return new Exacandelas(value);
			}

			public static Exacandelas operator *(Exacandelas value, double times)
			{
				return new Exacandelas(value.value * times);
			}

			public static Exacandelas operator *(double times, Exacandelas value)
			{
				return new Exacandelas(value.value * times);
			}

			public static Exacandelas operator +(Exacandelas first, Exacandelas second)
			{
				return new Exacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Exacandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Exacandelas operator +(Exacandelas first, Candelas second)
				{
					return new Exacandelas(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctocandelas(Exacandelas value)
				{
					return (value.value)*1E+42;
				}

				public static Exacandelas operator +(Exacandelas first, Yoctocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptocandelas(Exacandelas value)
				{
					return (value.value)*1E+39;
				}

				public static Exacandelas operator +(Exacandelas first, Zeptocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attocandelas(Exacandelas value)
				{
					return (value.value)*1E+36;
				}

				public static Exacandelas operator +(Exacandelas first, Attocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtocandelas(Exacandelas value)
				{
					return (value.value)*1E+33;
				}

				public static Exacandelas operator +(Exacandelas first, Femtocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picocandelas(Exacandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Exacandelas operator +(Exacandelas first, Picocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanocandelas(Exacandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Exacandelas operator +(Exacandelas first, Nanocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Microcandelas(Exacandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Exacandelas operator +(Exacandelas first, Microcandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Millicandelas(Exacandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Exacandelas operator +(Exacandelas first, Millicandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centicandelas(Exacandelas value)
				{
					return (value.value)*1E+20;
				}

				public static Exacandelas operator +(Exacandelas first, Centicandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-20);
				}
								public static implicit operator Decicandelas(Exacandelas value)
				{
					return (value.value)*1E+19;
				}

				public static Exacandelas operator +(Exacandelas first, Decicandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decacandelas(Exacandelas value)
				{
					return (value.value)*1E+17;
				}

				public static Exacandelas operator +(Exacandelas first, Decacandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectocandelas(Exacandelas value)
				{
					return (value.value)*1E+16;
				}

				public static Exacandelas operator +(Exacandelas first, Hectocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kilocandelas(Exacandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Exacandelas operator +(Exacandelas first, Kilocandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megacandelas(Exacandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Exacandelas operator +(Exacandelas first, Megacandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigacandelas(Exacandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Exacandelas operator +(Exacandelas first, Gigacandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Teracandelas(Exacandelas value)
				{
					return (value.value)*1000000;
				}

				public static Exacandelas operator +(Exacandelas first, Teracandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petacandelas(Exacandelas value)
				{
					return (value.value)*1000;
				}

				public static Exacandelas operator +(Exacandelas first, Petacandelas second)
				{
					return new Exacandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettacandelas(Exacandelas value)
				{
					return (value.value)*0.001;
				}

				public static Exacandelas operator +(Exacandelas first, Zettacandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1000);
				}
								public static implicit operator Yottacandelas(Exacandelas value)
				{
					return (value.value)*1E-06;
				}

				public static Exacandelas operator +(Exacandelas first, Yottacandelas second)
				{
					return new Exacandelas(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettacandelas : IValueWithUnit, IEquatable< Zettacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettacandelas Zero = new Zettacandelas(0);
			public static readonly Zettacandelas One = new Zettacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.zettacandela; } }

			public Zettacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Zcd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E+21);
				}
				
			public bool Equals(Zettacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettacandelas(double value)
			{
				return new Zettacandelas(value);
			}

			public static Zettacandelas operator *(Zettacandelas value, double times)
			{
				return new Zettacandelas(value.value * times);
			}

			public static Zettacandelas operator *(double times, Zettacandelas value)
			{
				return new Zettacandelas(value.value * times);
			}

			public static Zettacandelas operator +(Zettacandelas first, Zettacandelas second)
			{
				return new Zettacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Zettacandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Zettacandelas operator +(Zettacandelas first, Candelas second)
				{
					return new Zettacandelas(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctocandelas(Zettacandelas value)
				{
					return (value.value)*1E+45;
				}

				public static Zettacandelas operator +(Zettacandelas first, Yoctocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptocandelas(Zettacandelas value)
				{
					return (value.value)*1E+42;
				}

				public static Zettacandelas operator +(Zettacandelas first, Zeptocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attocandelas(Zettacandelas value)
				{
					return (value.value)*1E+39;
				}

				public static Zettacandelas operator +(Zettacandelas first, Attocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtocandelas(Zettacandelas value)
				{
					return (value.value)*1E+36;
				}

				public static Zettacandelas operator +(Zettacandelas first, Femtocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picocandelas(Zettacandelas value)
				{
					return (value.value)*1E+33;
				}

				public static Zettacandelas operator +(Zettacandelas first, Picocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanocandelas(Zettacandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Zettacandelas operator +(Zettacandelas first, Nanocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Microcandelas(Zettacandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Zettacandelas operator +(Zettacandelas first, Microcandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Millicandelas(Zettacandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Zettacandelas operator +(Zettacandelas first, Millicandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centicandelas(Zettacandelas value)
				{
					return (value.value)*1E+23;
				}

				public static Zettacandelas operator +(Zettacandelas first, Centicandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-23);
				}
								public static implicit operator Decicandelas(Zettacandelas value)
				{
					return (value.value)*1E+22;
				}

				public static Zettacandelas operator +(Zettacandelas first, Decicandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decacandelas(Zettacandelas value)
				{
					return (value.value)*1E+20;
				}

				public static Zettacandelas operator +(Zettacandelas first, Decacandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectocandelas(Zettacandelas value)
				{
					return (value.value)*1E+19;
				}

				public static Zettacandelas operator +(Zettacandelas first, Hectocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kilocandelas(Zettacandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Zettacandelas operator +(Zettacandelas first, Kilocandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megacandelas(Zettacandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Zettacandelas operator +(Zettacandelas first, Megacandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigacandelas(Zettacandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettacandelas operator +(Zettacandelas first, Gigacandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Teracandelas(Zettacandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Zettacandelas operator +(Zettacandelas first, Teracandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petacandelas(Zettacandelas value)
				{
					return (value.value)*1000000;
				}

				public static Zettacandelas operator +(Zettacandelas first, Petacandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Exacandelas(Zettacandelas value)
				{
					return (value.value)*1000;
				}

				public static Zettacandelas operator +(Zettacandelas first, Exacandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottacandelas(Zettacandelas value)
				{
					return (value.value)*0.001;
				}

				public static Zettacandelas operator +(Zettacandelas first, Yottacandelas second)
				{
					return new Zettacandelas(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottacandelas : IValueWithUnit, IEquatable< Yottacandelas >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottacandelas Zero = new Yottacandelas(0);
			public static readonly Yottacandelas One = new Yottacandelas(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return LuminousIntensity.Units.yottacandela; } }

			public Yottacandelas(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ycd", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Candelas ToBaseUnit()
				{
					return new Candelas((this.value)*1E+24);
				}
				
			public bool Equals(Yottacandelas other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottacandelas(double value)
			{
				return new Yottacandelas(value);
			}

			public static Yottacandelas operator *(Yottacandelas value, double times)
			{
				return new Yottacandelas(value.value * times);
			}

			public static Yottacandelas operator *(double times, Yottacandelas value)
			{
				return new Yottacandelas(value.value * times);
			}

			public static Yottacandelas operator +(Yottacandelas first, Yottacandelas second)
			{
				return new Yottacandelas(first.value * second.value);
			}

							public static implicit operator Candelas(Yottacandelas value)
				{
					return (value.value)*1E+24;
				}

				public static Yottacandelas operator +(Yottacandelas first, Candelas second)
				{
					return new Yottacandelas(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctocandelas(Yottacandelas value)
				{
					return (value.value)*1E+48;
				}

				public static Yottacandelas operator +(Yottacandelas first, Yoctocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptocandelas(Yottacandelas value)
				{
					return (value.value)*1E+45;
				}

				public static Yottacandelas operator +(Yottacandelas first, Zeptocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attocandelas(Yottacandelas value)
				{
					return (value.value)*1E+42;
				}

				public static Yottacandelas operator +(Yottacandelas first, Attocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtocandelas(Yottacandelas value)
				{
					return (value.value)*1E+39;
				}

				public static Yottacandelas operator +(Yottacandelas first, Femtocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picocandelas(Yottacandelas value)
				{
					return (value.value)*1E+36;
				}

				public static Yottacandelas operator +(Yottacandelas first, Picocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanocandelas(Yottacandelas value)
				{
					return (value.value)*1E+33;
				}

				public static Yottacandelas operator +(Yottacandelas first, Nanocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-33);
				}
								public static implicit operator Microcandelas(Yottacandelas value)
				{
					return (value.value)*1E+30;
				}

				public static Yottacandelas operator +(Yottacandelas first, Microcandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-30);
				}
								public static implicit operator Millicandelas(Yottacandelas value)
				{
					return (value.value)*1E+27;
				}

				public static Yottacandelas operator +(Yottacandelas first, Millicandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centicandelas(Yottacandelas value)
				{
					return (value.value)*1E+26;
				}

				public static Yottacandelas operator +(Yottacandelas first, Centicandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-26);
				}
								public static implicit operator Decicandelas(Yottacandelas value)
				{
					return (value.value)*1E+25;
				}

				public static Yottacandelas operator +(Yottacandelas first, Decicandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decacandelas(Yottacandelas value)
				{
					return (value.value)*1E+23;
				}

				public static Yottacandelas operator +(Yottacandelas first, Decacandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectocandelas(Yottacandelas value)
				{
					return (value.value)*1E+22;
				}

				public static Yottacandelas operator +(Yottacandelas first, Hectocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kilocandelas(Yottacandelas value)
				{
					return (value.value)*1E+21;
				}

				public static Yottacandelas operator +(Yottacandelas first, Kilocandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megacandelas(Yottacandelas value)
				{
					return (value.value)*1E+18;
				}

				public static Yottacandelas operator +(Yottacandelas first, Megacandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigacandelas(Yottacandelas value)
				{
					return (value.value)*1E+15;
				}

				public static Yottacandelas operator +(Yottacandelas first, Gigacandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-15);
				}
								public static implicit operator Teracandelas(Yottacandelas value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottacandelas operator +(Yottacandelas first, Teracandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petacandelas(Yottacandelas value)
				{
					return (value.value)*1000000000;
				}

				public static Yottacandelas operator +(Yottacandelas first, Petacandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-09);
				}
								public static implicit operator Exacandelas(Yottacandelas value)
				{
					return (value.value)*1000000;
				}

				public static Yottacandelas operator +(Yottacandelas first, Exacandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettacandelas(Yottacandelas value)
				{
					return (value.value)*1000;
				}

				public static Yottacandelas operator +(Yottacandelas first, Zettacandelas second)
				{
					return new Yottacandelas(first.value + (second.value)*0.001);
				}
						}
		}

		public struct Moles : IValueWithUnit, IEquatable< Moles >, IEquatable<IValueWithUnit>
		{
			public static readonly Moles Zero = new Moles(0);
			public static readonly Moles One = new Moles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.mole; } }

			public Moles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this;
								}

			
			public bool Equals(Moles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Moles(double value)
			{
				return new Moles(value);
			}

			public static Moles operator *(Moles value, double times)
			{
				return new Moles(value.value * times);
			}

			public static Moles operator *(double times, Moles value)
			{
				return new Moles(value.value * times);
			}

			public static Moles operator +(Moles first, Moles second)
			{
				return new Moles(first.value * second.value);
			}

							public static implicit operator Yoctomoles(Moles value)
				{
					return (value.value)/1E-24;
				}

				public static Moles operator +(Moles first, Yoctomoles second)
				{
					return new Moles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Zeptomoles(Moles value)
				{
					return (value.value)/1E-21;
				}

				public static Moles operator +(Moles first, Zeptomoles second)
				{
					return new Moles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Attomoles(Moles value)
				{
					return (value.value)/1E-18;
				}

				public static Moles operator +(Moles first, Attomoles second)
				{
					return new Moles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Femtomoles(Moles value)
				{
					return (value.value)/1E-15;
				}

				public static Moles operator +(Moles first, Femtomoles second)
				{
					return new Moles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Picomoles(Moles value)
				{
					return (value.value)/1E-12;
				}

				public static Moles operator +(Moles first, Picomoles second)
				{
					return new Moles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Nanomoles(Moles value)
				{
					return (value.value)/1E-09;
				}

				public static Moles operator +(Moles first, Nanomoles second)
				{
					return new Moles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Micromoles(Moles value)
				{
					return (value.value)/1E-06;
				}

				public static Moles operator +(Moles first, Micromoles second)
				{
					return new Moles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Millimoles(Moles value)
				{
					return (value.value)/0.001;
				}

				public static Moles operator +(Moles first, Millimoles second)
				{
					return new Moles(first.value + (second.value)*0.001);
				}
								public static implicit operator Centimoles(Moles value)
				{
					return (value.value)/0.01;
				}

				public static Moles operator +(Moles first, Centimoles second)
				{
					return new Moles(first.value + (second.value)*0.01);
				}
								public static implicit operator Decimoles(Moles value)
				{
					return (value.value)/0.1;
				}

				public static Moles operator +(Moles first, Decimoles second)
				{
					return new Moles(first.value + (second.value)*0.1);
				}
								public static implicit operator Decamoles(Moles value)
				{
					return (value.value)/10;
				}

				public static Moles operator +(Moles first, Decamoles second)
				{
					return new Moles(first.value + (second.value)*10);
				}
								public static implicit operator Hectomoles(Moles value)
				{
					return (value.value)/100;
				}

				public static Moles operator +(Moles first, Hectomoles second)
				{
					return new Moles(first.value + (second.value)*100);
				}
								public static implicit operator Kilomoles(Moles value)
				{
					return (value.value)/1000;
				}

				public static Moles operator +(Moles first, Kilomoles second)
				{
					return new Moles(first.value + (second.value)*1000);
				}
								public static implicit operator Megamoles(Moles value)
				{
					return (value.value)/1000000;
				}

				public static Moles operator +(Moles first, Megamoles second)
				{
					return new Moles(first.value + (second.value)*1000000);
				}
								public static implicit operator Gigamoles(Moles value)
				{
					return (value.value)/1000000000;
				}

				public static Moles operator +(Moles first, Gigamoles second)
				{
					return new Moles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Teramoles(Moles value)
				{
					return (value.value)/1000000000000;
				}

				public static Moles operator +(Moles first, Teramoles second)
				{
					return new Moles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Petamoles(Moles value)
				{
					return (value.value)/1E+15;
				}

				public static Moles operator +(Moles first, Petamoles second)
				{
					return new Moles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Examoles(Moles value)
				{
					return (value.value)/1E+18;
				}

				public static Moles operator +(Moles first, Examoles second)
				{
					return new Moles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Zettamoles(Moles value)
				{
					return (value.value)/1E+21;
				}

				public static Moles operator +(Moles first, Zettamoles second)
				{
					return new Moles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Yottamoles(Moles value)
				{
					return (value.value)/1E+24;
				}

				public static Moles operator +(Moles first, Yottamoles second)
				{
					return new Moles(first.value + (second.value)*1E+24);
				}
						}
		namespace Multiples
{

		public struct Yoctomoles : IValueWithUnit, IEquatable< Yoctomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Yoctomoles Zero = new Yoctomoles(0);
			public static readonly Yoctomoles One = new Yoctomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.yoctomole; } }

			public Yoctomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} ymol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-24);
				}
				
			public bool Equals(Yoctomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yoctomoles(double value)
			{
				return new Yoctomoles(value);
			}

			public static Yoctomoles operator *(Yoctomoles value, double times)
			{
				return new Yoctomoles(value.value * times);
			}

			public static Yoctomoles operator *(double times, Yoctomoles value)
			{
				return new Yoctomoles(value.value * times);
			}

			public static Yoctomoles operator +(Yoctomoles first, Yoctomoles second)
			{
				return new Yoctomoles(first.value * second.value);
			}

							public static implicit operator Moles(Yoctomoles value)
				{
					return (value.value)*1E-24;
				}

				public static Yoctomoles operator +(Yoctomoles first, Moles second)
				{
					return new Yoctomoles(first.value + (second.value)/1E-24);
				}
								public static implicit operator Zeptomoles(Yoctomoles value)
				{
					return (value.value)*0.001;
				}

				public static Yoctomoles operator +(Yoctomoles first, Zeptomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Attomoles(Yoctomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Yoctomoles operator +(Yoctomoles first, Attomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Femtomoles(Yoctomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Yoctomoles operator +(Yoctomoles first, Femtomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Picomoles(Yoctomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Yoctomoles operator +(Yoctomoles first, Picomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Nanomoles(Yoctomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Yoctomoles operator +(Yoctomoles first, Nanomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Micromoles(Yoctomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Yoctomoles operator +(Yoctomoles first, Micromoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Millimoles(Yoctomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Yoctomoles operator +(Yoctomoles first, Millimoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Centimoles(Yoctomoles value)
				{
					return (value.value)*1E-22;
				}

				public static Yoctomoles operator +(Yoctomoles first, Centimoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+22);
				}
								public static implicit operator Decimoles(Yoctomoles value)
				{
					return (value.value)*1E-23;
				}

				public static Yoctomoles operator +(Yoctomoles first, Decimoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+23);
				}
								public static implicit operator Decamoles(Yoctomoles value)
				{
					return (value.value)*1E-25;
				}

				public static Yoctomoles operator +(Yoctomoles first, Decamoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+25);
				}
								public static implicit operator Hectomoles(Yoctomoles value)
				{
					return (value.value)*1E-26;
				}

				public static Yoctomoles operator +(Yoctomoles first, Hectomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+26);
				}
								public static implicit operator Kilomoles(Yoctomoles value)
				{
					return (value.value)*1E-27;
				}

				public static Yoctomoles operator +(Yoctomoles first, Kilomoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Megamoles(Yoctomoles value)
				{
					return (value.value)*1E-30;
				}

				public static Yoctomoles operator +(Yoctomoles first, Megamoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+30);
				}
								public static implicit operator Gigamoles(Yoctomoles value)
				{
					return (value.value)*1E-33;
				}

				public static Yoctomoles operator +(Yoctomoles first, Gigamoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+33);
				}
								public static implicit operator Teramoles(Yoctomoles value)
				{
					return (value.value)*1E-36;
				}

				public static Yoctomoles operator +(Yoctomoles first, Teramoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+36);
				}
								public static implicit operator Petamoles(Yoctomoles value)
				{
					return (value.value)*1E-39;
				}

				public static Yoctomoles operator +(Yoctomoles first, Petamoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+39);
				}
								public static implicit operator Examoles(Yoctomoles value)
				{
					return (value.value)*1E-42;
				}

				public static Yoctomoles operator +(Yoctomoles first, Examoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+42);
				}
								public static implicit operator Zettamoles(Yoctomoles value)
				{
					return (value.value)*1E-45;
				}

				public static Yoctomoles operator +(Yoctomoles first, Zettamoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+45);
				}
								public static implicit operator Yottamoles(Yoctomoles value)
				{
					return (value.value)*1E-48;
				}

				public static Yoctomoles operator +(Yoctomoles first, Yottamoles second)
				{
					return new Yoctomoles(first.value + (second.value)*1E+48);
				}
						}
		}
namespace Multiples
{

		public struct Zeptomoles : IValueWithUnit, IEquatable< Zeptomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Zeptomoles Zero = new Zeptomoles(0);
			public static readonly Zeptomoles One = new Zeptomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.zeptomole; } }

			public Zeptomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} zmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-21);
				}
				
			public bool Equals(Zeptomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zeptomoles(double value)
			{
				return new Zeptomoles(value);
			}

			public static Zeptomoles operator *(Zeptomoles value, double times)
			{
				return new Zeptomoles(value.value * times);
			}

			public static Zeptomoles operator *(double times, Zeptomoles value)
			{
				return new Zeptomoles(value.value * times);
			}

			public static Zeptomoles operator +(Zeptomoles first, Zeptomoles second)
			{
				return new Zeptomoles(first.value * second.value);
			}

							public static implicit operator Moles(Zeptomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Zeptomoles operator +(Zeptomoles first, Moles second)
				{
					return new Zeptomoles(first.value + (second.value)/1E-21);
				}
								public static implicit operator Yoctomoles(Zeptomoles value)
				{
					return (value.value)*1000;
				}

				public static Zeptomoles operator +(Zeptomoles first, Yoctomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Attomoles(Zeptomoles value)
				{
					return (value.value)*0.001;
				}

				public static Zeptomoles operator +(Zeptomoles first, Attomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Femtomoles(Zeptomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Zeptomoles operator +(Zeptomoles first, Femtomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Picomoles(Zeptomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Zeptomoles operator +(Zeptomoles first, Picomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Nanomoles(Zeptomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Zeptomoles operator +(Zeptomoles first, Nanomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Micromoles(Zeptomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Zeptomoles operator +(Zeptomoles first, Micromoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Millimoles(Zeptomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Zeptomoles operator +(Zeptomoles first, Millimoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Centimoles(Zeptomoles value)
				{
					return (value.value)*1E-19;
				}

				public static Zeptomoles operator +(Zeptomoles first, Centimoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+19);
				}
								public static implicit operator Decimoles(Zeptomoles value)
				{
					return (value.value)*1E-20;
				}

				public static Zeptomoles operator +(Zeptomoles first, Decimoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+20);
				}
								public static implicit operator Decamoles(Zeptomoles value)
				{
					return (value.value)*1E-22;
				}

				public static Zeptomoles operator +(Zeptomoles first, Decamoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+22);
				}
								public static implicit operator Hectomoles(Zeptomoles value)
				{
					return (value.value)*1E-23;
				}

				public static Zeptomoles operator +(Zeptomoles first, Hectomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+23);
				}
								public static implicit operator Kilomoles(Zeptomoles value)
				{
					return (value.value)*1E-24;
				}

				public static Zeptomoles operator +(Zeptomoles first, Kilomoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Megamoles(Zeptomoles value)
				{
					return (value.value)*1E-27;
				}

				public static Zeptomoles operator +(Zeptomoles first, Megamoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Gigamoles(Zeptomoles value)
				{
					return (value.value)*1E-30;
				}

				public static Zeptomoles operator +(Zeptomoles first, Gigamoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+30);
				}
								public static implicit operator Teramoles(Zeptomoles value)
				{
					return (value.value)*1E-33;
				}

				public static Zeptomoles operator +(Zeptomoles first, Teramoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+33);
				}
								public static implicit operator Petamoles(Zeptomoles value)
				{
					return (value.value)*1E-36;
				}

				public static Zeptomoles operator +(Zeptomoles first, Petamoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+36);
				}
								public static implicit operator Examoles(Zeptomoles value)
				{
					return (value.value)*1E-39;
				}

				public static Zeptomoles operator +(Zeptomoles first, Examoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+39);
				}
								public static implicit operator Zettamoles(Zeptomoles value)
				{
					return (value.value)*1E-42;
				}

				public static Zeptomoles operator +(Zeptomoles first, Zettamoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+42);
				}
								public static implicit operator Yottamoles(Zeptomoles value)
				{
					return (value.value)*1E-45;
				}

				public static Zeptomoles operator +(Zeptomoles first, Yottamoles second)
				{
					return new Zeptomoles(first.value + (second.value)*1E+45);
				}
						}
		}
namespace Multiples
{

		public struct Attomoles : IValueWithUnit, IEquatable< Attomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Attomoles Zero = new Attomoles(0);
			public static readonly Attomoles One = new Attomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.attomole; } }

			public Attomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} amol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-18);
				}
				
			public bool Equals(Attomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Attomoles(double value)
			{
				return new Attomoles(value);
			}

			public static Attomoles operator *(Attomoles value, double times)
			{
				return new Attomoles(value.value * times);
			}

			public static Attomoles operator *(double times, Attomoles value)
			{
				return new Attomoles(value.value * times);
			}

			public static Attomoles operator +(Attomoles first, Attomoles second)
			{
				return new Attomoles(first.value * second.value);
			}

							public static implicit operator Moles(Attomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Attomoles operator +(Attomoles first, Moles second)
				{
					return new Attomoles(first.value + (second.value)/1E-18);
				}
								public static implicit operator Yoctomoles(Attomoles value)
				{
					return (value.value)*1000000;
				}

				public static Attomoles operator +(Attomoles first, Yoctomoles second)
				{
					return new Attomoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zeptomoles(Attomoles value)
				{
					return (value.value)*1000;
				}

				public static Attomoles operator +(Attomoles first, Zeptomoles second)
				{
					return new Attomoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Femtomoles(Attomoles value)
				{
					return (value.value)*0.001;
				}

				public static Attomoles operator +(Attomoles first, Femtomoles second)
				{
					return new Attomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Picomoles(Attomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Attomoles operator +(Attomoles first, Picomoles second)
				{
					return new Attomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Nanomoles(Attomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Attomoles operator +(Attomoles first, Nanomoles second)
				{
					return new Attomoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Micromoles(Attomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Attomoles operator +(Attomoles first, Micromoles second)
				{
					return new Attomoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Millimoles(Attomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Attomoles operator +(Attomoles first, Millimoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Centimoles(Attomoles value)
				{
					return (value.value)*1E-16;
				}

				public static Attomoles operator +(Attomoles first, Centimoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+16);
				}
								public static implicit operator Decimoles(Attomoles value)
				{
					return (value.value)*1E-17;
				}

				public static Attomoles operator +(Attomoles first, Decimoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+17);
				}
								public static implicit operator Decamoles(Attomoles value)
				{
					return (value.value)*1E-19;
				}

				public static Attomoles operator +(Attomoles first, Decamoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+19);
				}
								public static implicit operator Hectomoles(Attomoles value)
				{
					return (value.value)*1E-20;
				}

				public static Attomoles operator +(Attomoles first, Hectomoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+20);
				}
								public static implicit operator Kilomoles(Attomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Attomoles operator +(Attomoles first, Kilomoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Megamoles(Attomoles value)
				{
					return (value.value)*1E-24;
				}

				public static Attomoles operator +(Attomoles first, Megamoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Gigamoles(Attomoles value)
				{
					return (value.value)*1E-27;
				}

				public static Attomoles operator +(Attomoles first, Gigamoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Teramoles(Attomoles value)
				{
					return (value.value)*1E-30;
				}

				public static Attomoles operator +(Attomoles first, Teramoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+30);
				}
								public static implicit operator Petamoles(Attomoles value)
				{
					return (value.value)*1E-33;
				}

				public static Attomoles operator +(Attomoles first, Petamoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+33);
				}
								public static implicit operator Examoles(Attomoles value)
				{
					return (value.value)*1E-36;
				}

				public static Attomoles operator +(Attomoles first, Examoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+36);
				}
								public static implicit operator Zettamoles(Attomoles value)
				{
					return (value.value)*1E-39;
				}

				public static Attomoles operator +(Attomoles first, Zettamoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+39);
				}
								public static implicit operator Yottamoles(Attomoles value)
				{
					return (value.value)*1E-42;
				}

				public static Attomoles operator +(Attomoles first, Yottamoles second)
				{
					return new Attomoles(first.value + (second.value)*1E+42);
				}
						}
		}
namespace Multiples
{

		public struct Femtomoles : IValueWithUnit, IEquatable< Femtomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Femtomoles Zero = new Femtomoles(0);
			public static readonly Femtomoles One = new Femtomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.femtomole; } }

			public Femtomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} fmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-15);
				}
				
			public bool Equals(Femtomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Femtomoles(double value)
			{
				return new Femtomoles(value);
			}

			public static Femtomoles operator *(Femtomoles value, double times)
			{
				return new Femtomoles(value.value * times);
			}

			public static Femtomoles operator *(double times, Femtomoles value)
			{
				return new Femtomoles(value.value * times);
			}

			public static Femtomoles operator +(Femtomoles first, Femtomoles second)
			{
				return new Femtomoles(first.value * second.value);
			}

							public static implicit operator Moles(Femtomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Femtomoles operator +(Femtomoles first, Moles second)
				{
					return new Femtomoles(first.value + (second.value)/1E-15);
				}
								public static implicit operator Yoctomoles(Femtomoles value)
				{
					return (value.value)*1000000000;
				}

				public static Femtomoles operator +(Femtomoles first, Yoctomoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Zeptomoles(Femtomoles value)
				{
					return (value.value)*1000000;
				}

				public static Femtomoles operator +(Femtomoles first, Zeptomoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Attomoles(Femtomoles value)
				{
					return (value.value)*1000;
				}

				public static Femtomoles operator +(Femtomoles first, Attomoles second)
				{
					return new Femtomoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Picomoles(Femtomoles value)
				{
					return (value.value)*0.001;
				}

				public static Femtomoles operator +(Femtomoles first, Picomoles second)
				{
					return new Femtomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Nanomoles(Femtomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Femtomoles operator +(Femtomoles first, Nanomoles second)
				{
					return new Femtomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Micromoles(Femtomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Femtomoles operator +(Femtomoles first, Micromoles second)
				{
					return new Femtomoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Millimoles(Femtomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Femtomoles operator +(Femtomoles first, Millimoles second)
				{
					return new Femtomoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Centimoles(Femtomoles value)
				{
					return (value.value)*1E-13;
				}

				public static Femtomoles operator +(Femtomoles first, Centimoles second)
				{
					return new Femtomoles(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Decimoles(Femtomoles value)
				{
					return (value.value)*1E-14;
				}

				public static Femtomoles operator +(Femtomoles first, Decimoles second)
				{
					return new Femtomoles(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Decamoles(Femtomoles value)
				{
					return (value.value)*1E-16;
				}

				public static Femtomoles operator +(Femtomoles first, Decamoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+16);
				}
								public static implicit operator Hectomoles(Femtomoles value)
				{
					return (value.value)*1E-17;
				}

				public static Femtomoles operator +(Femtomoles first, Hectomoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+17);
				}
								public static implicit operator Kilomoles(Femtomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Femtomoles operator +(Femtomoles first, Kilomoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Megamoles(Femtomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Femtomoles operator +(Femtomoles first, Megamoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Gigamoles(Femtomoles value)
				{
					return (value.value)*1E-24;
				}

				public static Femtomoles operator +(Femtomoles first, Gigamoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Teramoles(Femtomoles value)
				{
					return (value.value)*1E-27;
				}

				public static Femtomoles operator +(Femtomoles first, Teramoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Petamoles(Femtomoles value)
				{
					return (value.value)*1E-30;
				}

				public static Femtomoles operator +(Femtomoles first, Petamoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+30);
				}
								public static implicit operator Examoles(Femtomoles value)
				{
					return (value.value)*1E-33;
				}

				public static Femtomoles operator +(Femtomoles first, Examoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+33);
				}
								public static implicit operator Zettamoles(Femtomoles value)
				{
					return (value.value)*1E-36;
				}

				public static Femtomoles operator +(Femtomoles first, Zettamoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+36);
				}
								public static implicit operator Yottamoles(Femtomoles value)
				{
					return (value.value)*1E-39;
				}

				public static Femtomoles operator +(Femtomoles first, Yottamoles second)
				{
					return new Femtomoles(first.value + (second.value)*1E+39);
				}
						}
		}
namespace Multiples
{

		public struct Picomoles : IValueWithUnit, IEquatable< Picomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Picomoles Zero = new Picomoles(0);
			public static readonly Picomoles One = new Picomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.picomole; } }

			public Picomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} pmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-12);
				}
				
			public bool Equals(Picomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Picomoles(double value)
			{
				return new Picomoles(value);
			}

			public static Picomoles operator *(Picomoles value, double times)
			{
				return new Picomoles(value.value * times);
			}

			public static Picomoles operator *(double times, Picomoles value)
			{
				return new Picomoles(value.value * times);
			}

			public static Picomoles operator +(Picomoles first, Picomoles second)
			{
				return new Picomoles(first.value * second.value);
			}

							public static implicit operator Moles(Picomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Picomoles operator +(Picomoles first, Moles second)
				{
					return new Picomoles(first.value + (second.value)/1E-12);
				}
								public static implicit operator Yoctomoles(Picomoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Picomoles operator +(Picomoles first, Yoctomoles second)
				{
					return new Picomoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Zeptomoles(Picomoles value)
				{
					return (value.value)*1000000000;
				}

				public static Picomoles operator +(Picomoles first, Zeptomoles second)
				{
					return new Picomoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Attomoles(Picomoles value)
				{
					return (value.value)*1000000;
				}

				public static Picomoles operator +(Picomoles first, Attomoles second)
				{
					return new Picomoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Femtomoles(Picomoles value)
				{
					return (value.value)*1000;
				}

				public static Picomoles operator +(Picomoles first, Femtomoles second)
				{
					return new Picomoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Nanomoles(Picomoles value)
				{
					return (value.value)*0.001;
				}

				public static Picomoles operator +(Picomoles first, Nanomoles second)
				{
					return new Picomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Micromoles(Picomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Picomoles operator +(Picomoles first, Micromoles second)
				{
					return new Picomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Millimoles(Picomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Picomoles operator +(Picomoles first, Millimoles second)
				{
					return new Picomoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Centimoles(Picomoles value)
				{
					return (value.value)*1E-10;
				}

				public static Picomoles operator +(Picomoles first, Centimoles second)
				{
					return new Picomoles(first.value + (second.value)*10000000000);
				}
								public static implicit operator Decimoles(Picomoles value)
				{
					return (value.value)*1E-11;
				}

				public static Picomoles operator +(Picomoles first, Decimoles second)
				{
					return new Picomoles(first.value + (second.value)*100000000000);
				}
								public static implicit operator Decamoles(Picomoles value)
				{
					return (value.value)*1E-13;
				}

				public static Picomoles operator +(Picomoles first, Decamoles second)
				{
					return new Picomoles(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Hectomoles(Picomoles value)
				{
					return (value.value)*1E-14;
				}

				public static Picomoles operator +(Picomoles first, Hectomoles second)
				{
					return new Picomoles(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Kilomoles(Picomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Picomoles operator +(Picomoles first, Kilomoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Megamoles(Picomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Picomoles operator +(Picomoles first, Megamoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Gigamoles(Picomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Picomoles operator +(Picomoles first, Gigamoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Teramoles(Picomoles value)
				{
					return (value.value)*1E-24;
				}

				public static Picomoles operator +(Picomoles first, Teramoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Petamoles(Picomoles value)
				{
					return (value.value)*1E-27;
				}

				public static Picomoles operator +(Picomoles first, Petamoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Examoles(Picomoles value)
				{
					return (value.value)*1E-30;
				}

				public static Picomoles operator +(Picomoles first, Examoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+30);
				}
								public static implicit operator Zettamoles(Picomoles value)
				{
					return (value.value)*1E-33;
				}

				public static Picomoles operator +(Picomoles first, Zettamoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+33);
				}
								public static implicit operator Yottamoles(Picomoles value)
				{
					return (value.value)*1E-36;
				}

				public static Picomoles operator +(Picomoles first, Yottamoles second)
				{
					return new Picomoles(first.value + (second.value)*1E+36);
				}
						}
		}
namespace Multiples
{

		public struct Nanomoles : IValueWithUnit, IEquatable< Nanomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Nanomoles Zero = new Nanomoles(0);
			public static readonly Nanomoles One = new Nanomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.nanomole; } }

			public Nanomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} nmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-09);
				}
				
			public bool Equals(Nanomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Nanomoles(double value)
			{
				return new Nanomoles(value);
			}

			public static Nanomoles operator *(Nanomoles value, double times)
			{
				return new Nanomoles(value.value * times);
			}

			public static Nanomoles operator *(double times, Nanomoles value)
			{
				return new Nanomoles(value.value * times);
			}

			public static Nanomoles operator +(Nanomoles first, Nanomoles second)
			{
				return new Nanomoles(first.value * second.value);
			}

							public static implicit operator Moles(Nanomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Nanomoles operator +(Nanomoles first, Moles second)
				{
					return new Nanomoles(first.value + (second.value)/1E-09);
				}
								public static implicit operator Yoctomoles(Nanomoles value)
				{
					return (value.value)*1E+15;
				}

				public static Nanomoles operator +(Nanomoles first, Yoctomoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Zeptomoles(Nanomoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Nanomoles operator +(Nanomoles first, Zeptomoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Attomoles(Nanomoles value)
				{
					return (value.value)*1000000000;
				}

				public static Nanomoles operator +(Nanomoles first, Attomoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Femtomoles(Nanomoles value)
				{
					return (value.value)*1000000;
				}

				public static Nanomoles operator +(Nanomoles first, Femtomoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Picomoles(Nanomoles value)
				{
					return (value.value)*1000;
				}

				public static Nanomoles operator +(Nanomoles first, Picomoles second)
				{
					return new Nanomoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Micromoles(Nanomoles value)
				{
					return (value.value)*0.001;
				}

				public static Nanomoles operator +(Nanomoles first, Micromoles second)
				{
					return new Nanomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Millimoles(Nanomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Nanomoles operator +(Nanomoles first, Millimoles second)
				{
					return new Nanomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Centimoles(Nanomoles value)
				{
					return (value.value)*1E-07;
				}

				public static Nanomoles operator +(Nanomoles first, Centimoles second)
				{
					return new Nanomoles(first.value + (second.value)*10000000);
				}
								public static implicit operator Decimoles(Nanomoles value)
				{
					return (value.value)*1E-08;
				}

				public static Nanomoles operator +(Nanomoles first, Decimoles second)
				{
					return new Nanomoles(first.value + (second.value)*100000000);
				}
								public static implicit operator Decamoles(Nanomoles value)
				{
					return (value.value)*1E-10;
				}

				public static Nanomoles operator +(Nanomoles first, Decamoles second)
				{
					return new Nanomoles(first.value + (second.value)*10000000000);
				}
								public static implicit operator Hectomoles(Nanomoles value)
				{
					return (value.value)*1E-11;
				}

				public static Nanomoles operator +(Nanomoles first, Hectomoles second)
				{
					return new Nanomoles(first.value + (second.value)*100000000000);
				}
								public static implicit operator Kilomoles(Nanomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Nanomoles operator +(Nanomoles first, Kilomoles second)
				{
					return new Nanomoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Megamoles(Nanomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Nanomoles operator +(Nanomoles first, Megamoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Gigamoles(Nanomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Nanomoles operator +(Nanomoles first, Gigamoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Teramoles(Nanomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Nanomoles operator +(Nanomoles first, Teramoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Petamoles(Nanomoles value)
				{
					return (value.value)*1E-24;
				}

				public static Nanomoles operator +(Nanomoles first, Petamoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Examoles(Nanomoles value)
				{
					return (value.value)*1E-27;
				}

				public static Nanomoles operator +(Nanomoles first, Examoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Zettamoles(Nanomoles value)
				{
					return (value.value)*1E-30;
				}

				public static Nanomoles operator +(Nanomoles first, Zettamoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+30);
				}
								public static implicit operator Yottamoles(Nanomoles value)
				{
					return (value.value)*1E-33;
				}

				public static Nanomoles operator +(Nanomoles first, Yottamoles second)
				{
					return new Nanomoles(first.value + (second.value)*1E+33);
				}
						}
		}
namespace Multiples
{

		public struct Micromoles : IValueWithUnit, IEquatable< Micromoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Micromoles Zero = new Micromoles(0);
			public static readonly Micromoles One = new Micromoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.micromole; } }

			public Micromoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} µmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E-06);
				}
				
			public bool Equals(Micromoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Micromoles(double value)
			{
				return new Micromoles(value);
			}

			public static Micromoles operator *(Micromoles value, double times)
			{
				return new Micromoles(value.value * times);
			}

			public static Micromoles operator *(double times, Micromoles value)
			{
				return new Micromoles(value.value * times);
			}

			public static Micromoles operator +(Micromoles first, Micromoles second)
			{
				return new Micromoles(first.value * second.value);
			}

							public static implicit operator Moles(Micromoles value)
				{
					return (value.value)*1E-06;
				}

				public static Micromoles operator +(Micromoles first, Moles second)
				{
					return new Micromoles(first.value + (second.value)/1E-06);
				}
								public static implicit operator Yoctomoles(Micromoles value)
				{
					return (value.value)*1E+18;
				}

				public static Micromoles operator +(Micromoles first, Yoctomoles second)
				{
					return new Micromoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Zeptomoles(Micromoles value)
				{
					return (value.value)*1E+15;
				}

				public static Micromoles operator +(Micromoles first, Zeptomoles second)
				{
					return new Micromoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Attomoles(Micromoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Micromoles operator +(Micromoles first, Attomoles second)
				{
					return new Micromoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Femtomoles(Micromoles value)
				{
					return (value.value)*1000000000;
				}

				public static Micromoles operator +(Micromoles first, Femtomoles second)
				{
					return new Micromoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Picomoles(Micromoles value)
				{
					return (value.value)*1000000;
				}

				public static Micromoles operator +(Micromoles first, Picomoles second)
				{
					return new Micromoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Nanomoles(Micromoles value)
				{
					return (value.value)*1000;
				}

				public static Micromoles operator +(Micromoles first, Nanomoles second)
				{
					return new Micromoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Millimoles(Micromoles value)
				{
					return (value.value)*0.001;
				}

				public static Micromoles operator +(Micromoles first, Millimoles second)
				{
					return new Micromoles(first.value + (second.value)*1000);
				}
								public static implicit operator Centimoles(Micromoles value)
				{
					return (value.value)*0.0001;
				}

				public static Micromoles operator +(Micromoles first, Centimoles second)
				{
					return new Micromoles(first.value + (second.value)*10000);
				}
								public static implicit operator Decimoles(Micromoles value)
				{
					return (value.value)*1E-05;
				}

				public static Micromoles operator +(Micromoles first, Decimoles second)
				{
					return new Micromoles(first.value + (second.value)*100000);
				}
								public static implicit operator Decamoles(Micromoles value)
				{
					return (value.value)*1E-07;
				}

				public static Micromoles operator +(Micromoles first, Decamoles second)
				{
					return new Micromoles(first.value + (second.value)*10000000);
				}
								public static implicit operator Hectomoles(Micromoles value)
				{
					return (value.value)*1E-08;
				}

				public static Micromoles operator +(Micromoles first, Hectomoles second)
				{
					return new Micromoles(first.value + (second.value)*100000000);
				}
								public static implicit operator Kilomoles(Micromoles value)
				{
					return (value.value)*1E-09;
				}

				public static Micromoles operator +(Micromoles first, Kilomoles second)
				{
					return new Micromoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Megamoles(Micromoles value)
				{
					return (value.value)*1E-12;
				}

				public static Micromoles operator +(Micromoles first, Megamoles second)
				{
					return new Micromoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Gigamoles(Micromoles value)
				{
					return (value.value)*1E-15;
				}

				public static Micromoles operator +(Micromoles first, Gigamoles second)
				{
					return new Micromoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Teramoles(Micromoles value)
				{
					return (value.value)*1E-18;
				}

				public static Micromoles operator +(Micromoles first, Teramoles second)
				{
					return new Micromoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Petamoles(Micromoles value)
				{
					return (value.value)*1E-21;
				}

				public static Micromoles operator +(Micromoles first, Petamoles second)
				{
					return new Micromoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Examoles(Micromoles value)
				{
					return (value.value)*1E-24;
				}

				public static Micromoles operator +(Micromoles first, Examoles second)
				{
					return new Micromoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Zettamoles(Micromoles value)
				{
					return (value.value)*1E-27;
				}

				public static Micromoles operator +(Micromoles first, Zettamoles second)
				{
					return new Micromoles(first.value + (second.value)*1E+27);
				}
								public static implicit operator Yottamoles(Micromoles value)
				{
					return (value.value)*1E-30;
				}

				public static Micromoles operator +(Micromoles first, Yottamoles second)
				{
					return new Micromoles(first.value + (second.value)*1E+30);
				}
						}
		}
namespace Multiples
{

		public struct Millimoles : IValueWithUnit, IEquatable< Millimoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Millimoles Zero = new Millimoles(0);
			public static readonly Millimoles One = new Millimoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.millimole; } }

			public Millimoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} mmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*0.001);
				}
				
			public bool Equals(Millimoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Millimoles(double value)
			{
				return new Millimoles(value);
			}

			public static Millimoles operator *(Millimoles value, double times)
			{
				return new Millimoles(value.value * times);
			}

			public static Millimoles operator *(double times, Millimoles value)
			{
				return new Millimoles(value.value * times);
			}

			public static Millimoles operator +(Millimoles first, Millimoles second)
			{
				return new Millimoles(first.value * second.value);
			}

							public static implicit operator Moles(Millimoles value)
				{
					return (value.value)*0.001;
				}

				public static Millimoles operator +(Millimoles first, Moles second)
				{
					return new Millimoles(first.value + (second.value)/0.001);
				}
								public static implicit operator Yoctomoles(Millimoles value)
				{
					return (value.value)*1E+21;
				}

				public static Millimoles operator +(Millimoles first, Yoctomoles second)
				{
					return new Millimoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Zeptomoles(Millimoles value)
				{
					return (value.value)*1E+18;
				}

				public static Millimoles operator +(Millimoles first, Zeptomoles second)
				{
					return new Millimoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Attomoles(Millimoles value)
				{
					return (value.value)*1E+15;
				}

				public static Millimoles operator +(Millimoles first, Attomoles second)
				{
					return new Millimoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Femtomoles(Millimoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Millimoles operator +(Millimoles first, Femtomoles second)
				{
					return new Millimoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Picomoles(Millimoles value)
				{
					return (value.value)*1000000000;
				}

				public static Millimoles operator +(Millimoles first, Picomoles second)
				{
					return new Millimoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Nanomoles(Millimoles value)
				{
					return (value.value)*1000000;
				}

				public static Millimoles operator +(Millimoles first, Nanomoles second)
				{
					return new Millimoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Micromoles(Millimoles value)
				{
					return (value.value)*1000;
				}

				public static Millimoles operator +(Millimoles first, Micromoles second)
				{
					return new Millimoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Centimoles(Millimoles value)
				{
					return (value.value)*0.1;
				}

				public static Millimoles operator +(Millimoles first, Centimoles second)
				{
					return new Millimoles(first.value + (second.value)*10);
				}
								public static implicit operator Decimoles(Millimoles value)
				{
					return (value.value)*0.01;
				}

				public static Millimoles operator +(Millimoles first, Decimoles second)
				{
					return new Millimoles(first.value + (second.value)*100);
				}
								public static implicit operator Decamoles(Millimoles value)
				{
					return (value.value)*0.0001;
				}

				public static Millimoles operator +(Millimoles first, Decamoles second)
				{
					return new Millimoles(first.value + (second.value)*10000);
				}
								public static implicit operator Hectomoles(Millimoles value)
				{
					return (value.value)*1E-05;
				}

				public static Millimoles operator +(Millimoles first, Hectomoles second)
				{
					return new Millimoles(first.value + (second.value)*100000);
				}
								public static implicit operator Kilomoles(Millimoles value)
				{
					return (value.value)*1E-06;
				}

				public static Millimoles operator +(Millimoles first, Kilomoles second)
				{
					return new Millimoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Megamoles(Millimoles value)
				{
					return (value.value)*1E-09;
				}

				public static Millimoles operator +(Millimoles first, Megamoles second)
				{
					return new Millimoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Gigamoles(Millimoles value)
				{
					return (value.value)*1E-12;
				}

				public static Millimoles operator +(Millimoles first, Gigamoles second)
				{
					return new Millimoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Teramoles(Millimoles value)
				{
					return (value.value)*1E-15;
				}

				public static Millimoles operator +(Millimoles first, Teramoles second)
				{
					return new Millimoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Petamoles(Millimoles value)
				{
					return (value.value)*1E-18;
				}

				public static Millimoles operator +(Millimoles first, Petamoles second)
				{
					return new Millimoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Examoles(Millimoles value)
				{
					return (value.value)*1E-21;
				}

				public static Millimoles operator +(Millimoles first, Examoles second)
				{
					return new Millimoles(first.value + (second.value)*1E+21);
				}
								public static implicit operator Zettamoles(Millimoles value)
				{
					return (value.value)*1E-24;
				}

				public static Millimoles operator +(Millimoles first, Zettamoles second)
				{
					return new Millimoles(first.value + (second.value)*1E+24);
				}
								public static implicit operator Yottamoles(Millimoles value)
				{
					return (value.value)*1E-27;
				}

				public static Millimoles operator +(Millimoles first, Yottamoles second)
				{
					return new Millimoles(first.value + (second.value)*1E+27);
				}
						}
		}
namespace Multiples
{

		public struct Centimoles : IValueWithUnit, IEquatable< Centimoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Centimoles Zero = new Centimoles(0);
			public static readonly Centimoles One = new Centimoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.centimole; } }

			public Centimoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} cmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*0.01);
				}
				
			public bool Equals(Centimoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Centimoles(double value)
			{
				return new Centimoles(value);
			}

			public static Centimoles operator *(Centimoles value, double times)
			{
				return new Centimoles(value.value * times);
			}

			public static Centimoles operator *(double times, Centimoles value)
			{
				return new Centimoles(value.value * times);
			}

			public static Centimoles operator +(Centimoles first, Centimoles second)
			{
				return new Centimoles(first.value * second.value);
			}

							public static implicit operator Moles(Centimoles value)
				{
					return (value.value)*0.01;
				}

				public static Centimoles operator +(Centimoles first, Moles second)
				{
					return new Centimoles(first.value + (second.value)/0.01);
				}
								public static implicit operator Yoctomoles(Centimoles value)
				{
					return (value.value)*1E+22;
				}

				public static Centimoles operator +(Centimoles first, Yoctomoles second)
				{
					return new Centimoles(first.value + (second.value)*1E-22);
				}
								public static implicit operator Zeptomoles(Centimoles value)
				{
					return (value.value)*1E+19;
				}

				public static Centimoles operator +(Centimoles first, Zeptomoles second)
				{
					return new Centimoles(first.value + (second.value)*1E-19);
				}
								public static implicit operator Attomoles(Centimoles value)
				{
					return (value.value)*1E+16;
				}

				public static Centimoles operator +(Centimoles first, Attomoles second)
				{
					return new Centimoles(first.value + (second.value)*1E-16);
				}
								public static implicit operator Femtomoles(Centimoles value)
				{
					return (value.value)*10000000000000;
				}

				public static Centimoles operator +(Centimoles first, Femtomoles second)
				{
					return new Centimoles(first.value + (second.value)*1E-13);
				}
								public static implicit operator Picomoles(Centimoles value)
				{
					return (value.value)*10000000000;
				}

				public static Centimoles operator +(Centimoles first, Picomoles second)
				{
					return new Centimoles(first.value + (second.value)*1E-10);
				}
								public static implicit operator Nanomoles(Centimoles value)
				{
					return (value.value)*10000000;
				}

				public static Centimoles operator +(Centimoles first, Nanomoles second)
				{
					return new Centimoles(first.value + (second.value)*1E-07);
				}
								public static implicit operator Micromoles(Centimoles value)
				{
					return (value.value)*10000;
				}

				public static Centimoles operator +(Centimoles first, Micromoles second)
				{
					return new Centimoles(first.value + (second.value)*0.0001);
				}
								public static implicit operator Millimoles(Centimoles value)
				{
					return (value.value)*10;
				}

				public static Centimoles operator +(Centimoles first, Millimoles second)
				{
					return new Centimoles(first.value + (second.value)*0.1);
				}
								public static implicit operator Decimoles(Centimoles value)
				{
					return (value.value)*0.1;
				}

				public static Centimoles operator +(Centimoles first, Decimoles second)
				{
					return new Centimoles(first.value + (second.value)*10);
				}
								public static implicit operator Decamoles(Centimoles value)
				{
					return (value.value)*0.001;
				}

				public static Centimoles operator +(Centimoles first, Decamoles second)
				{
					return new Centimoles(first.value + (second.value)*1000);
				}
								public static implicit operator Hectomoles(Centimoles value)
				{
					return (value.value)*0.0001;
				}

				public static Centimoles operator +(Centimoles first, Hectomoles second)
				{
					return new Centimoles(first.value + (second.value)*10000);
				}
								public static implicit operator Kilomoles(Centimoles value)
				{
					return (value.value)*1E-05;
				}

				public static Centimoles operator +(Centimoles first, Kilomoles second)
				{
					return new Centimoles(first.value + (second.value)*100000);
				}
								public static implicit operator Megamoles(Centimoles value)
				{
					return (value.value)*1E-08;
				}

				public static Centimoles operator +(Centimoles first, Megamoles second)
				{
					return new Centimoles(first.value + (second.value)*100000000);
				}
								public static implicit operator Gigamoles(Centimoles value)
				{
					return (value.value)*1E-11;
				}

				public static Centimoles operator +(Centimoles first, Gigamoles second)
				{
					return new Centimoles(first.value + (second.value)*100000000000);
				}
								public static implicit operator Teramoles(Centimoles value)
				{
					return (value.value)*1E-14;
				}

				public static Centimoles operator +(Centimoles first, Teramoles second)
				{
					return new Centimoles(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Petamoles(Centimoles value)
				{
					return (value.value)*1E-17;
				}

				public static Centimoles operator +(Centimoles first, Petamoles second)
				{
					return new Centimoles(first.value + (second.value)*1E+17);
				}
								public static implicit operator Examoles(Centimoles value)
				{
					return (value.value)*1E-20;
				}

				public static Centimoles operator +(Centimoles first, Examoles second)
				{
					return new Centimoles(first.value + (second.value)*1E+20);
				}
								public static implicit operator Zettamoles(Centimoles value)
				{
					return (value.value)*1E-23;
				}

				public static Centimoles operator +(Centimoles first, Zettamoles second)
				{
					return new Centimoles(first.value + (second.value)*1E+23);
				}
								public static implicit operator Yottamoles(Centimoles value)
				{
					return (value.value)*1E-26;
				}

				public static Centimoles operator +(Centimoles first, Yottamoles second)
				{
					return new Centimoles(first.value + (second.value)*1E+26);
				}
						}
		}
namespace Multiples
{

		public struct Decimoles : IValueWithUnit, IEquatable< Decimoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Decimoles Zero = new Decimoles(0);
			public static readonly Decimoles One = new Decimoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.decimole; } }

			public Decimoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} dmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*0.1);
				}
				
			public bool Equals(Decimoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decimoles(double value)
			{
				return new Decimoles(value);
			}

			public static Decimoles operator *(Decimoles value, double times)
			{
				return new Decimoles(value.value * times);
			}

			public static Decimoles operator *(double times, Decimoles value)
			{
				return new Decimoles(value.value * times);
			}

			public static Decimoles operator +(Decimoles first, Decimoles second)
			{
				return new Decimoles(first.value * second.value);
			}

							public static implicit operator Moles(Decimoles value)
				{
					return (value.value)*0.1;
				}

				public static Decimoles operator +(Decimoles first, Moles second)
				{
					return new Decimoles(first.value + (second.value)/0.1);
				}
								public static implicit operator Yoctomoles(Decimoles value)
				{
					return (value.value)*1E+23;
				}

				public static Decimoles operator +(Decimoles first, Yoctomoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-23);
				}
								public static implicit operator Zeptomoles(Decimoles value)
				{
					return (value.value)*1E+20;
				}

				public static Decimoles operator +(Decimoles first, Zeptomoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-20);
				}
								public static implicit operator Attomoles(Decimoles value)
				{
					return (value.value)*1E+17;
				}

				public static Decimoles operator +(Decimoles first, Attomoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-17);
				}
								public static implicit operator Femtomoles(Decimoles value)
				{
					return (value.value)*100000000000000;
				}

				public static Decimoles operator +(Decimoles first, Femtomoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-14);
				}
								public static implicit operator Picomoles(Decimoles value)
				{
					return (value.value)*100000000000;
				}

				public static Decimoles operator +(Decimoles first, Picomoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-11);
				}
								public static implicit operator Nanomoles(Decimoles value)
				{
					return (value.value)*100000000;
				}

				public static Decimoles operator +(Decimoles first, Nanomoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-08);
				}
								public static implicit operator Micromoles(Decimoles value)
				{
					return (value.value)*100000;
				}

				public static Decimoles operator +(Decimoles first, Micromoles second)
				{
					return new Decimoles(first.value + (second.value)*1E-05);
				}
								public static implicit operator Millimoles(Decimoles value)
				{
					return (value.value)*100;
				}

				public static Decimoles operator +(Decimoles first, Millimoles second)
				{
					return new Decimoles(first.value + (second.value)*0.01);
				}
								public static implicit operator Centimoles(Decimoles value)
				{
					return (value.value)*10;
				}

				public static Decimoles operator +(Decimoles first, Centimoles second)
				{
					return new Decimoles(first.value + (second.value)*0.1);
				}
								public static implicit operator Decamoles(Decimoles value)
				{
					return (value.value)*0.01;
				}

				public static Decimoles operator +(Decimoles first, Decamoles second)
				{
					return new Decimoles(first.value + (second.value)*100);
				}
								public static implicit operator Hectomoles(Decimoles value)
				{
					return (value.value)*0.001;
				}

				public static Decimoles operator +(Decimoles first, Hectomoles second)
				{
					return new Decimoles(first.value + (second.value)*1000);
				}
								public static implicit operator Kilomoles(Decimoles value)
				{
					return (value.value)*0.0001;
				}

				public static Decimoles operator +(Decimoles first, Kilomoles second)
				{
					return new Decimoles(first.value + (second.value)*10000);
				}
								public static implicit operator Megamoles(Decimoles value)
				{
					return (value.value)*1E-07;
				}

				public static Decimoles operator +(Decimoles first, Megamoles second)
				{
					return new Decimoles(first.value + (second.value)*10000000);
				}
								public static implicit operator Gigamoles(Decimoles value)
				{
					return (value.value)*1E-10;
				}

				public static Decimoles operator +(Decimoles first, Gigamoles second)
				{
					return new Decimoles(first.value + (second.value)*10000000000);
				}
								public static implicit operator Teramoles(Decimoles value)
				{
					return (value.value)*1E-13;
				}

				public static Decimoles operator +(Decimoles first, Teramoles second)
				{
					return new Decimoles(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Petamoles(Decimoles value)
				{
					return (value.value)*1E-16;
				}

				public static Decimoles operator +(Decimoles first, Petamoles second)
				{
					return new Decimoles(first.value + (second.value)*1E+16);
				}
								public static implicit operator Examoles(Decimoles value)
				{
					return (value.value)*1E-19;
				}

				public static Decimoles operator +(Decimoles first, Examoles second)
				{
					return new Decimoles(first.value + (second.value)*1E+19);
				}
								public static implicit operator Zettamoles(Decimoles value)
				{
					return (value.value)*1E-22;
				}

				public static Decimoles operator +(Decimoles first, Zettamoles second)
				{
					return new Decimoles(first.value + (second.value)*1E+22);
				}
								public static implicit operator Yottamoles(Decimoles value)
				{
					return (value.value)*1E-25;
				}

				public static Decimoles operator +(Decimoles first, Yottamoles second)
				{
					return new Decimoles(first.value + (second.value)*1E+25);
				}
						}
		}
namespace Multiples
{

		public struct Decamoles : IValueWithUnit, IEquatable< Decamoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Decamoles Zero = new Decamoles(0);
			public static readonly Decamoles One = new Decamoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.decamole; } }

			public Decamoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} damol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*10);
				}
				
			public bool Equals(Decamoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Decamoles(double value)
			{
				return new Decamoles(value);
			}

			public static Decamoles operator *(Decamoles value, double times)
			{
				return new Decamoles(value.value * times);
			}

			public static Decamoles operator *(double times, Decamoles value)
			{
				return new Decamoles(value.value * times);
			}

			public static Decamoles operator +(Decamoles first, Decamoles second)
			{
				return new Decamoles(first.value * second.value);
			}

							public static implicit operator Moles(Decamoles value)
				{
					return (value.value)*10;
				}

				public static Decamoles operator +(Decamoles first, Moles second)
				{
					return new Decamoles(first.value + (second.value)/10);
				}
								public static implicit operator Yoctomoles(Decamoles value)
				{
					return (value.value)*1E+25;
				}

				public static Decamoles operator +(Decamoles first, Yoctomoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-25);
				}
								public static implicit operator Zeptomoles(Decamoles value)
				{
					return (value.value)*1E+22;
				}

				public static Decamoles operator +(Decamoles first, Zeptomoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-22);
				}
								public static implicit operator Attomoles(Decamoles value)
				{
					return (value.value)*1E+19;
				}

				public static Decamoles operator +(Decamoles first, Attomoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-19);
				}
								public static implicit operator Femtomoles(Decamoles value)
				{
					return (value.value)*1E+16;
				}

				public static Decamoles operator +(Decamoles first, Femtomoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-16);
				}
								public static implicit operator Picomoles(Decamoles value)
				{
					return (value.value)*10000000000000;
				}

				public static Decamoles operator +(Decamoles first, Picomoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-13);
				}
								public static implicit operator Nanomoles(Decamoles value)
				{
					return (value.value)*10000000000;
				}

				public static Decamoles operator +(Decamoles first, Nanomoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-10);
				}
								public static implicit operator Micromoles(Decamoles value)
				{
					return (value.value)*10000000;
				}

				public static Decamoles operator +(Decamoles first, Micromoles second)
				{
					return new Decamoles(first.value + (second.value)*1E-07);
				}
								public static implicit operator Millimoles(Decamoles value)
				{
					return (value.value)*10000;
				}

				public static Decamoles operator +(Decamoles first, Millimoles second)
				{
					return new Decamoles(first.value + (second.value)*0.0001);
				}
								public static implicit operator Centimoles(Decamoles value)
				{
					return (value.value)*1000;
				}

				public static Decamoles operator +(Decamoles first, Centimoles second)
				{
					return new Decamoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Decimoles(Decamoles value)
				{
					return (value.value)*100;
				}

				public static Decamoles operator +(Decamoles first, Decimoles second)
				{
					return new Decamoles(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectomoles(Decamoles value)
				{
					return (value.value)*0.1;
				}

				public static Decamoles operator +(Decamoles first, Hectomoles second)
				{
					return new Decamoles(first.value + (second.value)*10);
				}
								public static implicit operator Kilomoles(Decamoles value)
				{
					return (value.value)*0.01;
				}

				public static Decamoles operator +(Decamoles first, Kilomoles second)
				{
					return new Decamoles(first.value + (second.value)*100);
				}
								public static implicit operator Megamoles(Decamoles value)
				{
					return (value.value)*1E-05;
				}

				public static Decamoles operator +(Decamoles first, Megamoles second)
				{
					return new Decamoles(first.value + (second.value)*100000);
				}
								public static implicit operator Gigamoles(Decamoles value)
				{
					return (value.value)*1E-08;
				}

				public static Decamoles operator +(Decamoles first, Gigamoles second)
				{
					return new Decamoles(first.value + (second.value)*100000000);
				}
								public static implicit operator Teramoles(Decamoles value)
				{
					return (value.value)*1E-11;
				}

				public static Decamoles operator +(Decamoles first, Teramoles second)
				{
					return new Decamoles(first.value + (second.value)*100000000000);
				}
								public static implicit operator Petamoles(Decamoles value)
				{
					return (value.value)*1E-14;
				}

				public static Decamoles operator +(Decamoles first, Petamoles second)
				{
					return new Decamoles(first.value + (second.value)*100000000000000);
				}
								public static implicit operator Examoles(Decamoles value)
				{
					return (value.value)*1E-17;
				}

				public static Decamoles operator +(Decamoles first, Examoles second)
				{
					return new Decamoles(first.value + (second.value)*1E+17);
				}
								public static implicit operator Zettamoles(Decamoles value)
				{
					return (value.value)*1E-20;
				}

				public static Decamoles operator +(Decamoles first, Zettamoles second)
				{
					return new Decamoles(first.value + (second.value)*1E+20);
				}
								public static implicit operator Yottamoles(Decamoles value)
				{
					return (value.value)*1E-23;
				}

				public static Decamoles operator +(Decamoles first, Yottamoles second)
				{
					return new Decamoles(first.value + (second.value)*1E+23);
				}
						}
		}
namespace Multiples
{

		public struct Hectomoles : IValueWithUnit, IEquatable< Hectomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Hectomoles Zero = new Hectomoles(0);
			public static readonly Hectomoles One = new Hectomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.hectomole; } }

			public Hectomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} hmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*100);
				}
				
			public bool Equals(Hectomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Hectomoles(double value)
			{
				return new Hectomoles(value);
			}

			public static Hectomoles operator *(Hectomoles value, double times)
			{
				return new Hectomoles(value.value * times);
			}

			public static Hectomoles operator *(double times, Hectomoles value)
			{
				return new Hectomoles(value.value * times);
			}

			public static Hectomoles operator +(Hectomoles first, Hectomoles second)
			{
				return new Hectomoles(first.value * second.value);
			}

							public static implicit operator Moles(Hectomoles value)
				{
					return (value.value)*100;
				}

				public static Hectomoles operator +(Hectomoles first, Moles second)
				{
					return new Hectomoles(first.value + (second.value)/100);
				}
								public static implicit operator Yoctomoles(Hectomoles value)
				{
					return (value.value)*1E+26;
				}

				public static Hectomoles operator +(Hectomoles first, Yoctomoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-26);
				}
								public static implicit operator Zeptomoles(Hectomoles value)
				{
					return (value.value)*1E+23;
				}

				public static Hectomoles operator +(Hectomoles first, Zeptomoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-23);
				}
								public static implicit operator Attomoles(Hectomoles value)
				{
					return (value.value)*1E+20;
				}

				public static Hectomoles operator +(Hectomoles first, Attomoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-20);
				}
								public static implicit operator Femtomoles(Hectomoles value)
				{
					return (value.value)*1E+17;
				}

				public static Hectomoles operator +(Hectomoles first, Femtomoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-17);
				}
								public static implicit operator Picomoles(Hectomoles value)
				{
					return (value.value)*100000000000000;
				}

				public static Hectomoles operator +(Hectomoles first, Picomoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-14);
				}
								public static implicit operator Nanomoles(Hectomoles value)
				{
					return (value.value)*100000000000;
				}

				public static Hectomoles operator +(Hectomoles first, Nanomoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-11);
				}
								public static implicit operator Micromoles(Hectomoles value)
				{
					return (value.value)*100000000;
				}

				public static Hectomoles operator +(Hectomoles first, Micromoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-08);
				}
								public static implicit operator Millimoles(Hectomoles value)
				{
					return (value.value)*100000;
				}

				public static Hectomoles operator +(Hectomoles first, Millimoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E-05);
				}
								public static implicit operator Centimoles(Hectomoles value)
				{
					return (value.value)*10000;
				}

				public static Hectomoles operator +(Hectomoles first, Centimoles second)
				{
					return new Hectomoles(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decimoles(Hectomoles value)
				{
					return (value.value)*1000;
				}

				public static Hectomoles operator +(Hectomoles first, Decimoles second)
				{
					return new Hectomoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Decamoles(Hectomoles value)
				{
					return (value.value)*10;
				}

				public static Hectomoles operator +(Hectomoles first, Decamoles second)
				{
					return new Hectomoles(first.value + (second.value)*0.1);
				}
								public static implicit operator Kilomoles(Hectomoles value)
				{
					return (value.value)*0.1;
				}

				public static Hectomoles operator +(Hectomoles first, Kilomoles second)
				{
					return new Hectomoles(first.value + (second.value)*10);
				}
								public static implicit operator Megamoles(Hectomoles value)
				{
					return (value.value)*0.0001;
				}

				public static Hectomoles operator +(Hectomoles first, Megamoles second)
				{
					return new Hectomoles(first.value + (second.value)*10000);
				}
								public static implicit operator Gigamoles(Hectomoles value)
				{
					return (value.value)*1E-07;
				}

				public static Hectomoles operator +(Hectomoles first, Gigamoles second)
				{
					return new Hectomoles(first.value + (second.value)*10000000);
				}
								public static implicit operator Teramoles(Hectomoles value)
				{
					return (value.value)*1E-10;
				}

				public static Hectomoles operator +(Hectomoles first, Teramoles second)
				{
					return new Hectomoles(first.value + (second.value)*10000000000);
				}
								public static implicit operator Petamoles(Hectomoles value)
				{
					return (value.value)*1E-13;
				}

				public static Hectomoles operator +(Hectomoles first, Petamoles second)
				{
					return new Hectomoles(first.value + (second.value)*10000000000000);
				}
								public static implicit operator Examoles(Hectomoles value)
				{
					return (value.value)*1E-16;
				}

				public static Hectomoles operator +(Hectomoles first, Examoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E+16);
				}
								public static implicit operator Zettamoles(Hectomoles value)
				{
					return (value.value)*1E-19;
				}

				public static Hectomoles operator +(Hectomoles first, Zettamoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E+19);
				}
								public static implicit operator Yottamoles(Hectomoles value)
				{
					return (value.value)*1E-22;
				}

				public static Hectomoles operator +(Hectomoles first, Yottamoles second)
				{
					return new Hectomoles(first.value + (second.value)*1E+22);
				}
						}
		}
namespace Multiples
{

		public struct Kilomoles : IValueWithUnit, IEquatable< Kilomoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Kilomoles Zero = new Kilomoles(0);
			public static readonly Kilomoles One = new Kilomoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.kilomole; } }

			public Kilomoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} kmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1000);
				}
				
			public bool Equals(Kilomoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Kilomoles(double value)
			{
				return new Kilomoles(value);
			}

			public static Kilomoles operator *(Kilomoles value, double times)
			{
				return new Kilomoles(value.value * times);
			}

			public static Kilomoles operator *(double times, Kilomoles value)
			{
				return new Kilomoles(value.value * times);
			}

			public static Kilomoles operator +(Kilomoles first, Kilomoles second)
			{
				return new Kilomoles(first.value * second.value);
			}

							public static implicit operator Moles(Kilomoles value)
				{
					return (value.value)*1000;
				}

				public static Kilomoles operator +(Kilomoles first, Moles second)
				{
					return new Kilomoles(first.value + (second.value)/1000);
				}
								public static implicit operator Yoctomoles(Kilomoles value)
				{
					return (value.value)*1E+27;
				}

				public static Kilomoles operator +(Kilomoles first, Yoctomoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Zeptomoles(Kilomoles value)
				{
					return (value.value)*1E+24;
				}

				public static Kilomoles operator +(Kilomoles first, Zeptomoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Attomoles(Kilomoles value)
				{
					return (value.value)*1E+21;
				}

				public static Kilomoles operator +(Kilomoles first, Attomoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Femtomoles(Kilomoles value)
				{
					return (value.value)*1E+18;
				}

				public static Kilomoles operator +(Kilomoles first, Femtomoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Picomoles(Kilomoles value)
				{
					return (value.value)*1E+15;
				}

				public static Kilomoles operator +(Kilomoles first, Picomoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Nanomoles(Kilomoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Kilomoles operator +(Kilomoles first, Nanomoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Micromoles(Kilomoles value)
				{
					return (value.value)*1000000000;
				}

				public static Kilomoles operator +(Kilomoles first, Micromoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Millimoles(Kilomoles value)
				{
					return (value.value)*1000000;
				}

				public static Kilomoles operator +(Kilomoles first, Millimoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Centimoles(Kilomoles value)
				{
					return (value.value)*100000;
				}

				public static Kilomoles operator +(Kilomoles first, Centimoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E-05);
				}
								public static implicit operator Decimoles(Kilomoles value)
				{
					return (value.value)*10000;
				}

				public static Kilomoles operator +(Kilomoles first, Decimoles second)
				{
					return new Kilomoles(first.value + (second.value)*0.0001);
				}
								public static implicit operator Decamoles(Kilomoles value)
				{
					return (value.value)*100;
				}

				public static Kilomoles operator +(Kilomoles first, Decamoles second)
				{
					return new Kilomoles(first.value + (second.value)*0.01);
				}
								public static implicit operator Hectomoles(Kilomoles value)
				{
					return (value.value)*10;
				}

				public static Kilomoles operator +(Kilomoles first, Hectomoles second)
				{
					return new Kilomoles(first.value + (second.value)*0.1);
				}
								public static implicit operator Megamoles(Kilomoles value)
				{
					return (value.value)*0.001;
				}

				public static Kilomoles operator +(Kilomoles first, Megamoles second)
				{
					return new Kilomoles(first.value + (second.value)*1000);
				}
								public static implicit operator Gigamoles(Kilomoles value)
				{
					return (value.value)*1E-06;
				}

				public static Kilomoles operator +(Kilomoles first, Gigamoles second)
				{
					return new Kilomoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Teramoles(Kilomoles value)
				{
					return (value.value)*1E-09;
				}

				public static Kilomoles operator +(Kilomoles first, Teramoles second)
				{
					return new Kilomoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Petamoles(Kilomoles value)
				{
					return (value.value)*1E-12;
				}

				public static Kilomoles operator +(Kilomoles first, Petamoles second)
				{
					return new Kilomoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Examoles(Kilomoles value)
				{
					return (value.value)*1E-15;
				}

				public static Kilomoles operator +(Kilomoles first, Examoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Zettamoles(Kilomoles value)
				{
					return (value.value)*1E-18;
				}

				public static Kilomoles operator +(Kilomoles first, Zettamoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E+18);
				}
								public static implicit operator Yottamoles(Kilomoles value)
				{
					return (value.value)*1E-21;
				}

				public static Kilomoles operator +(Kilomoles first, Yottamoles second)
				{
					return new Kilomoles(first.value + (second.value)*1E+21);
				}
						}
		}
namespace Multiples
{

		public struct Megamoles : IValueWithUnit, IEquatable< Megamoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Megamoles Zero = new Megamoles(0);
			public static readonly Megamoles One = new Megamoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.megamole; } }

			public Megamoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Mmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1000000);
				}
				
			public bool Equals(Megamoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Megamoles(double value)
			{
				return new Megamoles(value);
			}

			public static Megamoles operator *(Megamoles value, double times)
			{
				return new Megamoles(value.value * times);
			}

			public static Megamoles operator *(double times, Megamoles value)
			{
				return new Megamoles(value.value * times);
			}

			public static Megamoles operator +(Megamoles first, Megamoles second)
			{
				return new Megamoles(first.value * second.value);
			}

							public static implicit operator Moles(Megamoles value)
				{
					return (value.value)*1000000;
				}

				public static Megamoles operator +(Megamoles first, Moles second)
				{
					return new Megamoles(first.value + (second.value)/1000000);
				}
								public static implicit operator Yoctomoles(Megamoles value)
				{
					return (value.value)*1E+30;
				}

				public static Megamoles operator +(Megamoles first, Yoctomoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Zeptomoles(Megamoles value)
				{
					return (value.value)*1E+27;
				}

				public static Megamoles operator +(Megamoles first, Zeptomoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Attomoles(Megamoles value)
				{
					return (value.value)*1E+24;
				}

				public static Megamoles operator +(Megamoles first, Attomoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Femtomoles(Megamoles value)
				{
					return (value.value)*1E+21;
				}

				public static Megamoles operator +(Megamoles first, Femtomoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Picomoles(Megamoles value)
				{
					return (value.value)*1E+18;
				}

				public static Megamoles operator +(Megamoles first, Picomoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Nanomoles(Megamoles value)
				{
					return (value.value)*1E+15;
				}

				public static Megamoles operator +(Megamoles first, Nanomoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Micromoles(Megamoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Megamoles operator +(Megamoles first, Micromoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Millimoles(Megamoles value)
				{
					return (value.value)*1000000000;
				}

				public static Megamoles operator +(Megamoles first, Millimoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Centimoles(Megamoles value)
				{
					return (value.value)*100000000;
				}

				public static Megamoles operator +(Megamoles first, Centimoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-08);
				}
								public static implicit operator Decimoles(Megamoles value)
				{
					return (value.value)*10000000;
				}

				public static Megamoles operator +(Megamoles first, Decimoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-07);
				}
								public static implicit operator Decamoles(Megamoles value)
				{
					return (value.value)*100000;
				}

				public static Megamoles operator +(Megamoles first, Decamoles second)
				{
					return new Megamoles(first.value + (second.value)*1E-05);
				}
								public static implicit operator Hectomoles(Megamoles value)
				{
					return (value.value)*10000;
				}

				public static Megamoles operator +(Megamoles first, Hectomoles second)
				{
					return new Megamoles(first.value + (second.value)*0.0001);
				}
								public static implicit operator Kilomoles(Megamoles value)
				{
					return (value.value)*1000;
				}

				public static Megamoles operator +(Megamoles first, Kilomoles second)
				{
					return new Megamoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Gigamoles(Megamoles value)
				{
					return (value.value)*0.001;
				}

				public static Megamoles operator +(Megamoles first, Gigamoles second)
				{
					return new Megamoles(first.value + (second.value)*1000);
				}
								public static implicit operator Teramoles(Megamoles value)
				{
					return (value.value)*1E-06;
				}

				public static Megamoles operator +(Megamoles first, Teramoles second)
				{
					return new Megamoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Petamoles(Megamoles value)
				{
					return (value.value)*1E-09;
				}

				public static Megamoles operator +(Megamoles first, Petamoles second)
				{
					return new Megamoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Examoles(Megamoles value)
				{
					return (value.value)*1E-12;
				}

				public static Megamoles operator +(Megamoles first, Examoles second)
				{
					return new Megamoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Zettamoles(Megamoles value)
				{
					return (value.value)*1E-15;
				}

				public static Megamoles operator +(Megamoles first, Zettamoles second)
				{
					return new Megamoles(first.value + (second.value)*1E+15);
				}
								public static implicit operator Yottamoles(Megamoles value)
				{
					return (value.value)*1E-18;
				}

				public static Megamoles operator +(Megamoles first, Yottamoles second)
				{
					return new Megamoles(first.value + (second.value)*1E+18);
				}
						}
		}
namespace Multiples
{

		public struct Gigamoles : IValueWithUnit, IEquatable< Gigamoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Gigamoles Zero = new Gigamoles(0);
			public static readonly Gigamoles One = new Gigamoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.gigamole; } }

			public Gigamoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Gmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1000000000);
				}
				
			public bool Equals(Gigamoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Gigamoles(double value)
			{
				return new Gigamoles(value);
			}

			public static Gigamoles operator *(Gigamoles value, double times)
			{
				return new Gigamoles(value.value * times);
			}

			public static Gigamoles operator *(double times, Gigamoles value)
			{
				return new Gigamoles(value.value * times);
			}

			public static Gigamoles operator +(Gigamoles first, Gigamoles second)
			{
				return new Gigamoles(first.value * second.value);
			}

							public static implicit operator Moles(Gigamoles value)
				{
					return (value.value)*1000000000;
				}

				public static Gigamoles operator +(Gigamoles first, Moles second)
				{
					return new Gigamoles(first.value + (second.value)/1000000000);
				}
								public static implicit operator Yoctomoles(Gigamoles value)
				{
					return (value.value)*1E+33;
				}

				public static Gigamoles operator +(Gigamoles first, Yoctomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-33);
				}
								public static implicit operator Zeptomoles(Gigamoles value)
				{
					return (value.value)*1E+30;
				}

				public static Gigamoles operator +(Gigamoles first, Zeptomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Attomoles(Gigamoles value)
				{
					return (value.value)*1E+27;
				}

				public static Gigamoles operator +(Gigamoles first, Attomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Femtomoles(Gigamoles value)
				{
					return (value.value)*1E+24;
				}

				public static Gigamoles operator +(Gigamoles first, Femtomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Picomoles(Gigamoles value)
				{
					return (value.value)*1E+21;
				}

				public static Gigamoles operator +(Gigamoles first, Picomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Nanomoles(Gigamoles value)
				{
					return (value.value)*1E+18;
				}

				public static Gigamoles operator +(Gigamoles first, Nanomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Micromoles(Gigamoles value)
				{
					return (value.value)*1E+15;
				}

				public static Gigamoles operator +(Gigamoles first, Micromoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Millimoles(Gigamoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Gigamoles operator +(Gigamoles first, Millimoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Centimoles(Gigamoles value)
				{
					return (value.value)*100000000000;
				}

				public static Gigamoles operator +(Gigamoles first, Centimoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-11);
				}
								public static implicit operator Decimoles(Gigamoles value)
				{
					return (value.value)*10000000000;
				}

				public static Gigamoles operator +(Gigamoles first, Decimoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-10);
				}
								public static implicit operator Decamoles(Gigamoles value)
				{
					return (value.value)*100000000;
				}

				public static Gigamoles operator +(Gigamoles first, Decamoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-08);
				}
								public static implicit operator Hectomoles(Gigamoles value)
				{
					return (value.value)*10000000;
				}

				public static Gigamoles operator +(Gigamoles first, Hectomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-07);
				}
								public static implicit operator Kilomoles(Gigamoles value)
				{
					return (value.value)*1000000;
				}

				public static Gigamoles operator +(Gigamoles first, Kilomoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Megamoles(Gigamoles value)
				{
					return (value.value)*1000;
				}

				public static Gigamoles operator +(Gigamoles first, Megamoles second)
				{
					return new Gigamoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Teramoles(Gigamoles value)
				{
					return (value.value)*0.001;
				}

				public static Gigamoles operator +(Gigamoles first, Teramoles second)
				{
					return new Gigamoles(first.value + (second.value)*1000);
				}
								public static implicit operator Petamoles(Gigamoles value)
				{
					return (value.value)*1E-06;
				}

				public static Gigamoles operator +(Gigamoles first, Petamoles second)
				{
					return new Gigamoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Examoles(Gigamoles value)
				{
					return (value.value)*1E-09;
				}

				public static Gigamoles operator +(Gigamoles first, Examoles second)
				{
					return new Gigamoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Zettamoles(Gigamoles value)
				{
					return (value.value)*1E-12;
				}

				public static Gigamoles operator +(Gigamoles first, Zettamoles second)
				{
					return new Gigamoles(first.value + (second.value)*1000000000000);
				}
								public static implicit operator Yottamoles(Gigamoles value)
				{
					return (value.value)*1E-15;
				}

				public static Gigamoles operator +(Gigamoles first, Yottamoles second)
				{
					return new Gigamoles(first.value + (second.value)*1E+15);
				}
						}
		}
namespace Multiples
{

		public struct Teramoles : IValueWithUnit, IEquatable< Teramoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Teramoles Zero = new Teramoles(0);
			public static readonly Teramoles One = new Teramoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.teramole; } }

			public Teramoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Tmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1000000000000);
				}
				
			public bool Equals(Teramoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Teramoles(double value)
			{
				return new Teramoles(value);
			}

			public static Teramoles operator *(Teramoles value, double times)
			{
				return new Teramoles(value.value * times);
			}

			public static Teramoles operator *(double times, Teramoles value)
			{
				return new Teramoles(value.value * times);
			}

			public static Teramoles operator +(Teramoles first, Teramoles second)
			{
				return new Teramoles(first.value * second.value);
			}

							public static implicit operator Moles(Teramoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Teramoles operator +(Teramoles first, Moles second)
				{
					return new Teramoles(first.value + (second.value)/1000000000000);
				}
								public static implicit operator Yoctomoles(Teramoles value)
				{
					return (value.value)*1E+36;
				}

				public static Teramoles operator +(Teramoles first, Yoctomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-36);
				}
								public static implicit operator Zeptomoles(Teramoles value)
				{
					return (value.value)*1E+33;
				}

				public static Teramoles operator +(Teramoles first, Zeptomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-33);
				}
								public static implicit operator Attomoles(Teramoles value)
				{
					return (value.value)*1E+30;
				}

				public static Teramoles operator +(Teramoles first, Attomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Femtomoles(Teramoles value)
				{
					return (value.value)*1E+27;
				}

				public static Teramoles operator +(Teramoles first, Femtomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Picomoles(Teramoles value)
				{
					return (value.value)*1E+24;
				}

				public static Teramoles operator +(Teramoles first, Picomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Nanomoles(Teramoles value)
				{
					return (value.value)*1E+21;
				}

				public static Teramoles operator +(Teramoles first, Nanomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Micromoles(Teramoles value)
				{
					return (value.value)*1E+18;
				}

				public static Teramoles operator +(Teramoles first, Micromoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Millimoles(Teramoles value)
				{
					return (value.value)*1E+15;
				}

				public static Teramoles operator +(Teramoles first, Millimoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Centimoles(Teramoles value)
				{
					return (value.value)*100000000000000;
				}

				public static Teramoles operator +(Teramoles first, Centimoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-14);
				}
								public static implicit operator Decimoles(Teramoles value)
				{
					return (value.value)*10000000000000;
				}

				public static Teramoles operator +(Teramoles first, Decimoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-13);
				}
								public static implicit operator Decamoles(Teramoles value)
				{
					return (value.value)*100000000000;
				}

				public static Teramoles operator +(Teramoles first, Decamoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-11);
				}
								public static implicit operator Hectomoles(Teramoles value)
				{
					return (value.value)*10000000000;
				}

				public static Teramoles operator +(Teramoles first, Hectomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-10);
				}
								public static implicit operator Kilomoles(Teramoles value)
				{
					return (value.value)*1000000000;
				}

				public static Teramoles operator +(Teramoles first, Kilomoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Megamoles(Teramoles value)
				{
					return (value.value)*1000000;
				}

				public static Teramoles operator +(Teramoles first, Megamoles second)
				{
					return new Teramoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Gigamoles(Teramoles value)
				{
					return (value.value)*1000;
				}

				public static Teramoles operator +(Teramoles first, Gigamoles second)
				{
					return new Teramoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Petamoles(Teramoles value)
				{
					return (value.value)*0.001;
				}

				public static Teramoles operator +(Teramoles first, Petamoles second)
				{
					return new Teramoles(first.value + (second.value)*1000);
				}
								public static implicit operator Examoles(Teramoles value)
				{
					return (value.value)*1E-06;
				}

				public static Teramoles operator +(Teramoles first, Examoles second)
				{
					return new Teramoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Zettamoles(Teramoles value)
				{
					return (value.value)*1E-09;
				}

				public static Teramoles operator +(Teramoles first, Zettamoles second)
				{
					return new Teramoles(first.value + (second.value)*1000000000);
				}
								public static implicit operator Yottamoles(Teramoles value)
				{
					return (value.value)*1E-12;
				}

				public static Teramoles operator +(Teramoles first, Yottamoles second)
				{
					return new Teramoles(first.value + (second.value)*1000000000000);
				}
						}
		}
namespace Multiples
{

		public struct Petamoles : IValueWithUnit, IEquatable< Petamoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Petamoles Zero = new Petamoles(0);
			public static readonly Petamoles One = new Petamoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.petamole; } }

			public Petamoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Pmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E+15);
				}
				
			public bool Equals(Petamoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Petamoles(double value)
			{
				return new Petamoles(value);
			}

			public static Petamoles operator *(Petamoles value, double times)
			{
				return new Petamoles(value.value * times);
			}

			public static Petamoles operator *(double times, Petamoles value)
			{
				return new Petamoles(value.value * times);
			}

			public static Petamoles operator +(Petamoles first, Petamoles second)
			{
				return new Petamoles(first.value * second.value);
			}

							public static implicit operator Moles(Petamoles value)
				{
					return (value.value)*1E+15;
				}

				public static Petamoles operator +(Petamoles first, Moles second)
				{
					return new Petamoles(first.value + (second.value)/1E+15);
				}
								public static implicit operator Yoctomoles(Petamoles value)
				{
					return (value.value)*1E+39;
				}

				public static Petamoles operator +(Petamoles first, Yoctomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-39);
				}
								public static implicit operator Zeptomoles(Petamoles value)
				{
					return (value.value)*1E+36;
				}

				public static Petamoles operator +(Petamoles first, Zeptomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-36);
				}
								public static implicit operator Attomoles(Petamoles value)
				{
					return (value.value)*1E+33;
				}

				public static Petamoles operator +(Petamoles first, Attomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-33);
				}
								public static implicit operator Femtomoles(Petamoles value)
				{
					return (value.value)*1E+30;
				}

				public static Petamoles operator +(Petamoles first, Femtomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Picomoles(Petamoles value)
				{
					return (value.value)*1E+27;
				}

				public static Petamoles operator +(Petamoles first, Picomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Nanomoles(Petamoles value)
				{
					return (value.value)*1E+24;
				}

				public static Petamoles operator +(Petamoles first, Nanomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Micromoles(Petamoles value)
				{
					return (value.value)*1E+21;
				}

				public static Petamoles operator +(Petamoles first, Micromoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Millimoles(Petamoles value)
				{
					return (value.value)*1E+18;
				}

				public static Petamoles operator +(Petamoles first, Millimoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Centimoles(Petamoles value)
				{
					return (value.value)*1E+17;
				}

				public static Petamoles operator +(Petamoles first, Centimoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-17);
				}
								public static implicit operator Decimoles(Petamoles value)
				{
					return (value.value)*1E+16;
				}

				public static Petamoles operator +(Petamoles first, Decimoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-16);
				}
								public static implicit operator Decamoles(Petamoles value)
				{
					return (value.value)*100000000000000;
				}

				public static Petamoles operator +(Petamoles first, Decamoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-14);
				}
								public static implicit operator Hectomoles(Petamoles value)
				{
					return (value.value)*10000000000000;
				}

				public static Petamoles operator +(Petamoles first, Hectomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-13);
				}
								public static implicit operator Kilomoles(Petamoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Petamoles operator +(Petamoles first, Kilomoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Megamoles(Petamoles value)
				{
					return (value.value)*1000000000;
				}

				public static Petamoles operator +(Petamoles first, Megamoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Gigamoles(Petamoles value)
				{
					return (value.value)*1000000;
				}

				public static Petamoles operator +(Petamoles first, Gigamoles second)
				{
					return new Petamoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Teramoles(Petamoles value)
				{
					return (value.value)*1000;
				}

				public static Petamoles operator +(Petamoles first, Teramoles second)
				{
					return new Petamoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Examoles(Petamoles value)
				{
					return (value.value)*0.001;
				}

				public static Petamoles operator +(Petamoles first, Examoles second)
				{
					return new Petamoles(first.value + (second.value)*1000);
				}
								public static implicit operator Zettamoles(Petamoles value)
				{
					return (value.value)*1E-06;
				}

				public static Petamoles operator +(Petamoles first, Zettamoles second)
				{
					return new Petamoles(first.value + (second.value)*1000000);
				}
								public static implicit operator Yottamoles(Petamoles value)
				{
					return (value.value)*1E-09;
				}

				public static Petamoles operator +(Petamoles first, Yottamoles second)
				{
					return new Petamoles(first.value + (second.value)*1000000000);
				}
						}
		}
namespace Multiples
{

		public struct Examoles : IValueWithUnit, IEquatable< Examoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Examoles Zero = new Examoles(0);
			public static readonly Examoles One = new Examoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.examole; } }

			public Examoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Emol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E+18);
				}
				
			public bool Equals(Examoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Examoles(double value)
			{
				return new Examoles(value);
			}

			public static Examoles operator *(Examoles value, double times)
			{
				return new Examoles(value.value * times);
			}

			public static Examoles operator *(double times, Examoles value)
			{
				return new Examoles(value.value * times);
			}

			public static Examoles operator +(Examoles first, Examoles second)
			{
				return new Examoles(first.value * second.value);
			}

							public static implicit operator Moles(Examoles value)
				{
					return (value.value)*1E+18;
				}

				public static Examoles operator +(Examoles first, Moles second)
				{
					return new Examoles(first.value + (second.value)/1E+18);
				}
								public static implicit operator Yoctomoles(Examoles value)
				{
					return (value.value)*1E+42;
				}

				public static Examoles operator +(Examoles first, Yoctomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-42);
				}
								public static implicit operator Zeptomoles(Examoles value)
				{
					return (value.value)*1E+39;
				}

				public static Examoles operator +(Examoles first, Zeptomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-39);
				}
								public static implicit operator Attomoles(Examoles value)
				{
					return (value.value)*1E+36;
				}

				public static Examoles operator +(Examoles first, Attomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-36);
				}
								public static implicit operator Femtomoles(Examoles value)
				{
					return (value.value)*1E+33;
				}

				public static Examoles operator +(Examoles first, Femtomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-33);
				}
								public static implicit operator Picomoles(Examoles value)
				{
					return (value.value)*1E+30;
				}

				public static Examoles operator +(Examoles first, Picomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Nanomoles(Examoles value)
				{
					return (value.value)*1E+27;
				}

				public static Examoles operator +(Examoles first, Nanomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Micromoles(Examoles value)
				{
					return (value.value)*1E+24;
				}

				public static Examoles operator +(Examoles first, Micromoles second)
				{
					return new Examoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Millimoles(Examoles value)
				{
					return (value.value)*1E+21;
				}

				public static Examoles operator +(Examoles first, Millimoles second)
				{
					return new Examoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Centimoles(Examoles value)
				{
					return (value.value)*1E+20;
				}

				public static Examoles operator +(Examoles first, Centimoles second)
				{
					return new Examoles(first.value + (second.value)*1E-20);
				}
								public static implicit operator Decimoles(Examoles value)
				{
					return (value.value)*1E+19;
				}

				public static Examoles operator +(Examoles first, Decimoles second)
				{
					return new Examoles(first.value + (second.value)*1E-19);
				}
								public static implicit operator Decamoles(Examoles value)
				{
					return (value.value)*1E+17;
				}

				public static Examoles operator +(Examoles first, Decamoles second)
				{
					return new Examoles(first.value + (second.value)*1E-17);
				}
								public static implicit operator Hectomoles(Examoles value)
				{
					return (value.value)*1E+16;
				}

				public static Examoles operator +(Examoles first, Hectomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-16);
				}
								public static implicit operator Kilomoles(Examoles value)
				{
					return (value.value)*1E+15;
				}

				public static Examoles operator +(Examoles first, Kilomoles second)
				{
					return new Examoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Megamoles(Examoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Examoles operator +(Examoles first, Megamoles second)
				{
					return new Examoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Gigamoles(Examoles value)
				{
					return (value.value)*1000000000;
				}

				public static Examoles operator +(Examoles first, Gigamoles second)
				{
					return new Examoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Teramoles(Examoles value)
				{
					return (value.value)*1000000;
				}

				public static Examoles operator +(Examoles first, Teramoles second)
				{
					return new Examoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Petamoles(Examoles value)
				{
					return (value.value)*1000;
				}

				public static Examoles operator +(Examoles first, Petamoles second)
				{
					return new Examoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Zettamoles(Examoles value)
				{
					return (value.value)*0.001;
				}

				public static Examoles operator +(Examoles first, Zettamoles second)
				{
					return new Examoles(first.value + (second.value)*1000);
				}
								public static implicit operator Yottamoles(Examoles value)
				{
					return (value.value)*1E-06;
				}

				public static Examoles operator +(Examoles first, Yottamoles second)
				{
					return new Examoles(first.value + (second.value)*1000000);
				}
						}
		}
namespace Multiples
{

		public struct Zettamoles : IValueWithUnit, IEquatable< Zettamoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Zettamoles Zero = new Zettamoles(0);
			public static readonly Zettamoles One = new Zettamoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.zettamole; } }

			public Zettamoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Zmol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E+21);
				}
				
			public bool Equals(Zettamoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Zettamoles(double value)
			{
				return new Zettamoles(value);
			}

			public static Zettamoles operator *(Zettamoles value, double times)
			{
				return new Zettamoles(value.value * times);
			}

			public static Zettamoles operator *(double times, Zettamoles value)
			{
				return new Zettamoles(value.value * times);
			}

			public static Zettamoles operator +(Zettamoles first, Zettamoles second)
			{
				return new Zettamoles(first.value * second.value);
			}

							public static implicit operator Moles(Zettamoles value)
				{
					return (value.value)*1E+21;
				}

				public static Zettamoles operator +(Zettamoles first, Moles second)
				{
					return new Zettamoles(first.value + (second.value)/1E+21);
				}
								public static implicit operator Yoctomoles(Zettamoles value)
				{
					return (value.value)*1E+45;
				}

				public static Zettamoles operator +(Zettamoles first, Yoctomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-45);
				}
								public static implicit operator Zeptomoles(Zettamoles value)
				{
					return (value.value)*1E+42;
				}

				public static Zettamoles operator +(Zettamoles first, Zeptomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-42);
				}
								public static implicit operator Attomoles(Zettamoles value)
				{
					return (value.value)*1E+39;
				}

				public static Zettamoles operator +(Zettamoles first, Attomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-39);
				}
								public static implicit operator Femtomoles(Zettamoles value)
				{
					return (value.value)*1E+36;
				}

				public static Zettamoles operator +(Zettamoles first, Femtomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-36);
				}
								public static implicit operator Picomoles(Zettamoles value)
				{
					return (value.value)*1E+33;
				}

				public static Zettamoles operator +(Zettamoles first, Picomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-33);
				}
								public static implicit operator Nanomoles(Zettamoles value)
				{
					return (value.value)*1E+30;
				}

				public static Zettamoles operator +(Zettamoles first, Nanomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Micromoles(Zettamoles value)
				{
					return (value.value)*1E+27;
				}

				public static Zettamoles operator +(Zettamoles first, Micromoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Millimoles(Zettamoles value)
				{
					return (value.value)*1E+24;
				}

				public static Zettamoles operator +(Zettamoles first, Millimoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-24);
				}
								public static implicit operator Centimoles(Zettamoles value)
				{
					return (value.value)*1E+23;
				}

				public static Zettamoles operator +(Zettamoles first, Centimoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-23);
				}
								public static implicit operator Decimoles(Zettamoles value)
				{
					return (value.value)*1E+22;
				}

				public static Zettamoles operator +(Zettamoles first, Decimoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-22);
				}
								public static implicit operator Decamoles(Zettamoles value)
				{
					return (value.value)*1E+20;
				}

				public static Zettamoles operator +(Zettamoles first, Decamoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-20);
				}
								public static implicit operator Hectomoles(Zettamoles value)
				{
					return (value.value)*1E+19;
				}

				public static Zettamoles operator +(Zettamoles first, Hectomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-19);
				}
								public static implicit operator Kilomoles(Zettamoles value)
				{
					return (value.value)*1E+18;
				}

				public static Zettamoles operator +(Zettamoles first, Kilomoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Megamoles(Zettamoles value)
				{
					return (value.value)*1E+15;
				}

				public static Zettamoles operator +(Zettamoles first, Megamoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Gigamoles(Zettamoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Zettamoles operator +(Zettamoles first, Gigamoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Teramoles(Zettamoles value)
				{
					return (value.value)*1000000000;
				}

				public static Zettamoles operator +(Zettamoles first, Teramoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Petamoles(Zettamoles value)
				{
					return (value.value)*1000000;
				}

				public static Zettamoles operator +(Zettamoles first, Petamoles second)
				{
					return new Zettamoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Examoles(Zettamoles value)
				{
					return (value.value)*1000;
				}

				public static Zettamoles operator +(Zettamoles first, Examoles second)
				{
					return new Zettamoles(first.value + (second.value)*0.001);
				}
								public static implicit operator Yottamoles(Zettamoles value)
				{
					return (value.value)*0.001;
				}

				public static Zettamoles operator +(Zettamoles first, Yottamoles second)
				{
					return new Zettamoles(first.value + (second.value)*1000);
				}
						}
		}
namespace Multiples
{

		public struct Yottamoles : IValueWithUnit, IEquatable< Yottamoles >, IEquatable<IValueWithUnit>
		{
			public static readonly Yottamoles Zero = new Yottamoles(0);
			public static readonly Yottamoles One = new Yottamoles(1);

			readonly internal double value;
			public double Value { get { return value; } }

			public Unit Unit { get { return AmountOfSubstance.Units.yottamole; } }

			public Yottamoles(double value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return ToStringCore("G", CultureInfo.CurrentCulture);
			}

			public string ToString(IFormatProvider provider)
			{
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore("G", provider);
			}

			public string ToString(string format)
			{
				if (format == null) throw new ArgumentNullException("format");

				return ToStringCore(format, CultureInfo.CurrentCulture);
			}

			public string ToString(string format, IFormatProvider provider)
			{
				if (format == null) throw new ArgumentNullException("format");
				if (provider == null) throw new ArgumentNullException("provider");

				return ToStringCore(format, provider);
			}

			string ToStringCore(string format, IFormatProvider provider)
			{
				return string.Format("{0} Ymol", value.ToString(format, provider));
			}

			IValueWithUnit IValueWithUnit.ToBaseUnit()
			{
									return this.ToBaseUnit();
								}

							public Moles ToBaseUnit()
				{
					return new Moles((this.value)*1E+24);
				}
				
			public bool Equals(Yottamoles other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return other.value == value;
			}
			
			public bool Equals(IValueWithUnit other)
			{
				if (ReferenceEquals(other, null)) return false;
				else return false;
			}
			
			public override bool Equals(object other)
			{
				return Equals(other as IValueWithUnit);
			}
			
			public override int GetHashCode()
			{
				return value.GetHashCode();
			}

			public static implicit operator Yottamoles(double value)
			{
				return new Yottamoles(value);
			}

			public static Yottamoles operator *(Yottamoles value, double times)
			{
				return new Yottamoles(value.value * times);
			}

			public static Yottamoles operator *(double times, Yottamoles value)
			{
				return new Yottamoles(value.value * times);
			}

			public static Yottamoles operator +(Yottamoles first, Yottamoles second)
			{
				return new Yottamoles(first.value * second.value);
			}

							public static implicit operator Moles(Yottamoles value)
				{
					return (value.value)*1E+24;
				}

				public static Yottamoles operator +(Yottamoles first, Moles second)
				{
					return new Yottamoles(first.value + (second.value)/1E+24);
				}
								public static implicit operator Yoctomoles(Yottamoles value)
				{
					return (value.value)*1E+48;
				}

				public static Yottamoles operator +(Yottamoles first, Yoctomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-48);
				}
								public static implicit operator Zeptomoles(Yottamoles value)
				{
					return (value.value)*1E+45;
				}

				public static Yottamoles operator +(Yottamoles first, Zeptomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-45);
				}
								public static implicit operator Attomoles(Yottamoles value)
				{
					return (value.value)*1E+42;
				}

				public static Yottamoles operator +(Yottamoles first, Attomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-42);
				}
								public static implicit operator Femtomoles(Yottamoles value)
				{
					return (value.value)*1E+39;
				}

				public static Yottamoles operator +(Yottamoles first, Femtomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-39);
				}
								public static implicit operator Picomoles(Yottamoles value)
				{
					return (value.value)*1E+36;
				}

				public static Yottamoles operator +(Yottamoles first, Picomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-36);
				}
								public static implicit operator Nanomoles(Yottamoles value)
				{
					return (value.value)*1E+33;
				}

				public static Yottamoles operator +(Yottamoles first, Nanomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-33);
				}
								public static implicit operator Micromoles(Yottamoles value)
				{
					return (value.value)*1E+30;
				}

				public static Yottamoles operator +(Yottamoles first, Micromoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-30);
				}
								public static implicit operator Millimoles(Yottamoles value)
				{
					return (value.value)*1E+27;
				}

				public static Yottamoles operator +(Yottamoles first, Millimoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-27);
				}
								public static implicit operator Centimoles(Yottamoles value)
				{
					return (value.value)*1E+26;
				}

				public static Yottamoles operator +(Yottamoles first, Centimoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-26);
				}
								public static implicit operator Decimoles(Yottamoles value)
				{
					return (value.value)*1E+25;
				}

				public static Yottamoles operator +(Yottamoles first, Decimoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-25);
				}
								public static implicit operator Decamoles(Yottamoles value)
				{
					return (value.value)*1E+23;
				}

				public static Yottamoles operator +(Yottamoles first, Decamoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-23);
				}
								public static implicit operator Hectomoles(Yottamoles value)
				{
					return (value.value)*1E+22;
				}

				public static Yottamoles operator +(Yottamoles first, Hectomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-22);
				}
								public static implicit operator Kilomoles(Yottamoles value)
				{
					return (value.value)*1E+21;
				}

				public static Yottamoles operator +(Yottamoles first, Kilomoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-21);
				}
								public static implicit operator Megamoles(Yottamoles value)
				{
					return (value.value)*1E+18;
				}

				public static Yottamoles operator +(Yottamoles first, Megamoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-18);
				}
								public static implicit operator Gigamoles(Yottamoles value)
				{
					return (value.value)*1E+15;
				}

				public static Yottamoles operator +(Yottamoles first, Gigamoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-15);
				}
								public static implicit operator Teramoles(Yottamoles value)
				{
					return (value.value)*1000000000000;
				}

				public static Yottamoles operator +(Yottamoles first, Teramoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-12);
				}
								public static implicit operator Petamoles(Yottamoles value)
				{
					return (value.value)*1000000000;
				}

				public static Yottamoles operator +(Yottamoles first, Petamoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-09);
				}
								public static implicit operator Examoles(Yottamoles value)
				{
					return (value.value)*1000000;
				}

				public static Yottamoles operator +(Yottamoles first, Examoles second)
				{
					return new Yottamoles(first.value + (second.value)*1E-06);
				}
								public static implicit operator Zettamoles(Yottamoles value)
				{
					return (value.value)*1000;
				}

				public static Yottamoles operator +(Yottamoles first, Zettamoles second)
				{
					return new Yottamoles(first.value + (second.value)*0.001);
				}
						}
		}
}